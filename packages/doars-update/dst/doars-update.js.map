{
  "version": 3,
  "sources": ["../src/factories/contexts/createUpdate.js", "../src/factories/directives/createUpdate.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../src/Updater.js", "../src/DoarsUpdate.js"],
  "sourcesContent": ["export default (updater) => {\n  // Deconstruct updater.\n  const id = updater.getId()\n  const proxy = updater.getProxy()\n  const time = updater.getTime()\n\n  return {\n    name: '$update',\n\n    create: (component, attribute) => {\n      // Create event handlers.\n      const onGet = (target, path) => attribute.accessed(id, path.join('.'))\n\n      // Add event listeners.\n      proxy.addEventListener('get', onGet)\n\n      return {\n        value: time,\n\n        // Remove event listeners.\n        destroy: () => {\n          proxy.removeEventListener('get', onGet)\n        },\n      }\n    },\n  }\n}\n", "export default (options) => {\n  // Overwrite default options.\n  options = Object.assign({\n    defaultOrder: 500,\n  }, options)\n\n  // Create list of update directives.\n  const itemIds = []\n  const items = []\n\n  const directive = {\n    name: 'update',\n\n    update: function (component, attribute, { processExpression }) {\n      // Store execute expression locally.\n      if (!this._execute) {\n        this._execute = processExpression\n      }\n\n      // Deconstruct attribute.\n      const id = attribute.getId()\n\n      // Exit early if already in list.\n      if (itemIds.indexOf(id) >= 0) {\n        return\n      }\n\n      // Deconstruct attribute.\n      let { order } = attribute.getModifiers()\n      if (!order) {\n        order = options.defaultOrder\n      }\n\n      // Get index to place item at based on order.\n      let index = 0\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].order >= order) {\n          index = i\n          break\n        }\n      }\n\n      // Add item at index in list.\n      items.splice(index, 0, {\n        attribute,\n        component,\n        order,\n      })\n    },\n\n    destroy: (component, attribute) => {\n      // Deconstruct attribute.\n      const id = attribute.getId()\n\n      // Exit early if already in list.\n      const index = itemIds.indexOf(id)\n      if (index >= 0) {\n        return\n      }\n\n      // Remove attribute id from item ids list.\n      itemIds.splice(index, 1)\n\n      // Remove attribute from items list.\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].attribute === attribute) {\n          // Remove item from list.\n          items.splice(i, 1)\n          break\n        }\n      }\n    },\n  }\n\n  return [directive, () => {\n    // Run expression of each item in order.\n    for (const item of items) {\n      directive._execute(item.component, item.attribute.clone(), item.attribute.getValue(), {}, { return: false })\n    }\n  }]\n}\n", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\nexport default (target, handler) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  const revocableHandler = {}\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy')\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n    this.removeEventListeners = (name) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n\nexport default EventDispatcher\n", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n// Import event dispatcher.\nimport EventDispatcher from './EventDispatcher.js'\n\nclass ProxyDispatcher extends EventDispatcher {\n  constructor(options = {}) {\n    super()\n\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true,\n    }, options)\n\n    // Setup WeakMap for keep track of created proxies.\n    const map = new WeakMap()\n\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n    this.add = (target, path = []) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target)\n      }\n\n      // Recursively create proxies for each property.\n      for (const key in target) {\n        if (target[key] && typeof (target[key]) === 'object') {\n          target[key] = this.add(target[key], [...path, key])\n        }\n      }\n\n      // Create handler and add the handler for which a callback exits..\n      const handler = {}\n\n      if (options.delete) {\n        handler.deleteProperty = (target, key) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true\n          }\n\n          // Remove proxy.\n          this.remove(target, key)\n\n          // Delete property.\n          const deleted = Reflect.deleteProperty(target, key)\n\n          // Dispatch delete event.\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]])\n          }\n\n          // Return deleted.\n          return deleted\n        }\n      }\n\n      if (options.get) {\n        handler.get = (target, key, receiver) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver])\n          }\n\n          // Return value from object.\n          return Reflect.get(target, key, receiver)\n        }\n      }\n\n      if (options.set) {\n        handler.set = (target, key, value, receiver) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true\n          }\n\n          // Add proxy if value is an object.\n          if (value && typeof value === 'object') {\n            value = this.add(value, [...path, key])\n          }\n          // Store value.\n          target[key] = value\n\n          // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver])\n\n          // Return success.\n          return true\n        }\n      }\n\n      // Create proxy.\n      const revocable = RevocableProxy(target, handler)\n\n      // Store target at proxy.\n      map.set(revocable, target)\n\n      // Return proxy.\n      return revocable.proxy\n    }\n\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n    this.remove = (target) => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return\n      }\n\n      const revocable = map.get(target)\n      map.delete(revocable)\n\n      // Recursively remove properties as well.\n      for (const property in revocable.proxy) {\n        if (typeof (revocable.proxy[property]) === 'object') {\n          this.remove(revocable.proxy[property])\n        }\n      }\n\n      // Revoke proxy.\n      revocable.revoke()\n    }\n  }\n}\n\nexport default ProxyDispatcher\n", "// Import proxy dispatcher.\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\n\nexport default class Updater {\n  constructor(options, callback) {\n    // Overwrite default options.\n    options = Object.assign({\n      stepMinimum: 0,\n    }, options)\n\n    // Create id.\n    const id = Symbol('ID_UPDATE')\n\n    // Set private variables.\n    let isEnabled = false, request\n\n    // Setup time proxy.\n    const proxy = new ProxyDispatcher({\n      // We don't care when they are updated, we have a callback for that. They should never be updated by the user anyway.\n      delete: false,\n      set: false,\n    })\n    const time = proxy.add({})\n\n    const update = (timeAbsolute) => {\n      // Exit if not enabled any more.\n      if (!isEnabled) {\n        return\n      }\n\n      // Request to be updated next frame.\n      request = window.requestAnimationFrame(update)\n\n      // Set initial time values.\n      if (!time.startMs) {\n        time.currentMs = time.lastMs = time.startMs = timeAbsolute\n        time.current = time.last = time.start = timeAbsolute / 1000\n        time.delta = time.passed = time.deltaMs = time.passedMs = 0\n\n        // Exit early after initial update.\n        return\n      }\n\n      // Check if minimum time has been elapsed.\n      const deltaMs = timeAbsolute - time.lastMs\n      if (deltaMs <= options.stepMinimum) {\n        return\n      }\n\n      // Update time values.\n      time.lastMs = time.currentMs\n      time.last = time.current\n      time.currentMs = timeAbsolute\n      time.current = timeAbsolute / 1000\n      time.deltaMs = deltaMs\n      time.delta = deltaMs / 1000\n      time.passedMs += deltaMs // Adding the delta could introduce drift because we are not measuring from the start time, hover doing so would case issues if the updater is disabled and later on re-enabled. Due to the high precession the drift will only cause a noticeable effect after a long time, long enough to not cause a problem in most use cases. Long story short, good enough.\n      time.passed = time.passedMs / 1000\n\n      // Invoke callback.\n      callback()\n    }\n\n    /**\n     * Get whether the instance is enabled.\n     * @returns {Bool} Whether the instance is enabled.\n     */\n    this.isEnabled = () => {\n      return isEnabled\n    }\n\n    /**\n     * Get updater id.\n     * @returns {Symbol} Unique identifier.\n     */\n    this.getId = () => {\n      return id\n    }\n\n    /**\n     * Get time proxy.\n     * @returns {ProxyDispatcher} Time proxy.\n     */\n    this.getProxy = () => {\n      return proxy\n    }\n\n    /**\n     * Get time data.\n     * @returns {Proxy} Time data.\n     */\n    this.getTime = () => {\n      return time\n    }\n\n    /**\n     * Enable updater.\n     */\n    this.enable = () => {\n      if (isEnabled) {\n        return\n      }\n      isEnabled = true\n\n      // Start update loop.\n      request = window.requestAnimationFrame(update)\n    }\n\n    /**\n     * Disable updater.\n     */\n    this.disable = () => {\n      if (!isEnabled) {\n        return\n      }\n      isEnabled = false\n\n      // Stop updating.\n      if (request) {\n        cancelAnimationFrame(request)\n        request = null\n      }\n    }\n  }\n}\n", "// Import contexts.\nimport createContextUpdate from './factories/contexts/createUpdate.js'\n\n// Import directives.\nimport createDirectiveUpdate from './factories/directives/createUpdate.js'\n\n// Import updater.\nimport Updater from './Updater.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null\n) {\n  // Clone options.\n  options = Object.assign({}, options)\n\n  // Set private variables.\n  let isEnabled = false\n  let contextUpdate, directiveUpdate, updater\n\n  const onEnable = function () {\n    // Create and add directive.\n    const [_directiveUpdate, update] = createDirectiveUpdate(options)\n    directiveUpdate = _directiveUpdate\n    library.addDirectives(-1, directiveUpdate)\n\n    // Setup update loop.\n    updater = new Updater(options, () => {\n      // Update all directives.\n      update()\n\n      // Dispatch update triggers.\n      library.update([{\n        id: updater.getId(),\n        path: 'current',\n      }, {\n        id: updater.getId(),\n        path: 'delta',\n      }, {\n        id: updater.getId(),\n        path: 'last',\n      }, {\n        id: updater.getId(),\n        path: 'passed',\n      }])\n    })\n\n    // Create and add context.\n    contextUpdate = createContextUpdate(updater)\n    library.addContexts(0, contextUpdate)\n\n    // Enable updater.\n    updater.enable()\n  }\n  const onDisable = function () {\n    // Remove context.\n    library.removeContexts(contextUpdate)\n\n    // Remove directive.\n    library.removeDirectives(directiveUpdate)\n\n    // Disable updater.\n    updater.disable()\n\n    // Reset private variables.\n    contextUpdate = null\n    directiveUpdate = null\n    updater = null\n  }\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"],
  "mappings": "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",
  "names": ["createUpdate_default", "target", "createUpdate_default"]
}
