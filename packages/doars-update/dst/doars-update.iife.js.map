{
  "version": 3,
  "sources": ["../src/contexts/update.js", "../src/directives/update.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../src/Updater.js", "../src/DoarsUpdate.js", "../src/DoarsUpdate.iife.js"],
  "sourcesContent": [
    "export default (\n  {\n    updateContextName,\n  },\n  updater,\n) => {\n  // Deconstruct updater.\n  const id = updater.getId()\n  const proxy = updater.getProxy()\n  const time = updater.getTime()\n\n  return {\n    name: updateContextName,\n\n    create: (\n      component,\n      attribute,\n    ) => {\n      // Create event handlers.\n      const onGet = (\n        target,\n        path,\n      ) => attribute.accessed(id, path.join('.'))\n\n      // Add event listeners.\n      proxy.addEventListener('get', onGet)\n\n      return {\n        value: time,\n\n        // Remove event listeners.\n        destroy: (\n        ) => {\n          proxy.removeEventListener('get', onGet)\n        },\n      }\n    },\n  }\n}\n",
    "export default ({\n  defaultOrder,\n  updateDirectiveName,\n}) => {\n  // Create list of update directives.\n  const itemIds = []\n  const items = []\n\n  const directive = {\n    name: updateDirectiveName,\n\n    update: (\n      component,\n      attribute,\n      processExpression,\n    ) => {\n      // Store execute expression locally.\n      if (!directive._execute) {\n        directive._execute = processExpression\n      }\n\n      // Deconstruct attribute.\n      const id = attribute.getId()\n\n      // Exit early if already in list.\n      if (itemIds.indexOf(id) >= 0) {\n        return\n      }\n\n      // Deconstruct attribute.\n      let { order } = attribute.getModifiers()\n      if (!order) {\n        order = defaultOrder\n      }\n\n      // Get index to place item at based on order.\n      let index = 0\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].order >= order) {\n          index = i\n          break\n        }\n      }\n\n      // Add item at index in list.\n      items.splice(index, 0, {\n        attribute,\n        component,\n        order,\n      })\n    },\n\n    destroy: (\n      component,\n      attribute,\n    ) => {\n      // Deconstruct attribute.\n      const id = attribute.getId()\n\n      // Exit early if already in list.\n      const index = itemIds.indexOf(id)\n      if (index >= 0) {\n        return\n      }\n\n      // Remove attribute id from item ids list.\n      itemIds.splice(index, 1)\n\n      // Remove attribute from items list.\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].attribute === attribute) {\n          // Remove item from list.\n          items.splice(i, 1)\n          break\n        }\n      }\n    },\n  }\n\n  return [\n    directive,\n    () => {\n      // Run expression of each item in order.\n      for (const item of items) {\n        directive._execute(\n          item.component,\n          item.attribute.clone(),\n          item.attribute.getValue(),\n          {},\n          {\n            return: false,\n          },\n        )\n      }\n    },\n  ]\n}\n",
    "/**\n * Function to call to revoke the proxy.\n * @callback RevocableProxyCallback\n */\n\n/**\n * @typedef RevocableProxy\n * @type {object}\n * @property {Proxy} proxy Proxy that will be revocable.\n * @property {RevocableProxyCallback} revoke Function to call to revoke the proxy.\n */\n\n/**\n * Function called when a proxy has been handled.\n * @callback ProxyHandlerCallback\n */\n\n/**\n * @typedef ProxyHandler\n * @type {object}\n * @property {?ProxyHandlerCallback} apply A trap method for a function call.\n * @property {?ProxyHandlerCallback} construct A trap for the `new` operator.\n * @property {?ProxyHandlerCallback} defineProperty A trap for `Object.defineProperty()`.\n * @property {?ProxyHandlerCallback} deleteProperty A trap for the `delete` operator.\n * @property {?ProxyHandlerCallback} get A trap for getting a property value.\n * @property {?ProxyHandlerCallback} getOwnPropertyDescriptor A trap for `Object.getOwnPropertyDescriptor()`.\n * @property {?ProxyHandlerCallback} getPrototypeOf A trap for the `[[GetPrototypeOf]]` internal method.\n * @property {?ProxyHandlerCallback} has A trap for the `in` operator.\n * @property {?ProxyHandlerCallback} isExtensible A trap for `Object.isExtensible()`.\n * @property {?ProxyHandlerCallback} ownKeys A trap for `Reflect.ownKeys()`.\n * @property {?ProxyHandlerCallback} preventExtensions A trap for `Object.preventExtensions()`.\n * @property {?ProxyHandlerCallback} set A trap for setting a property value.\n * @property {?ProxyHandlerCallback} setPrototypeOf A trap for `Object.setPrototypeOf()`.\n */\n\n// List of methods to revoke access to.\nconst PROXY_TRAPS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'has',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n * @param {object} target Object to proxy.\n * @param {ProxyHandler} handler Object of handler methods.\n * @returns {?RevocableProxy} Proxy object and revoke method.\n */\nexport default (\n  target,\n  handler,\n) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  /**\n   * Copy of allowed handlers with a revocable layer in between.\n   * @type {ProxyHandler}\n   */\n  const revocableHandler = {}\n  for (const key of PROXY_TRAPS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n",
    "/**\n * @typedef EventListenerOptions\n * @type {object}\n * @property {?boolean} once Whether to call the listener only once.\n */\n\n/**\n * @typedef DispatchEventOptions\n * @type {object}\n * @property {?boolean} reverse Whether to call the listeners in reverse order.\n */\n\nexport default class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor(\n  ) {\n    /**\n     * Object to store event listeners for the EventDispatcher class.\n     * @type {Record<string, Array<{callback: Function, options: EventListenerOptions }>>}\n     */\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {EventListenerOptions} options Callback options.\n     */\n    this.addEventListener = (\n      name,\n      callback,\n      options = null,\n    ) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (\n      name,\n      callback,\n    ) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {string} name Event name.\n     */\n    this.removeEventListeners = (\n      name,\n    ) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     */\n    this.removeAllEventListeners = (\n    ) => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {string} name Event name.\n     * @param {Array<any>} parameters Event parameters to pass through.\n     * @param {DispatchEventOptions} options Dispatch options.\n     */\n    this.dispatchEvent = (\n      name,\n      parameters,\n      options = null,\n    ) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n",
    "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n// Import event dispatcher.\nimport EventDispatcher from './EventDispatcher.js'\n\n/**\n * @typedef ProxyOptions\n * @type {object}\n * @property {?boolean} delete Whether to dispatch an event on delete.\n * @property {?boolean} get Whether to dispatch an event on get.\n * @property {?boolean} set Whether to dispatch an event on set.\n */\n\nexport default class ProxyDispatcher extends EventDispatcher {\n  /**\n   * Creates a proxy dispatcher instance.\n   * @param {ProxyOptions} options Options for proxy dispatcher.\n   */\n  constructor(\n    options = {},\n  ) {\n    super()\n\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true,\n    }, options)\n\n    // Setup WeakMap for keep track of created proxies.\n    const map = new WeakMap()\n\n    /**\n     * Add object to start keeping track of it.\n     * @param {object} target Object that is being kept track of.\n     * @param {Array<string>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n    this.add = (\n      target,\n      path = [],\n    ) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target)\n      }\n\n      // Recursively create proxies for each property.\n      for (const key in target) {\n        if (target[key] && typeof (target[key]) === 'object') {\n          target[key] = this.add(target[key], [...path, key])\n        }\n      }\n\n      // Create handler and add the handler for which a callback exits..\n      const handler = {}\n\n      if (options.delete) {\n        handler.deleteProperty = (\n          target,\n          key,\n        ) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true\n          }\n\n          // Remove proxy.\n          this.remove(target, key)\n\n          // Delete property.\n          const deleted = Reflect.deleteProperty(target, key)\n\n          // Dispatch delete event.\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]])\n          }\n\n          // Return deleted.\n          return deleted\n        }\n      }\n\n      if (options.get) {\n        handler.get = (\n          target,\n          key,\n          receiver,\n        ) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver])\n          }\n\n          // Return value from object.\n          return Reflect.get(target, key, receiver)\n        }\n      }\n\n      if (options.set) {\n        handler.set = (\n          target,\n          key,\n          value,\n          receiver,\n        ) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true\n          }\n\n          // Add proxy if value is an object.\n          if (value && typeof value === 'object') {\n            value = this.add(value, [...path, key])\n          }\n          // Store value.\n          target[key] = value\n\n          // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver])\n\n          // Return success.\n          return true\n        }\n      }\n\n      // Create proxy.\n      const revocable = RevocableProxy(target, handler)\n\n      // Store target at proxy.\n      map.set(revocable, target)\n\n      // Return proxy.\n      return revocable.proxy\n    }\n\n    /**\n     * Remove object from being kept track of.\n     * @param {object} target Object that is being kept track of.\n     */\n    this.remove = (\n      target,\n    ) => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return\n      }\n\n      const revocable = map.get(target)\n      map.delete(revocable)\n\n      // Recursively remove properties as well.\n      for (const property in revocable.proxy) {\n        if (typeof (revocable.proxy[property]) === 'object') {\n          this.remove(revocable.proxy[property])\n        }\n      }\n\n      // Revoke proxy.\n      revocable.revoke()\n    }\n  }\n}\n",
    "// Import proxy dispatcher.\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\n\n/**\n * @callback UpdateCallback\n */\n\nexport default class Updater {\n  /**\n   * @param {object} options Updater options.\n   * @param {number} options.stepMinimum Minimum duration of a tick in milliseconds.\n   * @param {UpdateCallback} callback Called every update tick.\n   */\n  constructor(\n    {\n      stepMinimum,\n    },\n    callback,\n  ) {\n    // Create id.\n    const id = Symbol('ID_UPDATE')\n\n    // Set private variables.\n    let isEnabled = false, request\n\n    // Setup time proxy.\n    const proxy = new ProxyDispatcher({\n      // We don't care when they are updated, we have a callback for that. They should never be updated by the user anyway.\n      delete: false,\n      set: false,\n    })\n    const time = proxy.add({})\n\n    /**\n     * @param {number} timeAbsolute timestamp in milliseconds.\n     */\n    const update = (\n      timeAbsolute,\n    ) => {\n      // Exit if not enabled any more.\n      if (!isEnabled) {\n        return\n      }\n\n      // Request to be updated next frame.\n      request = window.requestAnimationFrame(update)\n\n      // Set initial time values.\n      if (!time.startMs) {\n        time.currentMs = time.lastMs = time.startMs = timeAbsolute\n        time.current = time.last = time.start = timeAbsolute / 1000\n        time.delta = time.passed = time.deltaMs = time.passedMs = 0\n\n        // Exit early after initial update.\n        return\n      }\n\n      // Check if minimum time has been elapsed.\n      const deltaMs = timeAbsolute - time.lastMs\n      if (deltaMs <= stepMinimum) {\n        return\n      }\n\n      // Update time values.\n      time.lastMs = time.currentMs\n      time.last = time.current\n      time.currentMs = timeAbsolute\n      time.current = timeAbsolute / 1000\n      time.deltaMs = deltaMs\n      time.delta = deltaMs / 1000\n      time.passedMs += deltaMs // Adding the delta could introduce drift because we are not measuring from the start time, hover doing so would case issues if the updater is disabled and later on re-enabled. Due to the high precession the drift will only cause a noticeable effect after a long time, long enough to not cause a problem in most use cases. Long story short, good enough.\n      time.passed = time.passedMs / 1000\n\n      // Invoke callback.\n      callback()\n    }\n\n    /**\n     * Get whether the instance is enabled.\n     * @returns {boolean} Whether the instance is enabled.\n     */\n    this.isEnabled = () => {\n      return isEnabled\n    }\n\n    /**\n     * Get updater id.\n     * @returns {symbol} Unique identifier.\n     */\n    this.getId = () => {\n      return id\n    }\n\n    /**\n     * Get time proxy.\n     * @returns {ProxyDispatcher} Time proxy.\n     */\n    this.getProxy = () => {\n      return proxy\n    }\n\n    /**\n     * Get time data.\n     * @returns {Proxy} Time data.\n     */\n    this.getTime = () => {\n      return time\n    }\n\n    /**\n     * Enable updater.\n     */\n    this.enable = () => {\n      if (isEnabled) {\n        return\n      }\n      isEnabled = true\n\n      // Start update loop.\n      request = window.requestAnimationFrame(update)\n    }\n\n    /**\n     * Disable updater.\n     */\n    this.disable = () => {\n      if (!isEnabled) {\n        return\n      }\n      isEnabled = false\n\n      // Stop updating.\n      if (request) {\n        cancelAnimationFrame(request)\n        request = null\n      }\n    }\n  }\n}\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport createUpdateContext from './contexts/update.js'\nimport createUpdateDirective from './directives/update.js'\nimport Updater from './Updater.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    defaultOrder: 500,\n    stepMinimum: 0,\n    updateContextName: '$update',\n    updateDirectiveName: 'update',\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  // Setup update loop.\n  const updater = new Updater(\n    options,\n    () => {\n      // Update all directives.\n      update()\n\n      // Dispatch update triggers.\n      library.update([{\n        id: updater.getId(),\n        path: 'current',\n      }, {\n        id: updater.getId(),\n        path: 'delta',\n      }, {\n        id: updater.getId(),\n        path: 'last',\n      }, {\n        id: updater.getId(),\n        path: 'passed',\n      }])\n    },\n  )\n  const contextUpdate = createUpdateContext(options, updater)\n  const [directiveUpdate, update] = createUpdateDirective(options)\n\n  const onEnable = (\n  ) => {\n    // Add contexts and directives.\n    library.addContexts(0, contextUpdate)\n    library.addDirectives(-1, directiveUpdate)\n    // Enable updater.\n    updater.enable()\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(contextUpdate)\n    library.removeDirectives(directiveUpdate)\n    // Disable updater.\n    updater.disable()\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n",
    "import DoarsUpdate from './DoarsUpdate.js'\n\nwindow.DoarsUpdate = DoarsUpdate\n"
  ],
  "mappings": "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",
  "debugId": "0C6527811A41EAD564756E2164756E21",
  "names": []
}