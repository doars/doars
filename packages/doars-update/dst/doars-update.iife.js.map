{
  "version": 3,
  "sources": ["../src/factories/contexts/createUpdate.js", "../src/factories/directives/createUpdate.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../src/Updater.js", "../src/DoarsUpdate.js", "../src/DoarsUpdate.iife.js"],
  "sourcesContent": ["export default (updater => {\n  // Deconstruct updater.\n  const id = updater.getId();\n  const proxy = updater.getProxy();\n  const time = updater.getTime();\n  return {\n    name: '$update',\n    create: (component, attribute) => {\n      // Create event handlers.\n      const onGet = (target, path) => attribute.accessed(id, path.join('.')); // Add event listeners.\n\n\n      proxy.addEventListener('get', onGet);\n      return {\n        value: time,\n        // Remove event listeners.\n        destroy: () => {\n          proxy.removeEventListener('get', onGet);\n        }\n      };\n    }\n  };\n});", "export default (options => {\n  // Overwrite default options.\n  options = Object.assign({\n    defaultOrder: 500\n  }, options); // Create list of update directives.\n\n  const itemIds = [];\n  const items = [];\n  const directive = {\n    name: 'update',\n    update: function (component, attribute, {\n      processExpression\n    }) {\n      // Store execute expression locally.\n      if (!this._execute) {\n        this._execute = processExpression;\n      } // Deconstruct attribute.\n\n\n      const id = attribute.getId(); // Exit early if already in list.\n\n      if (itemIds.indexOf(id) >= 0) {\n        return;\n      } // Deconstruct attribute.\n\n\n      let {\n        order\n      } = attribute.getModifiers();\n\n      if (!order) {\n        order = options.defaultOrder;\n      } // Get index to place item at based on order.\n\n\n      let index = 0;\n\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].order >= order) {\n          index = i;\n          break;\n        }\n      } // Add item at index in list.\n\n\n      items.splice(index, 0, {\n        attribute,\n        component,\n        order\n      });\n    },\n    destroy: (component, attribute) => {\n      // Deconstruct attribute.\n      const id = attribute.getId(); // Exit early if already in list.\n\n      const index = itemIds.indexOf(id);\n\n      if (index >= 0) {\n        return;\n      } // Remove attribute id from item ids list.\n\n\n      itemIds.splice(index, 1); // Remove attribute from items list.\n\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].attribute === attribute) {\n          // Remove item from list.\n          items.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n  return [directive, () => {\n    // Run expression of each item in order.\n    for (const item of items) {\n      directive._execute(item.component, item.attribute.clone(), item.attribute.getValue(), {}, {\n        return: false\n      });\n    }\n  }];\n});", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = ['apply', 'construct', 'defineProperty', 'deleteProperty', 'get', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf'];\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\n\nexport default ((target, handler) => {\n  // Keep track of status.\n  let revoked = false; // Add revocable handlers for each given handlers.\n\n  const revocableHandler = {};\n\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy');\n        return;\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters);\n      }\n\n      return Reflect[key](...parameters);\n    };\n  } // Return proxy and revoke method.\n\n\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true;\n    }\n  };\n});", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {};\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = [];\n      } // Add to events.\n\n\n      events[name].push({\n        callback,\n        options\n      });\n    };\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n\n\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return;\n      }\n\n      const eventData = events[name]; // Get index of callback in events.\n\n      let index = -1;\n\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return;\n      } // Remove item from events.\n\n\n      eventData.splice(index, 1); // Remove event if list is empty.\n\n      if (Object.keys(eventData).length === 0) {\n        delete events[name];\n      }\n    };\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeEventListeners = name => {\n      if (!name) {\n        return;\n      } // Remove all handlers with the event name.\n\n\n      delete events[name];\n    };\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {};\n    };\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n\n\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return;\n      } // Get events by trigger name.\n\n\n      const eventData = events[name]; // Dispatch a call to each event.\n\n      for (let i = 0; i < eventData.length; i++) {\n        const event = options && options.reverse ? eventData[eventData.length - (i + 1)] : eventData[i]; // If once is truthy then remove the callback.\n\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1);\n        } // Execute callback.\n\n\n        event.callback(...parameters);\n      }\n    };\n  }\n\n}\n\nexport default EventDispatcher;", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'; // Import event dispatcher.\n\nimport EventDispatcher from './EventDispatcher.js';\n\nclass ProxyDispatcher extends EventDispatcher {\n  constructor(options = {}) {\n    super();\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true\n    }, options); // Setup WeakMap for keep track of created proxies.\n\n    const map = new WeakMap();\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n\n    this.add = (target, path = []) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target);\n      } // Recursively create proxies for each property.\n\n\n      for (const key in target) {\n        if (target[key] && typeof target[key] === 'object') {\n          target[key] = this.add(target[key], [...path, key]);\n        }\n      } // Create handler and add the handler for which a callback exits..\n\n\n      const handler = {};\n\n      if (options.delete) {\n        handler.deleteProperty = (target, key) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true;\n          } // Remove proxy.\n\n\n          this.remove(target, key); // Delete property.\n\n          const deleted = Reflect.deleteProperty(target, key); // Dispatch delete event.\n\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]]);\n          } // Return deleted.\n\n\n          return deleted;\n        };\n      }\n\n      if (options.get) {\n        handler.get = (target, key, receiver) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver]);\n          } // Return value from object.\n\n\n          return Reflect.get(target, key, receiver);\n        };\n      }\n\n      if (options.set) {\n        handler.set = (target, key, value, receiver) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true;\n          } // Add proxy if value is an object.\n\n\n          if (typeof value === 'object') {\n            value = this.add(value, [...path, key]);\n          } // Store value.\n\n\n          target[key] = value; // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver]); // Return success.\n\n          return true;\n        };\n      } // Create proxy.\n\n\n      const revocable = RevocableProxy(target, handler); // Store target at proxy.\n\n      map.set(revocable, target); // Return proxy.\n\n      return revocable.proxy;\n    };\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n\n\n    this.remove = target => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return;\n      }\n\n      const revocable = map.get(target);\n      map.delete(revocable); // Recursively remove properties as well.\n\n      for (const property in revocable.proxy) {\n        if (typeof revocable.proxy[property] === 'object') {\n          this.remove(revocable.proxy[property]);\n        }\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    };\n  }\n\n}\n\nexport default ProxyDispatcher;", "// Import proxy dispatcher.\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js';\nexport default class Updater {\n  constructor(options, callback) {\n    // Overwrite default options.\n    options = Object.assign({\n      stepMinimum: 0\n    }, options); // Create id.\n\n    const id = Symbol('ID_UPDATE'); // Set private variables.\n\n    let isEnabled = false,\n        request; // Setup time proxy.\n\n    const proxy = new ProxyDispatcher({\n      // We don't care when they are updated, we have a callback for that. They should never be updated by the user anyway.\n      delete: false,\n      set: false\n    });\n    const time = proxy.add({});\n\n    const update = timeAbsolute => {\n      // Exit if not enabled any more.\n      if (!isEnabled) {\n        return;\n      } // Request to be updated next frame.\n\n\n      request = window.requestAnimationFrame(update); // Set initial time values.\n\n      if (!time.startMs) {\n        time.currentMs = time.lastMs = time.startMs = timeAbsolute;\n        time.current = time.last = time.start = timeAbsolute / 1000;\n        time.delta = time.passed = time.deltaMs = time.passedMs = 0; // Exit early after initial update.\n\n        return;\n      } // Check if minimum time has been elapsed.\n\n\n      const deltaMs = timeAbsolute - time.lastMs;\n\n      if (deltaMs <= options.stepMinimum) {\n        return;\n      } // Update time values.\n\n\n      time.lastMs = time.currentMs;\n      time.last = time.current;\n      time.currentMs = timeAbsolute;\n      time.current = timeAbsolute / 1000;\n      time.deltaMs = deltaMs;\n      time.delta = deltaMs / 1000;\n      time.passedMs += deltaMs; // Adding the delta could introduce drift because we are not measuring from the start time, hover doing so would case issues if the updater is disabled and later on re-enabled. Due to the high precession the drift will only cause a noticeable effect after a long time, long enough to not cause a problem in most use cases. Long story short, good enough.\n\n      time.passed = time.passedMs / 1000; // Invoke callback.\n\n      callback();\n    };\n    /**\n     * Get whether the instance is enabled.\n     * @returns {Bool} Whether the instance is enabled.\n     */\n\n\n    this.isEnabled = () => {\n      return isEnabled;\n    };\n    /**\n     * Get updater id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get time proxy.\n     * @returns {ProxyDispatcher} Time proxy.\n     */\n\n\n    this.getProxy = () => {\n      return proxy;\n    };\n    /**\n     * Get time data.\n     * @returns {Proxy} Time data.\n     */\n\n\n    this.getTime = () => {\n      return time;\n    };\n    /**\n     * Enable updater.\n     */\n\n\n    this.enable = () => {\n      if (isEnabled) {\n        return;\n      }\n\n      isEnabled = true; // Start update loop.\n\n      request = window.requestAnimationFrame(update);\n    };\n    /**\n     * Disable updater.\n     */\n\n\n    this.disable = () => {\n      if (!isEnabled) {\n        return;\n      }\n\n      isEnabled = false; // Stop updating.\n\n      if (request) {\n        cancelAnimationFrame(request);\n        request = null;\n      }\n    };\n  }\n\n}", "// Import contexts.\nimport createContextUpdate from './factories/contexts/createUpdate.js'; // Import directives.\n\nimport createDirectiveUpdate from './factories/directives/createUpdate.js'; // Import updater.\n\nimport Updater from './Updater.js';\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\n\nexport default function (library, options = null) {\n  // Clone options.\n  options = Object.assign({}, options); // Set private variables.\n\n  let isEnabled = false;\n  let contextUpdate, directiveUpdate, updater;\n\n  const onEnable = function () {\n    // Create and add directive.\n    const [_directiveUpdate, update] = createDirectiveUpdate(options);\n    directiveUpdate = _directiveUpdate;\n    library.addDirectives(-1, directiveUpdate); // Setup update loop.\n\n    updater = new Updater(options, () => {\n      // Update all directives.\n      update(); // Dispatch update triggers.\n\n      library.update([{\n        id: updater.getId(),\n        path: 'current'\n      }, {\n        id: updater.getId(),\n        path: 'delta'\n      }, {\n        id: updater.getId(),\n        path: 'last'\n      }, {\n        id: updater.getId(),\n        path: 'passed'\n      }]);\n    }); // Create and add context.\n\n    contextUpdate = createContextUpdate(updater);\n    library.addContexts(0, contextUpdate); // Enable updater.\n\n    updater.enable();\n  };\n\n  const onDisable = function () {\n    // Remove context.\n    library.removeContexts(contextUpdate); // Remove directive.\n\n    library.removeDirectives(directiveUpdate); // Disable updater.\n\n    updater.disable(); // Reset private variables.\n\n    contextUpdate = null;\n    directiveUpdate = null;\n    updater = null;\n  };\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false; // Stop listening to enable state of the library.\n\n      library.removeEventListener('enabling', onEnable);\n      library.removeEventListener('disabling', onDisable);\n    }\n  };\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true; // Listen to enable state of the library.\n\n      library.addEventListener('enabling', onEnable);\n      library.addEventListener('disabling', onDisable);\n    }\n  }; // Automatically enable plugin.\n\n\n  this.enable();\n}", "import DoarsUpdate from './DoarsUpdate.js';\nwindow.DoarsUpdate = DoarsUpdate;"],
  "mappings": "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",
  "names": ["createUpdate_default", "target", "createUpdate_default"]
}
