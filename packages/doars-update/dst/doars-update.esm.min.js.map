{
  "version": 3,
  "sources": ["../src/factories/contexts/createUpdate.js", "../src/factories/directives/createUpdate.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../src/Updater.js", "../src/DoarsUpdate.js"],
  "sourcesContent": ["export default (updater => {\n  // Deconstruct updater.\n  const id = updater.getId();\n  const proxy = updater.getProxy();\n  const time = updater.getTime();\n  return {\n    name: '$update',\n    create: (component, attribute) => {\n      // Create event handlers.\n      const onGet = (target, path) => attribute.accessed(id, path.join('.')); // Add event listeners.\n\n\n      proxy.addEventListener('get', onGet);\n      return {\n        value: time,\n        // Remove event listeners.\n        destroy: () => {\n          proxy.removeEventListener('get', onGet);\n        }\n      };\n    }\n  };\n});", "export default (options => {\n  // Overwrite default options.\n  options = Object.assign({\n    defaultOrder: 500\n  }, options); // Create list of update directives.\n\n  const itemIds = [];\n  const items = [];\n  const directive = {\n    name: 'update',\n    update: function (component, attribute, {\n      processExpression\n    }) {\n      // Store execute expression locally.\n      if (!this._execute) {\n        this._execute = processExpression;\n      } // Deconstruct attribute.\n\n\n      const id = attribute.getId(); // Exit early if already in list.\n\n      if (itemIds.indexOf(id) >= 0) {\n        return;\n      } // Deconstruct attribute.\n\n\n      let {\n        order\n      } = attribute.getModifiers();\n\n      if (!order) {\n        order = options.defaultOrder;\n      } // Get index to place item at based on order.\n\n\n      let index = 0;\n\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].order >= order) {\n          index = i;\n          break;\n        }\n      } // Add item at index in list.\n\n\n      items.splice(index, 0, {\n        attribute: attribute,\n        component: component,\n        order: order\n      });\n    },\n    destroy: (component, attribute) => {\n      // Deconstruct attribute.\n      const id = attribute.getId(); // Exit early if already in list.\n\n      const index = itemIds.indexOf(id);\n\n      if (index >= 0) {\n        return;\n      } // Remove attribute id from item ids list.\n\n\n      itemIds.splice(index, 1); // Remove attribute from items list.\n\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].attribute === attribute) {\n          // Remove item from list.\n          items.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n  return [directive, () => {\n    // Run expression of each item in order.\n    for (const item of items) {\n      directive._execute(item.component, item.attribute.clone(), item.attribute.getValue(), {}, {\n        return: false\n      });\n    }\n  }];\n});", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = ['apply', 'construct', 'defineProperty', 'deleteProperty', 'get', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf'];\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\n\nexport default ((target, handler) => {\n  // Keep track of status.\n  let revoked = false; // Add revocable handlers for each given handlers.\n\n  const revocableHandler = {};\n\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy');\n        return;\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters);\n      }\n\n      return Reflect[key](...parameters);\n    };\n  } // Return proxy and revoke method.\n\n\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true;\n    }\n  };\n});", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {};\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = [];\n      } // Add to events.\n\n\n      events[name].push({\n        callback: callback,\n        options: options\n      });\n    };\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n\n\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return;\n      }\n\n      const eventData = events[name]; // Get index of callback in events.\n\n      let index = -1;\n\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return;\n      } // Remove item from events.\n\n\n      eventData.splice(index, 1); // Remove event if list is empty.\n\n      if (Object.keys(eventData).length === 0) {\n        delete events[name];\n      }\n    };\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeEventListeners = name => {\n      if (!name) {\n        return;\n      } // Remove all handlers with the event name.\n\n\n      delete events[name];\n    };\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {};\n    };\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n\n\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return;\n      } // Get events by trigger name.\n\n\n      const eventData = events[name]; // Dispatch a call to each event.\n\n      for (let i = 0; i < eventData.length; i++) {\n        const event = options && options.reverse ? eventData[eventData.length - (i + 1)] : eventData[i]; // If once is truthy then remove the callback.\n\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1);\n        } // Execute callback.\n\n\n        event.callback(...parameters);\n      }\n    };\n  }\n\n}\n\nexport default EventDispatcher;", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'; // Import event dispatcher.\n\nimport EventDispatcher from './EventDispatcher.js';\n\nclass ProxyDispatcher extends EventDispatcher {\n  constructor(options = {}) {\n    super();\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true\n    }, options); // Setup WeakMap for keep track of created proxies.\n\n    const map = new WeakMap();\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n\n    this.add = (target, path = []) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target);\n      } // Recursively create proxies for each property.\n\n\n      for (const key in target) {\n        if (target[key] && typeof target[key] === 'object') {\n          target[key] = this.add(target[key], [...path, key]);\n        }\n      } // Create handler and add the handler for which a callback exits..\n\n\n      const handler = {};\n\n      if (options.delete) {\n        handler.deleteProperty = (target, key) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true;\n          } // Remove proxy.\n\n\n          this.remove(target, key); // Delete property.\n\n          const deleted = Reflect.deleteProperty(target, key); // Dispatch delete event.\n\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]]);\n          } // Return deleted.\n\n\n          return deleted;\n        };\n      }\n\n      if (options.get) {\n        handler.get = (target, key, receiver) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver]);\n          } // Return value from object.\n\n\n          return Reflect.get(target, key, receiver);\n        };\n      }\n\n      if (options.set) {\n        handler.set = (target, key, value, receiver) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true;\n          } // Add proxy if value is an object.\n\n\n          if (typeof value === 'object') {\n            value = this.add(value, [...path, key]);\n          } // Store value.\n\n\n          target[key] = value; // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver]); // Return success.\n\n          return true;\n        };\n      } // Create proxy.\n\n\n      const revocable = RevocableProxy(target, handler); // Store target at proxy.\n\n      map.set(revocable, target); // Return proxy.\n\n      return revocable.proxy;\n    };\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n\n\n    this.remove = target => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return;\n      }\n\n      const revocable = map.get(target);\n      map.delete(revocable); // Recursively remove properties as well.\n\n      for (const property in revocable.proxy) {\n        if (typeof revocable.proxy[property] === 'object') {\n          this.remove(revocable.proxy[property]);\n        }\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    };\n  }\n\n}\n\nexport default ProxyDispatcher;", "// Import proxy dispatcher.\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js';\nexport default class Updater {\n  constructor(options, callback) {\n    // Overwrite default options.\n    options = Object.assign({\n      stepMinimum: 0\n    }, options); // Create id.\n\n    const id = Symbol('ID_UPDATE'); // Set private variables.\n\n    let isEnabled = false,\n        request; // Setup time proxy.\n\n    const proxy = new ProxyDispatcher({\n      // We don't care when they are updated, we have a callback for that. They should never be updated by the user anyway.\n      delete: false,\n      set: false\n    });\n    const time = proxy.add({});\n\n    const update = timeAbsolute => {\n      // Exit if not enabled any more.\n      if (!isEnabled) {\n        return;\n      } // Request to be updated next frame.\n\n\n      request = window.requestAnimationFrame(update); // Set initial time values.\n\n      if (!time.startMs) {\n        time.currentMs = time.lastMs = time.startMs = timeAbsolute;\n        time.current = time.last = time.start = timeAbsolute / 1000;\n        time.delta = time.passed = time.deltaMs = time.passedMs = 0; // Exit early after initial update.\n\n        return;\n      } // Check if minimum time has been elapsed.\n\n\n      const deltaMs = timeAbsolute - time.lastMs;\n\n      if (deltaMs <= options.stepMinimum) {\n        return;\n      } // Update time values.\n\n\n      time.lastMs = time.currentMs;\n      time.last = time.current;\n      time.currentMs = timeAbsolute;\n      time.current = timeAbsolute / 1000;\n      time.deltaMs = deltaMs;\n      time.delta = deltaMs / 1000;\n      time.passedMs += deltaMs; // Adding the delta could introduce drift because we are not measuring from the start time, hover doing so would case issues if the updater is disabled and later on re-enabled. Due to the high precession the drift will only cause a noticeable effect after a long time, long enough to not cause a problem in most use cases. Long story short, good enough.\n\n      time.passed = time.passedMs / 1000; // Invoke callback.\n\n      callback();\n    };\n    /**\n     * Get whether the instance is enabled.\n     * @returns {Bool} Whether the instance is enabled.\n     */\n\n\n    this.isEnabled = () => {\n      return isEnabled;\n    };\n    /**\n     * Get updater id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get time proxy.\n     * @returns {ProxyDispatcher} Time proxy.\n     */\n\n\n    this.getProxy = () => {\n      return proxy;\n    };\n    /**\n     * Get time data.\n     * @returns {Proxy} Time data.\n     */\n\n\n    this.getTime = () => {\n      return time;\n    };\n    /**\n     * Enable updater.\n     */\n\n\n    this.enable = () => {\n      if (isEnabled) {\n        return;\n      }\n\n      isEnabled = true; // Start update loop.\n\n      request = window.requestAnimationFrame(update);\n    };\n    /**\n     * Disable updater.\n     */\n\n\n    this.disable = () => {\n      if (!isEnabled) {\n        return;\n      }\n\n      isEnabled = false; // Stop updating.\n\n      if (request) {\n        cancelAnimationFrame(request);\n        request = null;\n      }\n    };\n  }\n\n}", "// Import contexts.\nimport createContextUpdate from './factories/contexts/createUpdate.js'; // Import directives.\n\nimport createDirectiveUpdate from './factories/directives/createUpdate.js'; // Import updater.\n\nimport Updater from './Updater.js';\nexport default class DoarsUpdate {\n  /**\n   * Create plugin instance.\n   * @param {Doars} library Doars instance to add onto.\n   * @param {Object} options The plugin options.\n   */\n  constructor(library, options = null) {\n    options = Object.assign({}, options); // Set private variables.\n\n    let contextUpdate, directiveUpdate, updater; // Enable plugin when library is enabling.\n\n    library.addEventListener('enabling', () => {\n      // Create and add directive.\n      const [_directiveUpdate, update] = createDirectiveUpdate(options);\n      directiveUpdate = _directiveUpdate;\n      library.addDirectives(-1, directiveUpdate); // Setup update loop.\n\n      updater = new Updater(options, () => {\n        // Update all directives.\n        update(); // Dispatch update triggers.\n\n        library.update([{\n          id: updater.getId(),\n          path: 'current'\n        }, {\n          id: updater.getId(),\n          path: 'delta'\n        }, {\n          id: updater.getId(),\n          path: 'last'\n        }, {\n          id: updater.getId(),\n          path: 'passed'\n        }]);\n      }); // Create and add context.\n\n      contextUpdate = createContextUpdate(updater);\n      library.addContexts(0, contextUpdate); // Enable updater.\n\n      updater.enable();\n    }); // Disable plugin when library is disabling.\n\n    library.addEventListener('disabling', () => {\n      // Remove context.\n      library.removeContexts(contextUpdate); // Remove directive.\n\n      library.removeDirectives(directiveUpdate); // Disable updater.\n\n      updater.disable(); // Reset private variables.\n\n      contextUpdate = null;\n      directiveUpdate = null;\n      updater = null;\n    });\n  }\n\n}"],
  "mappings": "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",
  "names": ["createUpdate_default", "updater", "id", "proxy", "time", "component", "attribute", "onGet", "target", "path", "createUpdate_default", "options", "itemIds", "items", "directive", "component", "attribute", "processExpression", "id", "order", "index", "i", "item", "REFLECTION_METHODS", "RevocableProxy_default", "target", "handler", "revoked", "revocableHandler", "key", "parameters", "EventDispatcher", "events", "name", "callback", "options", "eventData", "index", "i", "parameters", "event", "EventDispatcher_default", "ProxyDispatcher", "EventDispatcher_default", "options", "map", "target", "path", "key", "handler", "deleted", "receiver", "value", "revocable", "RevocableProxy_default", "property", "ProxyDispatcher_default", "Updater", "options", "callback", "id", "isEnabled", "request", "proxy", "ProxyDispatcher_default", "time", "update", "timeAbsolute", "deltaMs", "DoarsUpdate", "library", "options", "contextUpdate", "directiveUpdate", "updater", "_directiveUpdate", "update", "createUpdate_default", "Updater"]
}
