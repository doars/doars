{
  "version": 3,
  "sources": ["../src/symbols.js", "../node_modules/@doars/common/src/events/EventDispatcher.js", "../node_modules/@doars/common/src/utilities/String.js", "../src/Attribute.js", "../node_modules/@doars/common/src/polyfills/RevocableProxy.js", "../node_modules/@doars/common/src/events/ProxyDispatcher.js", "../src/utilities/Component.js", "../node_modules/@doars/common/src/utilities/Element.js", "../src/Component.js", "../src/utilities/Context.js", "../src/contexts/children.js", "../src/contexts/component.js", "../src/contexts/element.js", "../src/contexts/dispatch.js", "../src/contexts/for.js", "../src/contexts/inContext.js", "../src/contexts/nextSibling.js", "../src/contexts/nextTick.js", "../src/contexts/parent.js", "../src/contexts/previousSibling.js", "../src/contexts/references.js", "../src/contexts/siblings.js", "../node_modules/@doars/common/src/factories/createState.js", "../src/contexts/state.js", "../node_modules/@doars/common/src/utilities/Object.js", "../node_modules/@doars/common/src/factories/createStateContext.js", "../src/contexts/store.js", "../src/contexts/watch.js", "../node_modules/@doars/common/src/utilities/Attribute.js", "../node_modules/@doars/common/src/utilities/Promise.js", "../src/directives/attribute.js", "../node_modules/@doars/common/src/utilities/Transition.js", "../src/directives/cloak.js", "../node_modules/@doars/common/src/utilities/Script.js", "../src/directives/for.js", "../node_modules/@doars/common/src/utilities/Html.js", "../node_modules/@doars/common/src/utilities/Morph.js", "../src/directives/html.js", "../src/directives/if.js", "../src/directives/initialized.js", "../src/directives/on.js", "../src/directives/reference.js", "../src/directives/select.js", "../src/directives/show.js", "../src/directives/sync.js", "../src/directives/text.js", "../src/directives/watch.js", "../src/Doars.js", "../src/utilities/Execute.js", "../src/DoarsExecute.js"],
  "sourcesContent": ["export const ATTRIBUTES = Symbol('ATTRIBUTES')\n\nexport const COMPONENT = Symbol('COMPONENT')\n\nexport const FOR = Symbol('FOR')\n\nexport const REFERENCES = Symbol('REFERENCES')\nexport const REFERENCES_CACHE = Symbol('REFERENCES_CACHE')\n", "/**\n * @typedef EventListenerOptions\n * @type {object}\n * @property {?boolean} once Whether to call the listener only once.\n */\n\n/**\n * @typedef DispatchEventOptions\n * @type {object}\n * @property {?boolean} reverse Whether to call the listeners in reverse order.\n */\n\nexport default class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor(\n  ) {\n    /**\n     * Object to store event listeners for the EventDispatcher class.\n     * @type {Record<string, Array<{callback: Function, options: EventListenerOptions }>>}\n     */\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {EventListenerOptions} options Callback options.\n     */\n    this.addEventListener = (\n      name,\n      callback,\n      options = null,\n    ) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (\n      name,\n      callback,\n    ) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {string} name Event name.\n     */\n    this.removeEventListeners = (\n      name,\n    ) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     */\n    this.removeAllEventListeners = (\n    ) => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {string} name Event name.\n     * @param {Array<any>} parameters Event parameters to pass through.\n     * @param {DispatchEventOptions} options Dispatch options.\n     */\n    this.dispatchEvent = (\n      name,\n      parameters,\n      options = null,\n    ) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n", "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {string} text String to escape.\n * @returns {string} Escaped string.\n */\nexport const escapeHtml = (\n  text,\n) => {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\\\'/g, '\\\\\\'')\n    .replace(/\\\\\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n}\n\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {string} text String to modify.\n * @returns {string} Converted string.\n */\nexport const kebabToCamel = (\n  text,\n) => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase())\n}\n\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<string>} modifiers List of modifiers to parse.\n * @returns {object} Parsed modifiers.\n */\nexport const parseAttributeModifiers = (\n  modifiers,\n) => {\n  const result = {}\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-')\n\n    // If no hyphen then set the modifiers to true.\n    if (hyphenIndex < 0) {\n      result[modifier] = true\n      continue\n    }\n\n    // If it starts with hyphen then set the modifier to false.\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false\n      continue\n    }\n\n    // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n    const key = modifier.substring(0, hyphenIndex)\n    let value = modifier.substring(hyphenIndex + 1)\n\n    let tmpValue = value\n\n    // Try to remove time suffixes.\n    let type\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2)\n    } else if (value.endsWith('s')) {\n      type = 's'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('m')) {\n      type = 'm'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('h')) {\n      type = 'h'\n      tmpValue = value.substring(-1)\n    }\n\n    // Try to parse the value as a number.\n    tmpValue = Number.parseInt(tmpValue)\n    if (!isNaN(tmpValue)) {\n      value = tmpValue\n\n      // Convert to milliseconds if given in a different format.\n      switch (type) {\n        case 'h':\n          value *= 60\n        case 'm':\n          value *= 60\n        case 's':\n          value *= 1000\n          break\n      }\n    }\n\n    // Store modifier data.\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {string} prefix Directive prefix.\n * @param {string} name Name to parse.\n * @returns {Array<string> | undefined} list of segments.\n */\nexport const parseAttributeName = (\n  prefix,\n  name,\n) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'))\n  if (!name) {\n    return\n  }\n  // Deconstruct match.\n  let [full, directive, keyRaw, modifiers] = name // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n  keyRaw = keyRaw !== '' ? keyRaw : null\n  const key = keyRaw ? kebabToCamel(keyRaw) : null\n  // Ensure modifiers is and array.\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []\n  // Return result a single array.\n  return [directive, keyRaw, key, modifiers]\n}\n\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n * @param {string} expression For expression to parse.\n * @returns {object | undefined} Iterable type and variables.\n */\nexport const parseForExpression = (\n  expression,\n) => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i)\n  if (!match) {\n    return\n  }\n\n  // Remove parenthesis.\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, '')\n  // Parse for variables.\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i)\n  if (!variables) {\n    return\n  }\n  variables.shift()\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables], // Convert it to an array instead of a regular expression match.\n  }\n}\n\n/**\n * Parse selector to an attributes object.\n * @param {string} selector Selector to parse.\n * @returns {object | undefined} Attributes. Do note the class property is a list of strings not a single string.\n */\nexport const parseSelector = (\n  selector,\n) => {\n  // Convert to array.\n  if (typeof (selector) === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/)\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.')\n    return\n  }\n\n  const attributes = {}\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim()\n\n    // Base what to do of the leading character.\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1)\n        break\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1)\n        // Add to classlist.\n        if (!attributes.class) {\n          attributes.class = []\n        }\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment)\n        }\n        break\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i) // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n        attributes[key] = value\n        break\n    }\n  }\n  return attributes\n}\n\nexport default {\n  escapeHtml,\n  kebabToCamel,\n  parseAttributeModifiers,\n  parseAttributeName,\n  parseForExpression,\n  parseSelector,\n}\n", "// Import event dispatcher.\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'\n\n// Import symbols.\nimport { ATTRIBUTES } from './symbols.js'\n\n// Import types.\nimport Component from './Component.js'\n\n// Import utilities.\nimport {\n  parseAttributeName,\n  parseAttributeModifiers,\n} from '@doars/common/src/utilities/String.js'\n\n/**\n * @typedef {import('./Doars.js').default} Doars\n */\n\nexport default class Attribute extends EventDispatcher {\n  /**\n   * Create instance.\n   * @param {Component} component Component instance.\n   * @param {HTMLElement} element Element.\n   * @param {string} name Attribute name (with library prefix removed).\n   * @param {string} value Attribute value.\n   * @param {boolean} isClone Whether this will be a clone of an existing attribute.\n   */\n  constructor(\n    component,\n    element,\n    name,\n    value,\n    isClone = false,\n  ) {\n    super()\n\n    // Create unique ID.\n    const id = Symbol('ID_ATTRIBUTE')\n\n    if (!isClone) {\n      // Add attribute reference to the element.\n      if (!element[ATTRIBUTES]) {\n        element[ATTRIBUTES] = []\n      }\n      element[ATTRIBUTES].push(this)\n    }\n\n    // Create private variables.\n    let accessedItems = {},\n      data = null,\n      directive,\n      key,\n      keyRaw,\n      modifiersRaw,\n      modifiers\n\n    // Parse and store name.\n    if (name) {\n      // Parse and store attribute name.\n      const [_directive, _keyRaw, _key, _modifiers] = parseAttributeName(\n        component.getLibrary().getOptions().prefix,\n        name,\n      )\n      directive = _directive\n      key = _key\n      keyRaw = _keyRaw\n      modifiersRaw = _modifiers\n\n      // Parse and store modifiers.\n      if (_modifiers) {\n        modifiers = parseAttributeModifiers(_modifiers)\n      }\n    }\n\n    /**\n     * Get the component this attribute is a part of.\n     * @returns {Component} Attribute's component.\n     */\n    this.getComponent = (\n    ) => {\n      return component\n    }\n\n    /**\n     * Get the element this attribute belongs to.\n     * @returns {HTMLElement} Element.\n     */\n    this.getElement = (\n    ) => {\n      return element\n    }\n\n    /**\n     * Get attribute id.\n     * @returns {symbol} Unique identifier.\n     */\n    this.getId = (\n    ) => {\n      return id\n    }\n\n    /**\n     * Get the directive this attribute matches.\n     * @returns {string} Directive name.\n     */\n    this.getDirective = (\n    ) => {\n      return directive\n    }\n\n    /**\n     * Get the optional key of the attribute.\n     * @returns {string} Key.\n     */\n    this.getKey = (\n    ) => {\n      return key\n    }\n\n    /**\n     * Get the optional key of the attribute before being processed.\n     * @returns {string} Raw key.\n     */\n    this.getKeyRaw = (\n    ) => {\n      return keyRaw\n    }\n\n    /**\n     * Get the optional modifiers of the attribute.\n     * @returns {object} Modifiers object.\n     */\n    this.getModifiers = (\n    ) => {\n      return Object.assign({}, modifiers)\n    }\n\n    /**\n     * Get the optional modifiers of the attribute before being processed.\n     * @returns {Array<string>} List of raw modifiers.\n     */\n    this.getModifiersRaw = (\n    ) => {\n      return modifiersRaw\n    }\n\n    /**\n     * Get attribute's name.\n     * @returns {string} Attribute name.\n     */\n    this.getName = (\n    ) => {\n      return name\n    }\n\n    /**\n     * Get the attribute's value.\n     * @returns {string} Value.\n     */\n    this.getValue = (\n    ) => {\n      return value\n    }\n\n    /**\n     * Set the attribute's value.\n     * @param {string} _value New value.\n     */\n    this.setValue = (\n      _value,\n    ) => {\n      value = _value\n\n      // Dispatch changed event.\n      this.dispatchEvent('changed', [this])\n    }\n\n    /**\n     * Clear custom data set.\n     */\n    this.clearData = (\n    ) => {\n      data = null\n    }\n\n    /**\n     * Whether there is data set.\n     * @returns {boolean} Whether data is set.\n     */\n    this.hasData = (\n    ) => {\n      return data !== null\n    }\n\n    /**\n     * Get custom data set previously.\n     * @returns {any} the data.\n     */\n    this.getData = (\n    ) => {\n      return data\n    }\n\n    /**\n     * Set custom attribute data.\n     * @param {any} _data Some data.\n     */\n    this.setData = (\n      _data,\n    ) => {\n      data = _data\n    }\n\n    /**\n     * Destroy the attribute.\n     */\n    this.destroy = (\n    ) => {\n      // Clear data.\n      this.setData(null)\n\n      // Clear accessed.\n      this.clearAccessed()\n\n      // Remove attribute from element's attributes.\n      const indexInElement = element[ATTRIBUTES].indexOf(this)\n      if (indexInElement >= 0) {\n        element[ATTRIBUTES].splice(indexInElement, 1)\n      }\n\n      // Dispatch destroy event.\n      this.dispatchEvent('destroyed', [this])\n\n      // Remove all listeners.\n      this.removeAllEventListeners()\n    }\n\n    /**\n     * Mark an item as accessed.\n     * @param {symbol} id Unique identifier.\n     * @param {string} path Context path.\n     */\n    this.accessed = (\n      id,\n      path,\n    ) => {\n      if (!accessedItems[id]) {\n        accessedItems[id] = []\n      } else if (accessedItems[id].includes(path)) {\n        return\n      }\n\n      accessedItems[id].push(path)\n\n      // Dispatch accessed event.\n      this.dispatchEvent('accessed', [this, id, path])\n    }\n\n    /**\n     * Clear list of accessed items.\n     */\n    this.clearAccessed = (\n    ) => {\n      accessedItems = {}\n    }\n\n    /**\n     * Check if attribute accessed any of the item's paths.\n     * @param {symbol} id Unique identifier.\n     * @param {Array<string>} paths Contexts path.\n     * @returns {boolean} Whether any item's path was accessed.\n     */\n    this.hasAccessed = (\n      id,\n      paths,\n    ) => {\n      if (!(id in accessedItems)) {\n        return false\n      }\n      const accessedAtId = accessedItems[id]\n\n      for (const path of paths) {\n        if (accessedAtId.includes(path)) {\n          return true\n        }\n      }\n      return false\n    }\n\n    /**\n     * Creates a clone of the attribute without copying over the id and accessed values.\n     * @returns {Attribute} Cloned attribute.\n     */\n    this.clone = (\n    ) => {\n      // Create new attribute as clone.\n      return new Attribute(\n        component,\n        element,\n        name,\n        value,\n        true,\n      )\n    }\n  }\n}\n", "/**\n * Function to call to revoke the proxy.\n * @callback RevocableProxyCallback\n */\n\n/**\n * @typedef RevocableProxy\n * @type {object}\n * @property {Proxy} proxy Proxy that will be revocable.\n * @property {RevocableProxyCallback} revoke Function to call to revoke the proxy.\n */\n\n/**\n * Function called when a proxy has been handled.\n * @callback ProxyHandlerCallback\n */\n\n/**\n * @typedef ProxyHandler\n * @type {object}\n * @property {?ProxyHandlerCallback} apply A trap method for a function call.\n * @property {?ProxyHandlerCallback} construct A trap for the `new` operator.\n * @property {?ProxyHandlerCallback} defineProperty A trap for `Object.defineProperty()`.\n * @property {?ProxyHandlerCallback} deleteProperty A trap for the `delete` operator.\n * @property {?ProxyHandlerCallback} get A trap for getting a property value.\n * @property {?ProxyHandlerCallback} getOwnPropertyDescriptor A trap for `Object.getOwnPropertyDescriptor()`.\n * @property {?ProxyHandlerCallback} getPrototypeOf A trap for the `[[GetPrototypeOf]]` internal method.\n * @property {?ProxyHandlerCallback} has A trap for the `in` operator.\n * @property {?ProxyHandlerCallback} isExtensible A trap for `Object.isExtensible()`.\n * @property {?ProxyHandlerCallback} ownKeys A trap for `Reflect.ownKeys()`.\n * @property {?ProxyHandlerCallback} preventExtensions A trap for `Object.preventExtensions()`.\n * @property {?ProxyHandlerCallback} set A trap for setting a property value.\n * @property {?ProxyHandlerCallback} setPrototypeOf A trap for `Object.setPrototypeOf()`.\n */\n\n// List of methods to revoke access to.\nconst PROXY_TRAPS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'has',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n * @param {object} target Object to proxy.\n * @param {ProxyHandler} handler Object of handler methods.\n * @returns {?RevocableProxy} Proxy object and revoke method.\n */\nexport default (\n  target,\n  handler,\n) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  /**\n   * Copy of allowed handlers with a revocable layer in between.\n   * @type {ProxyHandler}\n   */\n  const revocableHandler = {}\n  for (const key of PROXY_TRAPS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n// Import event dispatcher.\nimport EventDispatcher from './EventDispatcher.js'\n\n/**\n * @typedef ProxyOptions\n * @type {object}\n * @property {?boolean} delete Whether to dispatch an event on delete.\n * @property {?boolean} get Whether to dispatch an event on get.\n * @property {?boolean} set Whether to dispatch an event on set.\n */\n\nexport default class ProxyDispatcher extends EventDispatcher {\n  /**\n   * Creates a proxy dispatcher instance.\n   * @param {ProxyOptions} options Options for proxy dispatcher.\n   */\n  constructor(\n    options = {},\n  ) {\n    super()\n\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true,\n    }, options)\n\n    // Setup WeakMap for keep track of created proxies.\n    const map = new WeakMap()\n\n    /**\n     * Add object to start keeping track of it.\n     * @param {object} target Object that is being kept track of.\n     * @param {Array<string>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n    this.add = (\n      target,\n      path = [],\n    ) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target)\n      }\n\n      // Recursively create proxies for each property.\n      for (const key in target) {\n        if (target[key] && typeof (target[key]) === 'object') {\n          target[key] = this.add(target[key], [...path, key])\n        }\n      }\n\n      // Create handler and add the handler for which a callback exits..\n      const handler = {}\n\n      if (options.delete) {\n        handler.deleteProperty = (\n          target,\n          key,\n        ) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true\n          }\n\n          // Remove proxy.\n          this.remove(target, key)\n\n          // Delete property.\n          const deleted = Reflect.deleteProperty(target, key)\n\n          // Dispatch delete event.\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]])\n          }\n\n          // Return deleted.\n          return deleted\n        }\n      }\n\n      if (options.get) {\n        handler.get = (\n          target,\n          key,\n          receiver,\n        ) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver])\n          }\n\n          // Return value from object.\n          return Reflect.get(target, key, receiver)\n        }\n      }\n\n      if (options.set) {\n        handler.set = (\n          target,\n          key,\n          value,\n          receiver,\n        ) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true\n          }\n\n          // Add proxy if value is an object.\n          if (value && typeof value === 'object') {\n            value = this.add(value, [...path, key])\n          }\n          // Store value.\n          target[key] = value\n\n          // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver])\n\n          // Return success.\n          return true\n        }\n      }\n\n      // Create proxy.\n      const revocable = RevocableProxy(target, handler)\n\n      // Store target at proxy.\n      map.set(revocable, target)\n\n      // Return proxy.\n      return revocable.proxy\n    }\n\n    /**\n     * Remove object from being kept track of.\n     * @param {object} target Object that is being kept track of.\n     */\n    this.remove = (\n      target,\n    ) => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return\n      }\n\n      const revocable = map.get(target)\n      map.delete(revocable)\n\n      // Recursively remove properties as well.\n      for (const property in revocable.proxy) {\n        if (typeof (revocable.proxy[property]) === 'object') {\n          this.remove(revocable.proxy[property])\n        }\n      }\n\n      // Revoke proxy.\n      revocable.revoke()\n    }\n  }\n}\n", "// Import symbols.\nimport { COMPONENT } from '../symbols.js'\n\n/**\n * @typedef {import('../Component.js').default} Component\n */\n\n/**\n * Get closest component in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Component|undefined} Closest component.\n */\nexport const closestComponent = (\n  element,\n) => {\n  if (element.parentElement) {\n    element = element.parentElement\n\n    if (element[COMPONENT]) {\n      /** @type {Component} */\n      return element[COMPONENT]\n    }\n\n    return closestComponent(element)\n  }\n}\n\nexport default {\n  closestComponent,\n}\n", "/**\n * Convert string to HTML element.\n * @param {string} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const stringStart = string.substring(0, 15).toLowerCase()\n  const isDocument = (\n    stringStart.startsWith('<!doctype html>') ||\n    stringStart.startsWith('<html>')\n  )\n  if (isDocument) {\n    const html = document.createElement('html')\n    html.innerHTML = string\n    return html\n  }\n\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after().\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (\n  reference,\n  node,\n) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Inserts an element before the reference element,\n * @param {HTMLElement} reference Node to insert before.\n * @param {Node} node Node to insert.\n */\nexport const insertBefore = (\n  reference,\n  node,\n) => {\n  reference.parentNode.insertBefore(reference, node)\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMLElement} a A node.\n * @param {HTMLElement} b Another node.\n * @returns {boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (a.isSameNode && a.isSameNode(b)) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * @callback WalkIterate Returns a new child element or null when all items have been iterated on.\n * @returns {HTMLElement|null}\n */\n\n/**\n * @callback WalkFilter Filter function that takes in an element and return true if the element needs to be walked and false when it needs to be skipped.\n * @param {HTMLElement} element Element to decide on.\n * @returns {boolean}\n */\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {WalkFilter} filter Filter function, return false to skip element.\n * @returns {WalkIterate} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  element,\n  filter,\n) => {\n  let index = -1\n  /** @type {null|WalkIterate} */\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "// Import symbols.\nimport { COMPONENT } from './symbols.js'\n\n// Import classes.\nimport Attribute from './Attribute.js'\n\n// Import proxy dispatcher.\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\n\n// Import types.\nimport Doars from './Doars.js'\n\n// Import utilities.\nimport { closestComponent } from './utilities/Component.js'\nimport { walk } from '@doars/common/src/utilities/Element.js'\n\n/**\n * @typedef {import('./Doars.js').default} Doars\n */\n\nexport default class Component {\n  /**\n   * Create instance.\n   * @param {Doars} library Library instance.\n   * @param {HTMLElement} element Element.\n   */\n  constructor(\n    library,\n    element,\n  ) {\n    // Create unique ID.\n    const id = Symbol('ID_COMPONENT')\n\n    // Deconstruct library options.\n    const {\n      prefix,\n      stateDirectiveName,\n    } = library.getOptions()\n\n    // Get the expression processor.\n    const processExpression = library.getProcessor()\n\n    // create private variables.\n    let attributes = [],\n      hasUpdated = false,\n      isInitialized = false,\n      data,\n      proxy,\n      state\n\n    // Check if element has a state attribute.\n    if (!element.attributes[prefix + '-' + stateDirectiveName]) {\n      console.error('Doars: element given to component does not contain a state attribute!')\n      return\n    }\n\n    // Add reference to element.\n    element[COMPONENT] = this\n\n    // Update position in hierarchy.\n    const children = []\n    // Get current parent component.\n    let parent = closestComponent(element)\n    if (parent) {\n      // Add to list of children in parent.\n      if (!parent.getChildren().includes(this)) {\n        parent.getChildren().push(this)\n\n        // Trigger children update.\n        library.update([{\n          id: parent.getId(),\n          path: 'children',\n        }])\n      }\n    }\n\n    /**\n     * Dispatch an event from this component.\n     * @param {string} name Name of the event.\n     * @param {any} detail Event details.\n     */\n    const dispatchEvent = (\n      name,\n      detail,\n    ) => {\n      element.dispatchEvent(\n        new CustomEvent(prefix + '-' + name, {\n          detail,\n          bubbles: true,\n        }),\n      )\n    }\n\n    /**\n     * Get the attributes in this component.\n     * @returns {Array<Attribute>} List of attributes.\n     */\n    this.getAttributes = (\n    ) => {\n      return attributes\n    }\n\n    /**\n     * Get child components in hierarchy of this component.\n     * @returns {Array<Component>} List of components.\n     */\n    this.getChildren = (\n    ) => {\n      return children\n    }\n\n    /**\n     * Get root element of the component.\n     * @returns {HTMLElement} Element.\n     */\n    this.getElement = (\n    ) => {\n      return element\n    }\n\n    /**\n     * Get component id.\n     * @returns {symbol} Unique identifier.\n     */\n    this.getId = (\n    ) => {\n      return id\n    }\n\n    /**\n     * Get the library instance this component is from.\n     * @returns {Doars} Doars instance.\n     */\n    this.getLibrary = (\n    ) => {\n      return library\n    }\n\n    /**\n     * Get parent component in hierarchy of this component.\n     * @returns {Component} Component.\n     */\n    this.getParent = (\n    ) => {\n      return parent\n    }\n\n    /**\n     * Get the event dispatcher of state's proxy.\n     * @returns {ProxyDispatcher} State's proxy dispatcher.\n     */\n    this.getProxy = (\n    ) => {\n      return proxy\n    }\n\n    /**\n     * Get the component's state.\n     * @returns {Proxy} State.\n     */\n    this.getState = (\n    ) => {\n      return state\n    }\n\n    /**\n     * Set new parent component of this component.\n     * @param {Component} _parent Parent component.\n     */\n    this.setParent = (\n      _parent,\n    ) => {\n      parent = _parent\n    }\n\n    /**\n     * Initialize the component.\n     */\n    this.initialize = (\n    ) => {\n      if (isInitialized) {\n        return\n      }\n\n      // Set as enabled.\n      isInitialized = true\n\n      const { stateDirectiveName } = this.getLibrary().getOptions()\n\n      // Get component's state attribute.\n      const componentName = prefix + '-' + stateDirectiveName\n      const value = element.attributes[componentName].value\n\n      // Process expression for generating the state using a mock attribute.\n      data = value\n        ? processExpression(\n          this,\n          new Attribute(this, element, null, value),\n          value,\n        )\n        : {}\n      if (data === null) {\n        data = {}\n      } else if (typeof (data) !== 'object' || Array.isArray(data)) {\n        console.error('Doars: component tag must return an object!')\n        return\n      }\n\n      // Create proxy dispatcher for state.\n      proxy = new ProxyDispatcher()\n      // Add data to dispatcher to create the state.\n      state = proxy.add(data)\n\n      // Scan for attributes.\n      this.scanAttributes(element)\n    }\n\n    /**\n     * Destroy the component.\n     */\n    this.destroy = (\n    ) => {\n      if (!isInitialized) {\n        return\n      }\n\n      if (attributes.length > 0) {\n        // Filter out directives without a destroy function.\n        const directives = library.getDirectivesObject()\n        for (const key in directives) {\n          if (!directives[key].destroy) {\n            directives[key] = undefined\n          }\n        }\n\n        for (const attribute of attributes) {\n          // Clean up attribute if the directive has a destroy function.\n          const directive = directives[attribute.getKey()]\n          if (directive) {\n            directive.destroy(this, attribute, processExpression)\n          }\n\n          // Destroy the attribute.\n          attribute.destroy()\n        }\n      }\n\n      // Remove reference from element.\n      delete element[COMPONENT]\n\n      // Reset variables.\n      attributes = []\n\n      // Set as not initialized.\n      isInitialized = false\n\n      // Remove state and state handling.\n      proxy.remove(data)\n      state = null\n      proxy = null\n      data = null\n\n      // Store update triggers.\n      const triggers = []\n\n      // Set children as children of parent.\n      if (children.length > 0) {\n        for (const child of children) {\n          // Set new parent of children.\n          child.setParent(parent)\n\n          // Add parent update trigger.\n          triggers.push({\n            id: child.getId(),\n            path: 'parent',\n          })\n        }\n\n        // Add children update trigger.\n        triggers.push({\n          id,\n          path: 'children',\n        })\n      }\n      if (parent) {\n        if (children.length > 0) {\n          // Add children to parent.\n          parent.getChildren().push(...children)\n\n          // Add children update trigger.\n          triggers.push({\n            id: parent.getId(),\n            path: 'children',\n          })\n        }\n\n        // Add parent update trigger.\n        triggers.push({\n          id,\n          path: 'parent',\n        })\n      }\n\n      // Dispatch triggers.\n      if (triggers.length > 0) {\n        library.update(triggers)\n      }\n\n      // Dispatch event.\n      dispatchEvent('destroyed', {\n        element,\n        id,\n      })\n    }\n\n    /**\n     * Create and add an attribute. Assumes this attribute has not been added before.\n     * @param {HTMLElement} element Attribute element.\n     * @param {string} name Name of the attribute.\n     * @param {string} value Value of the attribute.\n     * @returns {Attribute} New attribute.\n     */\n    this.addAttribute = (\n      element,\n      name,\n      value,\n    ) => {\n      // Get directive keys from library.\n      const directivesKeys = library.getDirectivesNames()\n\n      // Create and add attribute.\n      const attribute = new Attribute(this, element, name, value)\n\n      // Get index to add attribute at.\n      let index = attribute.length\n      const directiveIndex = directivesKeys.indexOf(attribute.getDirective())\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        // If the other attribute is further down the keys list than add it after that item.\n        if (directivesKeys.indexOf(attributes[i].getDirective()) <= directiveIndex) {\n          index = i + 1\n          break\n        }\n      }\n\n      // Add to list of attributes.\n      attributes.splice(index, 0, attribute)\n\n      // Return new attribute.\n      return attribute\n    }\n\n    /**\n     * Remove an attribute.\n     * @param {Attribute} attribute The attribute to remove.\n     */\n    this.removeAttribute = (\n      attribute,\n    ) => {\n      // Get index of attribute in list.\n      const indexInAttributes = attributes.indexOf(attribute)\n      if (indexInAttributes < 0) {\n        return\n      }\n\n      // Get directives.\n      const directives = library.getDirectivesObject\n\n      // Attribute has been removed, call the destroy directive.\n      const directive = directives[attribute.getKey()]\n      if (directive && directive.destroy) {\n        directive.destroy(this, attribute, processExpression)\n      }\n\n      // Remove attribute from list.\n      attributes.splice(indexInAttributes, 1)\n\n      // Destroy attribute.\n      attribute.destroy()\n    }\n\n    /**\n     * Scans element for new attributes. It assumes this element as not been read before and is part of the component.\n     * @param {HTMLElement} element Element to scan.\n     * @returns {Array<Attribute>} New attributes.\n     */\n    this.scanAttributes = (\n      element,\n    ) => {\n      const {\n        stateDirectiveName,\n        ignoreDirectiveName,\n      } = this.getLibrary().getOptions()\n\n      // Get component's state attribute.\n      const componentName = prefix + '-' + stateDirectiveName\n      const ignoreName = prefix + '-' + ignoreDirectiveName\n\n      // Store new attributes.\n      const newAttributes = []\n\n      // Create iterator for walking over all elements in the component, skipping elements that are components or contain the ignore directive.\n      const iterator = walk(element, (element) => !element.hasAttribute(componentName) && !element.hasAttribute(ignoreName))\n      // Start on the given element then continue iterating over all children.\n      do {\n        for (const { name, value } of element.attributes) {\n          // Skip attribute if it is not that of a directive.\n          if (library.isDirectiveName(name)) {\n            newAttributes.push(this.addAttribute(element, name, value))\n          }\n        }\n      } while (element = iterator())\n\n      // Return new attributes.\n      return newAttributes\n    }\n\n    /**\n     * Update an attribute.\n     * @param {Attribute} attribute The attribute to update.\n     */\n    this.updateAttribute = (\n      attribute,\n    ) => {\n      // Check if the attribute is still relevant, since the attribute or element could have been removed.\n      if (!attribute.getElement() || attribute.getValue() === null || attribute.getValue() === undefined) {\n        this.removeAttribute(attribute)\n        return\n      }\n\n      // Get directives.\n      const directives = library.getDirectivesObject()\n\n      // Clear accessed.\n      attribute.clearAccessed()\n\n      // Process directive on attribute.\n      const directive = directives[attribute.getDirective()]\n      if (directive) {\n        directive.update(this, attribute, processExpression)\n      }\n    }\n\n    /**\n     * Update the specified attributes of the component.\n     * @param {Array<Attribute>} attributes Attributes to update.\n     */\n    this.updateAttributes = (\n      attributes,\n    ) => {\n      if (!isInitialized || attributes.length <= 0) {\n        if (!hasUpdated) {\n          // Dispatch updated event anyway.\n          hasUpdated = true\n          dispatchEvent('updated', {\n            attributes,\n            element,\n            id,\n          })\n        }\n        return\n      }\n\n      for (const attribute of attributes) {\n        this.updateAttribute(attribute)\n      }\n\n      // Dispatch updated event.\n      hasUpdated = true\n      dispatchEvent('updated', {\n        attributes,\n        element,\n        id,\n      })\n    }\n\n    /**\n     * Start updating the component's attributes.\n     * @param {Array<object>} triggers List of triggers.\n     */\n    this.update = (\n      triggers,\n    ) => {\n      if (!isInitialized) {\n        return\n      }\n\n      // Get all ids of triggers.\n      const triggerIds = Object.getOwnPropertySymbols(triggers)\n\n      // Update all attributes whose accessed items match any update trigger.\n      const updatedAttributes = []\n      for (const attribute of attributes) {\n        for (const id of triggerIds) {\n          if (attribute.hasAccessed(id, triggers[id])) {\n            this.updateAttribute(attribute)\n            updatedAttributes.push(attribute)\n          }\n        }\n      }\n\n      // Dispatch updated event.\n      if (!hasUpdated || updatedAttributes.length > 0) {\n        hasUpdated = true\n        dispatchEvent('updated', {\n          attributes: updatedAttributes,\n          element,\n          id,\n        })\n      }\n    }\n  }\n}\n", "/**\n * @typedef {import('../Attribute.js').default} Attribute\n * @typedef {import('../Component.js').default} Component\n * @typedef {import('../Context.js').DestroyFunction} DestroyFunction\n * @typedef {import('../Context.js').UpdateFunction} UpdateFunction\n * @typedef {import('../Doars.js').ContextMap} ContextMap\n */\n\n// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n\n/**\n * @typedef CreatedContexts\n * @type {object}\n * @property {ContextMap} contexts The contexts.\n * @property {() => never} destroy Destroy callback.\n * @property {string} before Text to place before function definition.\n * @property {string} after Text to place after function definition.\n * @property {Array<string>} deconstructed List of context names to deconstruct.\n */\n\n/**\n * Create component's contexts for an attributes expression.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {UpdateFunction} update Called when update needs to be invoked.\n * @param {object|null} extra Optional extra context items.\n * @returns {CreatedContexts} Expressions contexts and destroy functions.\n */\nexport const createContexts = (\n  component,\n  attribute,\n  update,\n  extra = null,\n) => {\n  // Get library.\n  const library = component.getLibrary()\n\n  // Start with the simple contexts.\n  const contexts = library.getSimpleContexts()\n\n  /** @type {Array<string>} */\n  const deconstructed = []\n  let after = '', before = ''\n  // Iterate over all contexts.\n  const creatableContexts = library.getContexts()\n  // Store destroy functions.\n  /** @type {Array<DestroyFunction>} */\n  const destroyFunctions = []\n  for (const creatableContext of creatableContexts) {\n    if (!creatableContext || !creatableContext.name) {\n      continue\n    }\n\n    // Get context result.\n    const result = creatableContext.create(\n      component,\n      attribute,\n      update,\n    )\n    if (!result || !result.value) {\n      continue\n    }\n\n    // Store destroy functions.\n    if (result.destroy && typeof (result.destroy) === 'function') {\n      destroyFunctions.push(result.destroy)\n    }\n\n    // Deconstruct options if marked as such.\n    if (creatableContext.deconstruct && typeof (result.value) === 'object') {\n      deconstructed.push(creatableContext.name)\n      before += 'with(' + creatableContext.name + ') { '\n      after += ' }'\n    }\n\n    // Store result value in context results.\n    contexts[creatableContext.name] = result.value\n  }\n\n  // Add extra items to context.\n  if (typeof (extra) === 'object') {\n    for (const name in extra) {\n      contexts[name] = extra[name]\n    }\n  }\n\n  return {\n    contexts,\n    destroy: (\n    ) => {\n      // Call all destroy functions.\n      for (const destroyFunction of destroyFunctions) {\n        destroyFunction()\n      }\n    },\n\n    after,\n    before,\n    deconstructed,\n  }\n}\n\n/**\n * Create component's contexts only after the context gets used.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {UpdateFunction} update Called when update needs to be invoked.\n * @param {object|undefined} extra Optional extra context items.\n * @returns {Proxy} Expressions contexts' proxy.\n */\nexport const createContextsProxy = (\n  component,\n  attribute,\n  update,\n  extra = null,\n) => {\n  // Store context after first call.\n  let data = null\n  // Create context proxy.\n  const revocable = RevocableProxy({}, {\n    get: (\n      target,\n      property,\n    ) => {\n      // Create context.\n      if (!data) {\n        data = createContexts(component, attribute, update, extra)\n      }\n\n      // Check if name exists in context.\n      if (property in data.contexts) {\n        // Call accessed callback if element or state is accessed.\n        attribute.accessed(component.getId(), property)\n\n        // Return value.\n        return data.contexts[property]\n      }\n\n      // Try and get value from state.\n      if (data.contexts.$state) {\n        if (property in data.contexts.$state) {\n          // Call accessed callback if element or state is accessed.\n          attribute.accessed(component.getId(), '$state')\n\n          // Return value.\n          return data.contexts.$state[property]\n        }\n      }\n    },\n  })\n\n  // Return context.\n  return {\n    contexts: revocable.proxy,\n    destroy: (\n    ) => {\n      // Call destroy on created context.\n      if (data && data.destroy) {\n        data.destroy(component, attribute)\n      }\n\n      // Revoke proxy.\n      revocable.revoke()\n    },\n  }\n}\n\n/**\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {object|undefined} extra Optional extra context items.\n * @returns {Array<ContextMap|() => never>} Contexts and destroy function.\n */\nexport const createAutoContexts = (\n  component,\n  attribute,\n  extra = null,\n) => {\n  // Collect update triggers.\n  const triggers = []\n  const update = (id, context) => {\n    triggers.push({\n      id,\n      path: context,\n    })\n  }\n\n  // Create function context.\n  const {\n    contexts,\n    destroy,\n  } = createContexts(\n    component,\n    attribute,\n    update,\n    extra,\n  )\n\n  return [contexts, () => {\n    // Invoke destroy.\n    destroy()\n\n    // Dispatch update triggers.\n    if (triggers.length > 0) {\n      component.getLibrary().update(triggers)\n    }\n  }]\n}\n\nexport default {\n  createAutoContexts,\n  createContexts,\n  createContextsProxy,\n}\n", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n\nimport { createContextsProxy } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the children context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  childrenContextName,\n}) => ({\n  name: childrenContextName,\n\n  create: (\n    component,\n    attribute,\n    update,\n  ) => {\n    // Create contexts proxy for children.\n    let childrenContexts\n    const revocable = RevocableProxy(component.getChildren(), {\n      get: (target, key, receiver) => {\n        if (!childrenContexts) {\n          // Create list of child contexts.\n          childrenContexts = target.map((child) => createContextsProxy(child, attribute, update))\n\n          // Set children of this component as accessed.\n          attribute.accessed(component.getId(), 'children')\n        }\n\n        // If not a number then do a normal access.\n        if (isNaN(key)) {\n          return Reflect.get(childrenContexts, key, receiver)\n        }\n\n        // Return context from child.\n        const child = Reflect.get(childrenContexts, key, receiver)\n        if (child) {\n          return child.contexts\n        }\n      },\n    })\n\n    return {\n      value: revocable.proxy,\n\n      destroy: (\n      ) => {\n        // Call destroy on all created contexts.\n        if (childrenContexts) {\n          childrenContexts.forEach((child) => child.destroy())\n        }\n\n        // Revoke proxy.\n        revocable.revoke()\n      },\n    }\n  },\n})\n", "/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the component context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  componentContextName,\n}) => ({\n  name: componentContextName,\n\n  create: (\n    component,\n  ) => ({\n    // Return the component's element.\n    value: component.getElement(),\n  }),\n})\n", "/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the element context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  elementContextName,\n}) => ({\n  name: elementContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => ({\n    // Return the attribute's element.\n    value: attribute.getElement(),\n  }),\n})\n", "/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the dispatch context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  dispatchContextName,\n}) => ({\n  name: dispatchContextName,\n\n  create: (\n    component,\n  ) => {\n    // Return the dispatch method.\n    return {\n      value: (\n        name,\n        detail = {},\n      ) => {\n        // Dispatch the event after the elements have updated.\n        component.getElement().dispatchEvent(\n          new CustomEvent(name, {\n            detail,\n            bubbles: true,\n          }),\n        )\n      },\n    }\n  },\n})\n", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n// Import symbols.\nimport { FOR } from '../symbols.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the for context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  forContextDeconstruct,\n  forContextName,\n}) => ({\n  deconstruct: forContextDeconstruct,\n\n  name: forContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => {\n    // Exit early in parent contexts.\n    if (component !== attribute.getComponent()) {\n      return\n    }\n\n    // Deconstruct attribute.\n    let element = attribute.getElement()\n\n    // Walk up the tree until the component's root element is found.\n    const componentElement = component.getElement(), items = [], target = {}\n    while (element && !element.isSameNode(componentElement)) {\n      // Check if element has for symbol.\n      const data = element[FOR]\n      if (data) {\n        items.push(data)\n\n        for (const key in data.variables) {\n          target[key] = data.variables[key]\n        }\n      }\n\n      // Go up the document tree.\n      element = element.parentNode\n    }\n\n    if (items.length === 0) {\n      return\n    }\n\n    // Create revocable proxy.\n    const revocable = RevocableProxy(target, {\n      get: (\n        target,\n        key,\n      ) => {\n        for (const item of items) {\n          if (key in item.variables) {\n            // Mark as accessed for data.\n            attribute.accessed(item.id, '$for')\n\n            // Return value at key.\n            return item.variables[key]\n          }\n        }\n      },\n    })\n\n    // Set keys and return values.\n    return {\n      value: revocable.proxy,\n\n      destroy: (\n      ) => {\n        revocable.revoke()\n      },\n    }\n  },\n})\n", "import { createContexts } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the inContext context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  inContextContextName,\n}) => ({\n  name: inContextContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => ({\n    value: (\n      callback,\n    ) => {\n      // Collect update triggers.\n      const newTriggers = []\n      const contextUpdate = (\n        id,\n        path,\n      ) => {\n        newTriggers.push({\n          id,\n          path,\n        })\n      }\n\n      // Create contexts.\n      const {\n        contexts,\n        destroy,\n      } = createContexts(\n        component,\n        attribute,\n        contextUpdate,\n        {},\n      )\n\n      // Invoke callback and store its result.\n      const result = callback(contexts)\n\n      // Destroy contexts.\n      destroy()\n\n      // Dispatch update triggers.\n      if (newTriggers.length > 0) {\n        component.getLibrary().update(newTriggers)\n      }\n\n      // Return callback's result.\n      return result\n    },\n  }),\n})\n", "import { createContextsProxy } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the children context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  nextSiblingContextName,\n}) => ({\n  name: nextSiblingContextName,\n\n  create: (\n    component,\n    attribute,\n    update,\n  ) => {\n    const parent = component.getParent()\n    if (!parent) {\n      return {\n        value: null,\n      }\n    }\n    const siblings = parent.getChildren()\n    const index = siblings.indexOf(component)\n    if (index + 1 >= siblings.length) {\n      return {\n        value: null,\n      }\n    }\n\n    // Create contexts proxy for sibling.\n    const {\n      contexts,\n      destroy,\n    } = createContextsProxy(siblings[index + 1], attribute, update)\n\n    return {\n      value: contexts,\n\n      destroy,\n    }\n  },\n})\n", "import { createContexts } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the nextTick context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  nextTickContextName,\n}) => ({\n  name: nextTickContextName,\n\n  create: (\n    component,\n    attribute,\n    update,\n  ) => {\n    // Keep track of callbacks.\n    let callbacks\n\n    // The setup process is delayed since we only want this code to run if the context is used.\n    let isInitialized = false\n    const initialize = (\n    ) => {\n      // Exit early if already setup.\n      if (isInitialized) {\n        return\n      }\n      isInitialized = true\n\n      // Deconstruct component.\n      const library = component.getLibrary()\n\n      // Setup callbacks list.\n      callbacks = []\n\n      // Remove and invoke each callback in the list.\n      const handleUpdate = (\n      ) => {\n        // Stop listening the update has happened.\n        stopListening()\n\n        // Create function context.\n        const {\n          contexts,\n          destroy,\n        } = createContexts(component, attribute, update, {})\n\n        // Invoke all callbacks.\n        for (const callback of callbacks) {\n          callback(contexts)\n        }\n\n        // Destroy contexts.\n        destroy()\n      }\n\n      // Stop listening for the update event and attribute changes.\n      const stopListening = (\n      ) => {\n        // Stop listening for updated event.\n        library.removeEventListener('updated', handleUpdate)\n\n        // Remove self from listening.\n        attribute.removeEventListener('changed', stopListening)\n        attribute.removeEventListener('destroyed', stopListening)\n      }\n\n      // Listen to the libraries updated event.\n      library.addEventListener('updated', handleUpdate)\n\n      // Stop listening if the attribute changes since this directive will be run again.\n      attribute.addEventListener('changed', stopListening)\n      attribute.addEventListener('destroyed', stopListening)\n    }\n\n    return {\n      value: (\n        callback,\n      ) => {\n        // Do delayed setup now.\n        initialize()\n\n        // Add callback to list.\n        callbacks.push(callback)\n      },\n    }\n  },\n})\n", "import { createContextsProxy } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the parent context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  parentContextName,\n}) => ({\n  name: parentContextName,\n\n  create: (\n    component,\n    attribute,\n    update,\n  ) => {\n    // Deconstruct component.\n    const parent = component.getParent()\n    if (!parent) {\n      return {\n        value: null,\n      }\n    }\n\n    // Create contexts proxy for parent.\n    const {\n      contexts,\n      destroy,\n    } = createContextsProxy(parent, attribute, update)\n\n    return {\n      value: contexts,\n\n      destroy,\n    }\n  },\n})\n", "import { createContextsProxy } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the children context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  previousSiblingContextName,\n}) => ({\n  name: previousSiblingContextName,\n\n  create: (\n    component,\n    attribute,\n    update,\n  ) => {\n    const parent = component.getParent()\n    if (!parent) {\n      return {\n        value: null,\n      }\n    }\n    const siblings = parent.getChildren()\n    const index = siblings.indexOf(component)\n    if (index <= 0) {\n      return {\n        value: null,\n      }\n    }\n\n    // Create contexts proxy for sibling.\n    const {\n      contexts,\n      destroy,\n    } = createContextsProxy(siblings[index - 1], attribute, update)\n\n    return {\n      value: contexts,\n\n      destroy,\n    }\n  },\n})\n", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n// Import symbols.\nimport { REFERENCES, REFERENCES_CACHE } from '../symbols.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the references context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  referencesContextName,\n}) => ({\n  name: referencesContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => {\n    // Exit early if no references exist.\n    if (!component[REFERENCES]) {\n      return {\n        value: [],\n      }\n    }\n\n    // Generate references cache.\n    let cache = component[REFERENCES_CACHE]\n    if (!cache) {\n      // Get references from component.\n      const references = component[REFERENCES]\n      const attributeIds = Object.getOwnPropertySymbols(references)\n\n      // Convert references to a named object.\n      cache = {}\n      for (const id of attributeIds) {\n        const { element, name } = references[id]\n        cache[name] = element\n      }\n      component[REFERENCES_CACHE] = cache\n    }\n\n    // Create revocable proxy.\n    const revocable = RevocableProxy(cache, {\n      get: (\n        target,\n        propertyKey,\n        receiver,\n      ) => {\n        // Mark references as accessed.\n        attribute.accessed(component.getId(), '$references.' + propertyKey)\n\n        // Return reference.\n        return Reflect.get(target, propertyKey, receiver)\n      },\n    })\n\n    // Return references proxy.\n    return {\n      value: revocable.proxy,\n\n      destroy: (\n      ) => {\n        revocable.revoke()\n      },\n    }\n  },\n})\n", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n\nimport { createContextsProxy } from '../utilities/Context.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the children context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  siblingsContextName,\n}) => ({\n  name: siblingsContextName,\n\n  create: (\n    component,\n    attribute,\n    update,\n  ) => {\n    const parent = component.getParent()\n    if (!parent) {\n      return {\n        value: [],\n      }\n    }\n    // Create contexts proxy for children.\n    let siblingsContexts\n    const revocable = RevocableProxy(\n      parent\n        .getChildren()\n        .filter((sibling) => sibling !== component),\n      {\n        get: (target, key, receiver) => {\n          if (!siblingsContexts) {\n            // Create list of child contexts.\n            siblingsContexts = target.map((child) => createContextsProxy(child, attribute, update))\n\n            // Set children of this component as accessed.\n            attribute.accessed(component.getId(), 'siblings')\n          }\n\n          // If not a number then do a normal access.\n          if (isNaN(key)) {\n            return Reflect.get(siblingsContexts, key, receiver)\n          }\n\n          // Return context from child.\n          const sibling = Reflect.get(siblingsContexts, key, receiver)\n          if (sibling) {\n            return sibling.contexts\n          }\n        },\n      },\n    )\n\n    return {\n      value: revocable.proxy,\n\n      destroy: (\n      ) => {\n        // Call destroy on all created contexts.\n        if (siblingsContexts) {\n          siblingsContexts.forEach((child) => child.destroy())\n        }\n\n        // Revoke proxy.\n        revocable.revoke()\n      },\n    }\n  },\n})\n", "/**\n * @typedef {import('../events/ProxyDispatcher.js').ProxyDispatcher} ProxyDispatcher\n */\n\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n/**\n * Factory function to create a context for a state which dispatched update events when mutated.\n * @param {string} name Name of the state.\n * @param {string} id Identifier of the state.\n * @param {object} state Data of the state.\n * @param {ProxyDispatcher} proxy Dispatcher to pass events through.\n * @returns {object} Proxied state and destroy callback.\n */\nexport default (\n  name,\n  id,\n  state,\n  proxy,\n) => {\n  return (\n    component,\n    attribute,\n    update,\n  ) => {\n    // Create event handlers.\n    const onDelete = (\n      target,\n      path,\n    ) => update(id, name + '.' + path.join('.'))\n    const onGet = (\n      target,\n      path,\n    ) => attribute.accessed(id, name + '.' + path.join('.'))\n    const onSet = (\n      target,\n      path,\n    ) => update(id, name + '.' + path.join('.'))\n\n    // Add event listeners.\n    proxy.addEventListener('delete', onDelete)\n    proxy.addEventListener('get', onGet)\n    proxy.addEventListener('set', onSet)\n\n    // Wrap in a revocable proxy.\n    const revocable = RevocableProxy(state, {})\n\n    return {\n      value: revocable.proxy,\n\n      // Remove event listeners.\n      destroy: (\n      ) => {\n        proxy.removeEventListener('delete', onDelete)\n        proxy.removeEventListener('get', onGet)\n        proxy.removeEventListener('set', onSet)\n\n        // Revoke access to state.\n        revocable.revoke()\n      },\n    }\n  }\n}\n", "import createState from '@doars/common/src/factories/createState'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the state context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  stateContextDeconstruct,\n  stateContextName,\n}) => ({\n  deconstruct: stateContextDeconstruct,\n\n  name: stateContextName,\n\n  // Wrap create state so the component's data can be used.\n  create: (\n    component,\n    attribute,\n    update,\n    utilities,\n  ) => {\n    // Deconstruct component.\n    const proxy = component.getProxy()\n    const state = component.getState()\n    if (!proxy || !state) {\n      return\n    }\n\n    return (\n      createState(\n        stateContextName,\n        component.getId(),\n        state,\n        proxy,\n      )(\n        component,\n        attribute,\n        update,\n        utilities,\n      )\n    )\n  },\n})\n", "/**\n * Deeply assign a series of objects properties together.\n * @param {object} target Target object to merge to.\n * @param {...object} sources Objects to merge into the target.\n * @returns {object} Merged resulting object.\n */\nexport const deepAssign = (\n  target,\n  ...sources\n) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {object} object Object to get from.\n * @param  {Array<string>} path Path to value.\n * @returns {any} value at path.\n */\nexport const getDeeply = (\n  object,\n  path,\n) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {any} value Value of unknown type.\n * @returns {boolean} Whether the value is an object.\n */\nexport const isObject = (\n  value,\n) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {object} object Object to set on.\n * @param {Array<string>} path Path to value.\n * @param {any} value Value to set.\n */\nexport const setDeeply = (\n  object,\n  path,\n  value,\n) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n", "import createState from './createState.js'\n\n/**\n * @typedef {import('../events/ProxyDispatcher.js').default} ProxyDispatcher\n * @typedef {import('../polyfills/RevocableProxy.js').RevocableProxy} RevocableProxy\n */\n\n/**\n * Function called when the context needs to be destroyed.\n * @callback DestroyStateContext\n */\n\n/**\n * @typedef StateContext\n * @type {object}\n * @property {Proxy} value The proxy of the state to mutate.\n * @property {DestroyStateContext} destroy The proxy of the state.\n */\n\n/**\n * Factory function to create a context for a state which dispatched update events when mutated.\n * @param {string} name Name of the state.\n * @param {string} id Identifier of the state.\n * @param {object} state Data of the state.\n * @param {ProxyDispatcher} proxy Dispatcher to pass events through.\n * @param {boolean} deconstruct Whether to deconstruct the state or require the name prefix.\n * @returns {object} Proxied state and destroy callback.\n */\nexport default (\n  name,\n  id,\n  state,\n  proxy,\n  deconstruct,\n) => ({\n  deconstruct,\n\n  name,\n\n  create: createState(\n    name,\n    id,\n    state,\n    proxy,\n  ),\n})\n", "import { deepAssign } from '@doars/common/src/utilities/Object.js'\nimport createStateContext from '@doars/common/src/factories/createStateContext.js'\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\n\n/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the store context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  storeContextDeconstruct,\n  storeContextInitial,\n  storeContextName,\n}) => {\n  // Create a single proxy for the store.\n  const data = deepAssign({}, storeContextInitial)\n  const proxy = new ProxyDispatcher()\n  const state = proxy.add(data)\n\n  return createStateContext(\n    storeContextName,\n    Symbol('ID_STORE'),\n    state,\n    proxy,\n    storeContextDeconstruct,\n  )\n}\n", "/**\n * @typedef {import('../Context.js').Context} Context\n * @typedef {import('../Doars.js').default} Doars\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n * @typedef {import('../Doars.js').Trigger} Trigger\n */\n\nimport { createContexts } from '../utilities/Context.js'\n\n/**\n * @callback WatchCallback\n * @param {object} context New context.\n * @returns {never}\n */\n\n/**\n * @typedef WatchReturn\n * @type {Function}\n */\n\n/**\n * Create the state context.\n * @param {DoarsOptions} options Library options.\n * @returns {Context} The context.\n */\nexport default ({\n  watchContextName,\n}) => ({\n  name: watchContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => {\n    let callbacks = null,\n      contextIsDestroyed = false,\n      directiveIsDestroyed = false,\n      isInitialized = false,\n      processExpression = null\n\n    const initialized = (\n    ) => {\n      isInitialized = true\n      callbacks = []\n\n      // Get the expression processor.\n      const library = component.getLibrary()\n      processExpression = library.getProcessor()\n\n      /**\n       * @param {Doars} _ Doars library instance.\n       * @param {Array<Trigger>} triggers List of triggers that will be handled.\n       * @returns {void}\n       */\n      const onUpdate = (_, triggers) => {\n        const ids = Object.getOwnPropertySymbols(triggers)\n        if (ids.length > 0) {\n          // Collect update triggers.\n          const newTriggers = []\n          const contextUpdate = (\n            id,\n            path,\n          ) => {\n            newTriggers.push({\n              id,\n              path,\n            })\n          }\n\n          for (const id of ids) {\n            for (const callback of callbacks) {\n              // Process path in order to compare the triggers against the accessed values.\n              if (!callback.attribute) {\n                callback.attribute = attribute.clone()\n                processExpression(\n                  component,\n                  callback.attribute,\n                  callback.path,\n                )\n              }\n\n              if (callback.attribute.hasAccessed(id, triggers[id])) {\n                // Invoke callback and provide it with a new context.\n                const {\n                  contexts,\n                  destroy,\n                } = createContexts(\n                  component,\n                  attribute,\n                  contextUpdate,\n                  {},\n                )\n                callback.callback(contexts)\n                destroy()\n\n                // Go to the next callback, only allow it to be invoked once.\n                continue\n              }\n            }\n          }\n\n          // Dispatch update triggers.\n          if (newTriggers.length > 0) {\n            component.getLibrary().update(newTriggers)\n          }\n        }\n      }\n\n      const stopHandling = () => {\n        if (!directiveIsDestroyed) {\n          // Mark as destroyed.\n          directiveIsDestroyed = true\n\n          // Remove any references to this context.\n          attribute.removeEventListener('changed', stopHandling)\n          attribute.removeEventListener('destroyed', stopHandling)\n          library.removeEventListener('updating', onUpdate)\n        }\n      }\n      // Stop handling since it will be re-ran.\n      attribute.addEventListener('changed', stopHandling)\n      // Stop handling since the attribute is destroyed.\n      attribute.addEventListener('destroyed', stopHandling)\n\n      // Start listening for changes.\n      library.addEventListener('updating', onUpdate)\n    }\n\n    return {\n      /**\n       * Watch a value at the given path and on change invoke the callback.\n       * @param {string} path Path to the value that needs to be watched.\n       * @param {WatchCallback} callback Function to call when the value at the path has changed.\n       * @returns {WatchReturn|undefined} Function to invoke the callback with.\n       */\n      value: (\n        path,\n        callback,\n      ) => {\n        // Don't allow new listeners after the context has been destroyed.\n        if (contextIsDestroyed || directiveIsDestroyed) {\n          return\n        }\n\n        if (!isInitialized) {\n          initialized()\n        }\n\n        // Store path and callback.\n        callbacks.push({\n          path,\n          callback,\n        })\n\n        // Return a function that can be called to invoke the callback immediately.\n        return (\n        ) => {\n          // Collect update triggers.\n          const newTriggers = []\n          const contextUpdate = (\n            id,\n            path,\n          ) => {\n            newTriggers.push({\n              id,\n              path,\n            })\n          }\n\n          // Invoke callback and provide it with a new context.\n          const {\n            contexts,\n            destroy,\n          } = createContexts(\n            component,\n            attribute.clone(),\n            contextUpdate,\n            {},\n          )\n          callback(contexts)\n          destroy()\n\n          // Dispatch update triggers.\n          if (newTriggers.length > 0) {\n            component.getLibrary().update(newTriggers)\n          }\n        }\n      },\n\n      destroy: () => {\n        contextIsDestroyed = true\n      },\n    }\n  },\n})\n", "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (\n  value,\n) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (\n  value,\n) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n", "// Import utilities.\nimport { setAttribute, setAttributes } from '@doars/common/src/utilities/Attribute.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { parseSelector } from '@doars/common/src/utilities/String.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the attribute directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  attributeDirectiveName,\n}) => ({\n  name: attributeDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const directive = attribute.getDirective()\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    const set = (\n      value,\n    ) => {\n      if (modifiers.selector) {\n        if (typeof (value) !== 'string') {\n          console.error('Doars: Value returned to \"' + directive + '\" directive must be a string if the selector modifier is set.')\n          return\n        }\n        value = parseSelector(value)\n\n        setAttributes(element, value)\n        return\n      }\n\n      // Deconstruct attribute.\n      const key = attribute.getKeyRaw()\n\n      if (!key) {\n        // Set attributes on element.\n        if (typeof (value) === 'object' && !Array.isArray(value)) {\n          setAttributes(element, value)\n        } else {\n          console.error('Doars: Value returned to \"' + directive + '\" directive of invalid type.')\n        }\n\n        return\n      }\n\n      // Set attribute on element at key.\n      setAttribute(element, key, value)\n    }\n\n    // Execute attribute value.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n})\n", "// Import utilities.\nimport { parseSelector } from './String.js'\nimport { addAttributes, removeAttributes } from './Attribute.js'\n\n// Transition name.\nconst TRANSITION_NAME = '-transition:'\n\n/**\n * @callback TransitionEnd\n */\n\n/**\n * Transition an element.\n * @param {string} type Type of transition, for example 'in' and 'out'.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transition = (\n  type,\n  libraryOptions,\n  element,\n  callback = null,\n) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback()\n    }\n    return\n  }\n\n  // Transition attribute name.\n  const transitionDirectiveName = libraryOptions.prefix + TRANSITION_NAME + type\n\n  // Setup dispatcher function.\n  const dispatchEvent = (phase) => {\n    element.dispatchEvent(\n      new CustomEvent('transition-' + phase),\n    )\n    element.dispatchEvent(\n      new CustomEvent('transition-' + type + '-' + phase),\n    )\n  }\n\n  // Declare variables for later.\n  let name, value, timeout, requestFrame\n  let isDone = false\n  const selectors = {}\n\n  // Process transition during attribute.\n  name = transitionDirectiveName\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.during = parseSelector(value)\n    addAttributes(element, selectors.during)\n  }\n\n  // Process transition from attribute.\n  name = transitionDirectiveName + '.from'\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.from = parseSelector(value)\n    addAttributes(element, selectors.from)\n  }\n\n  // Dispatch transition event.\n  dispatchEvent('start')\n\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null\n\n    // If cancelled then stop immediately.\n    if (isDone) {\n      return\n    }\n\n    // Remove from selector.\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    }\n\n    // Process transition to attribute.\n    name = transitionDirectiveName + '.to'\n    value = element.getAttribute(name)\n    // Parse and apply returned selector.\n    if (value) {\n      selectors.to = parseSelector(value)\n      addAttributes(element, selectors.to)\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n      return\n    }\n\n    // Get computes style.\n    const styles = getComputedStyle(element)\n\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null\n\n      // If cancelled then stop immediately.\n      if (isDone) {\n        return\n      }\n\n      // Remove during selector.\n      if (selectors.during) {\n        removeAttributes(element, selectors.during)\n        selectors.during = undefined\n      }\n\n      // Remove to selector.\n      if (selectors.to) {\n        removeAttributes(element, selectors.to)\n        selectors.to = undefined\n      }\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n    }, duration)\n  })\n\n  return (\n  ) => {\n    if (!isDone) {\n      return\n    }\n    isDone = true\n\n    // Remove applied selector.\n    if (selectors.during) {\n      removeAttributes(element, selectors.during)\n      selectors.during = undefined\n    }\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to)\n      selectors.to = undefined\n    }\n\n    // Clear request animation frame and timeout.\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame)\n      requestFrame = null\n    } else if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    // Dispatch end event.\n    dispatchEvent('end')\n    // Invoke callback.\n    if (callback) {\n      callback()\n    }\n  }\n}\n\n/**\n * Transition an element in.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionIn = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('in', libraryOptions, element, callback)\n}\n\n/**\n * Transition an element out.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionOut = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('out', libraryOptions, element, callback)\n}\n\nexport default {\n  transition,\n  transitionIn,\n  transitionOut,\n}\n", "import { transitionIn } from '@doars/common/src/utilities/Transition.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the cloak directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  cloakDirectiveName,\n}) => ({\n  name: cloakDirectiveName,\n\n  update: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const libraryOptions = component.getLibrary().getOptions()\n\n    // Remove attribute from element.\n    element.removeAttribute(\n      libraryOptions.prefix + '-' + this.name,\n    )\n\n    // Transition in.\n    transitionIn(libraryOptions, element)\n  },\n})\n", "import { walk } from './Element.js'\n\n/**\n * Re-adds a script to the document in order to trigger it again.\n * @param {HTMLElement} element Script to re-add to the DOM.\n * @returns {void}\n */\nconst _readdScript = (\n  element,\n) => {\n  // Check if element is a script without a source.\n  if (\n    element.tagName !== 'SCRIPT' ||\n    element.hasAttribute('src')\n  ) {\n    return false\n  }\n\n  // Set up new script with same content.\n  const newScript = document.createElement('script')\n  newScript.innerText = element.innerText\n\n  // Replace script in the document.\n  element.parentNode.insertBefore(\n    newScript,\n    element,\n  )\n  element.remove()\n  return true\n}\n\n/**\n * Checks the elements for scripts and re-adds these to the DOM.\n * @param  {...HTMLElement} elements Elements to check for scripts.\n * @returns {void}\n */\nexport const readdScripts = (\n  ...elements\n) => {\n  for (const element of elements) {\n    // Try to re-add element in case it is a script.\n    if (!_readdScript(element)) {\n      // Otherwise check its children.\n      const iterate = walk(element)\n      let maybeScript = null\n      while (maybeScript = iterate()) {\n        _readdScript(maybeScript)\n      }\n    }\n  }\n}\n\nexport default {\n  readdScripts,\n}\n", "// Import symbols.\nimport { FOR } from '../symbols.js'\n\n// Import utilities.\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { readdScripts } from '@doars/common/src/utilities/Script.js'\nimport { parseForExpression } from '@doars/common/src/utilities/String.js'\nimport {\n  transitionIn,\n  transitionOut,\n} from '@doars/common/src/utilities/Transition.js'\n\n/**\n * @typedef {import('../Component.js').default} Component\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Add values add object by name in given order.\n * @param {Array<string>} names Names of values.\n * @param  {...any} values Values to add to object.\n * @returns {object} Resulting object with values at names.\n */\nconst createVariables = (\n  names,\n  ...values\n) => {\n  const variables = {}\n  for (let i = 0; i < values.length; i++) {\n    if (i >= names.length) {\n      break\n    }\n    variables[names[i]] = values[i]\n  }\n  return variables\n}\n\n/**\n * Finds the index of an element in list matching the value.\n * @param {HTMLElement} elements List of elements to search through.\n * @param {any} value Value to compare to.\n * @param {number} offset The index to start searching after.\n * @returns {number} Index of value in elements.\n */\nconst indexInSiblings = (\n  elements,\n  value,\n  offset = -1,\n) => {\n  offset++\n  if (offset >= elements.length) {\n    return -1\n  }\n\n  if (elements[offset][FOR].value === value) {\n    return offset\n  }\n\n  return indexInSiblings(\n    elements,\n    value,\n    offset,\n  )\n}\n\n/**\n * Adds item to document at right index.\n * @param {Component} component Component attribute is part of.\n * @param {Function} update Update trigger function.\n * @param {DocumentFragment} template Template of items.\n * @param {Array<HTMLElement>} elements Existing item elements.\n * @param {number} index Index to start looking from.\n * @param {any} value Value of item to add.\n * @param {object} variables Variables associated with item.\n * @param {boolean} allowInlineScript Whether to allow inline scripts.\n * @returns {void}\n */\nconst setAfter = (\n  component,\n  update,\n  template,\n  elements,\n  index,\n  value,\n  variables,\n  allowInlineScript,\n) => {\n  const libraryOptions = component.getLibrary().getOptions()\n\n  const existingIndex = indexInSiblings(elements, value, index)\n  if (existingIndex >= 0) {\n    // Exit early it is already in place.\n    if (existingIndex === index + 1) {\n      return\n    }\n\n    // Get existing element to move.\n    const element = elements[existingIndex];\n\n    // Move element after element at index or directly after the template.\n    (elements[index] ? elements[index] : template).insertAdjacentElement('afterend', element)\n\n    // Update all attributes using this for item's data.\n    update(element[FOR].id)\n\n    return\n  }\n\n  // Create new element from template.\n  let element = document.importNode(template.content, true)\n  // Add element after template or element at index.\n  const sibling = index === -1 ? template : elements[index]\n  sibling.insertAdjacentElement('afterend', element)\n  // Get HTMLElement reference instead of DocumentFragment.\n  element = sibling.nextElementSibling\n  if (allowInlineScript) {\n    readdScripts(element)\n  }\n\n  // Transition in.\n  transitionIn(libraryOptions, element)\n\n  // Store data.\n  element[FOR] = {\n    id: Symbol('ID_FOR'),\n    value,\n    variables,\n  }\n\n  // Store reference.\n  elements.splice(index + 1, 0, element)\n}\n\n/**\n * Removes elements after maximum length.\n * @param {Component} component Component the elements are part of.\n * @param {Array<HTMLElement>} elements List of existing elements.\n * @param {number} maxLength Maximum number of elements.\n */\nconst removeAfter = (\n  component,\n  elements,\n  maxLength,\n) => {\n  // Exit early if length is not exceeded.\n  if (elements.length < maxLength) {\n    return\n  }\n\n  const libraryOptions = component.getLibrary().getOptions()\n\n  // Iterate over exceeding elements.\n  for (let i = elements.length - 1; i >= maxLength; i--) {\n    // Remove element from list.\n    const element = elements[i]\n    elements.splice(i, 1)\n\n    // Transition out.\n    transitionOut(libraryOptions, element, () => {\n      element.remove()\n    })\n  }\n}\n\n/**\n * Create the for directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  allowInlineScript,\n  forDirectiveName,\n}) => ({\n  name: forDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const directive = attribute.getDirective()\n    const template = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    // Check if placed on a template tag.\n    if (template.tagName !== 'TEMPLATE') {\n      console.warn('Doars: \"' + directive + '\" directive must be placed on a TEMPLATE tag.')\n      return\n    }\n\n    const expression = parseForExpression(attribute.getValue())\n    if (!expression) {\n      console.error('Doars: Error in \"' + directive + '\" expression: ', attribute.getValue())\n      return\n    }\n\n    // Setup update method.\n    const triggers = {}\n    const update = (id) => {\n      if (!triggers[id]) {\n        triggers[id] = ['$for']\n      }\n    }\n\n    const set = (\n      iterable,\n    ) => {\n      // Get stored data.\n      const data = attribute.getData()\n\n      // Get list of elements already made by this attribute.\n      const elements = data.elements ? data.elements : []\n\n      // Process iterable based on type.\n      const iterableType = typeof (iterable)\n      if (iterable !== null && iterable !== undefined) {\n        if (iterableType === 'number') {\n          for (let index = 0; index < iterable; index++) {\n            // Setup variables for context.\n            const variables = createVariables(expression.variables, index)\n\n            // Add element based on data after previously iterated value.\n            setAfter(component, update, template, elements, index - 1, iterable, variables, allowInlineScript || modifiers.script)\n          }\n\n          // Remove old values.\n          removeAfter(component, elements, iterable)\n        } else if (iterableType === 'string') {\n          for (let index = 0; index < iterable.length; index++) {\n            // Get value at index.\n            const value = iterable[index]\n\n            // Setup variables for context.\n            const variables = createVariables(expression.variables, value, index)\n\n            // Add element based on data after previously iterated value.\n            setAfter(component, update, template, elements, index - 1, value, variables, allowInlineScript || modifiers.script)\n          }\n\n          // Remove old values.\n          removeAfter(component, elements, iterable.length)\n        } else {\n          // We can't rely on Array.isArray since it might be a proxy, therefore we try to convert it to an array.\n          let isArray, length\n          try {\n            const values = [...iterable]\n            isArray = true\n            length = values.length\n          } catch { }\n\n          if (isArray) {\n            for (let index = 0; index < length; index++) {\n              // Get value at index.\n              const value = iterable[index]\n\n              // Setup variables for context.\n              const variables = createVariables(expression.variables, value, index)\n\n              // Add element based on data after previously iterated value.\n              setAfter(component, update, template, elements, index - 1, value, variables, allowInlineScript || modifiers.script)\n            }\n          } else {\n            const keys = Object.keys(iterable)\n            length = keys.length\n\n            for (let index = 0; index < length; index++) {\n              // Get value at index.\n              const key = keys[index]\n              const value = iterable[key]\n\n              // Setup variables for context.\n              const variables = createVariables(expression.variables, key, value, index)\n\n              // Add element based on data after previously iterated value.\n              setAfter(component, update, template, elements, index - 1, value, variables, allowInlineScript || modifiers.script)\n            }\n          }\n\n          // Remove old values.\n          removeAfter(component, elements, length)\n        }\n      }\n\n      // Dispatch triggers.\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        component.update(triggers)\n      }\n\n      // Store results.\n      attribute.setData(\n        Object.assign({}, data, {\n          elements,\n        }),\n      )\n    }\n\n    // Get iterable value.\n    let result\n    // Check if iterable is a number.\n    if (!isNaN(expression.iterable)) {\n      result = Number(expression.iterable)\n    } else {\n      // Get iterable data, and this will automatically mark the data as being accessed by this component.\n      result = processExpression(\n        component,\n        attribute,\n        expression.iterable,\n      )\n    }\n\n    // Get stored data.\n    const data = attribute.getData()\n\n    // Store results.\n    attribute.setData(\n      Object.assign({}, data, {\n        result,\n      }),\n    )\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData().result !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Get stored data.\n    const data = attribute.getData()\n\n    // Get list of elements created by this attribute.\n    if (data.elements) {\n      // Iterate over generated elements.\n      for (const element of data.elements) {\n        // Transition out.\n        transitionOut(\n          component.getLibrary().getOptions(),\n          element,\n          () => {\n            // Remove element.\n            element.remove()\n          },\n        )\n      }\n    }\n  },\n})\n", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n", "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame,\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement | string} newTree The tree to change to.\n * @param {object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the initial value. Changing the \"value\" attribute without changing the \"value\" property will have no effect since it is only used to the set the initial value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n * @param {string} name Name of the attribute.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop.\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing.\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old.\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new.\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild)\n      offset++\n\n      // Both nodes are the same, morph.\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder.\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree.\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list.\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID.\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node.\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n", "// Import utilities.\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { readdScripts } from '@doars/common/src/utilities/Script.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the html directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  allowInlineScript,\n  htmlDirectiveName,\n}) => ({\n  name: htmlDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const directive = attribute.getDirective()\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    const set = (\n      html,\n    ) => {\n      // Decode string.\n      if (modifiers.decode) {\n        html = decode(html)\n      }\n\n      // Clone and set html as only child for HTMLElements.\n      if (html instanceof HTMLElement) {\n        for (const child of element.children) {\n          child.remove()\n        }\n\n        element.append(\n          html.cloneNode(true),\n        )\n        return\n      }\n\n      // Set html via inner html for strings.\n      if (typeof (html) === 'string') {\n        if (modifiers.morph) {\n          if (modifiers.outer) {\n            // Morph the element as well.\n            morphTree(element, html)\n          } else {\n            // Ensure element only has one child.\n            if (element.children.length === 0) {\n              element.append(document.createElement('div'))\n            } else if (element.children.length > 1) {\n              for (let i = element.children.length - 1; i >= 1; i--) {\n                element.children[i].remove()\n              }\n            }\n\n            // Morph first child to given element tree.\n            const root = morphTree(element.children[0], html)\n            if (!element.children[0].isSameNode(root)) {\n              element.children[0].remove()\n              element.append(root)\n            }\n          }\n        } else if (modifiers.outer) {\n          if (element.outerHTML !== html) {\n            element.outerHTML = html\n            if (allowInlineScript || modifiers.script) {\n              readdScripts(element)\n            }\n          }\n        } else if (element.innerHTML !== html) {\n          element.innerHTML = html\n          if (allowInlineScript || modifiers.script) {\n            readdScripts(...element.children)\n          }\n        }\n        return\n      }\n\n      console.error('Doars: Unknown type returned to \"' + directive + '\" directive.')\n    }\n\n    // Execute value and retrieve result.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n})\n", "// Import utilities.\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { readdScripts } from '@doars/common/src/utilities/Script.js'\nimport {\n  transitionIn,\n  transitionOut,\n} from '@doars/common/src/utilities/Transition.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the if directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  allowInlineScript,\n  ifDirectiveName,\n}) => ({\n  name: ifDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct component and attribute.\n    const libraryOptions = component.getLibrary().getOptions()\n    const directive = attribute.getDirective()\n    const modifiers = attribute.getModifiers()\n    const template = attribute.getElement()\n\n    // Check if placed on a template tag.\n    if (template.tagName !== 'TEMPLATE') {\n      console.warn('Doars: \"' + directive + '\" must be placed on a `<template>`.')\n      return\n    }\n\n    // Check if it only has one child.\n    if (template.childCount > 1) {\n      console.warn('Doars: \"' + directive + '\" must have one child.')\n      return\n    }\n\n    const set = (\n      result,\n    ) => {\n      // Get stored data.\n      const data = attribute.getData()\n\n      // Get existing reference element.\n      let element = data.element\n      let transition = data.transition\n\n      if (!result) {\n        // If the element exists then transition out and remove the element.\n        if (element) {\n          // FIX: Will this not re-animate the element out, or break because the element does not exist since removing the transition. Perhaps track whether it is a transition in or transition out.\n\n          // Cancel previous transition.\n          if (transition) {\n            transition()\n          }\n\n          transition = transitionOut(libraryOptions, element, () => {\n            element.remove()\n          })\n        }\n      } else if (!element) {\n        // If the reference does not exist create the element.\n\n        // Cancel previous transition.\n        if (transition) {\n          transition()\n        }\n\n        // Create new element from template.\n        element = document.importNode(template.content, true)\n        // Add element after the template element.\n        template.insertAdjacentElement('afterend', element)\n        // Get HTMLElement reference instead of DocumentFragment.\n        element = template.nextElementSibling\n        if (allowInlineScript || modifiers.script) {\n          readdScripts(element)\n        }\n\n        // Transition element in.\n        transition = transitionIn(libraryOptions, element)\n      }\n\n      // Store results.\n      attribute.setData(\n        Object.assign({}, data, {\n          element,\n          transition,\n        }),\n      )\n    }\n\n    // Execute expression.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Get stored data.\n    const data = attribute.getData()\n\n    // Store results.\n    attribute.setData(\n      Object.assign({}, data, {\n        result,\n      }),\n    )\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          result,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData().result !== result) {\n            return\n          }\n\n          set(result)\n        })\n    } else {\n      set(result)\n    }\n  },\n\n  destroy: (\n    component,\n    attribute, {\n      transitionOut,\n    },\n  ) => {\n    // Get stored data.\n    const data = attribute.getData()\n\n    // If the element exists then transition out and remove the element.\n    if (data.element) {\n      transitionOut(\n        component.getLibrary().getOptions(),\n        data.element,\n        () => {\n          data.element.remove()\n        },\n      )\n    }\n  },\n})\n", "// Symbols.\nconst INITIALIZED = Symbol('INITIALIZED')\n\n/**\n * @typedef {import('../Attribute.js').default} Attribute\n * @typedef {import('../Component.js').default} Component\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Destroys the directive.\n * @param {Component} component The component the directive is part of.\n * @param {Attribute} attribute The attribute the directive is part of.\n * @returns {undefined}\n */\nconst destroy = (\n  component,\n  attribute,\n) => {\n  // Exit early if no listeners can be found.\n  if (!attribute[INITIALIZED]) {\n    return\n  }\n\n  // Deconstruct component.\n  const element = component.getElement()\n\n  // Create event name.\n  const name = component.getLibrary().getOptions().prefix + '-updated'\n\n  // Remove existing listener and delete directive data.\n  element.removeEventListener(name, attribute[INITIALIZED].handler)\n  delete attribute[INITIALIZED]\n}\n\n/**\n * Create the initialized directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  initializedDirectiveName,\n}) => ({\n  name: initializedDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct component.\n    const element = component.getElement()\n\n    // Deconstruct attribute.\n    const value = attribute.getValue()\n\n    // Create event name.\n    const name = component.getLibrary().getOptions().prefix + '-updated'\n\n    // Check if existing listener exists.\n    if (attribute[INITIALIZED]) {\n      // Exit early if listener has not changed.\n      if (attribute[INITIALIZED].value === value) {\n        return\n      }\n\n      // Remove existing listener so we don' listen twice.\n      element.removeEventListener(name, attribute[INITIALIZED].handler)\n      delete attribute[INITIALIZED]\n    }\n\n    const handler = ({ detail }) => {\n      // Only execute on self.\n      if (detail.element !== element) {\n        return\n      }\n\n      // Execute value using a copy of the attribute since this attribute does not need to update based on what it accesses.\n      processExpression(\n        component,\n        attribute.clone(),\n        value,\n        {},\n        { return: false },\n      )\n\n      // Call destroy.\n      destroy(component, attribute)\n    }\n\n    // Add listener to component.\n    element.addEventListener(name, handler, {\n      once: true,\n    })\n\n    // Store listener data on the component.\n    attribute[INITIALIZED] = {\n      handler,\n      value,\n    }\n  },\n\n  destroy,\n})\n", "/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n// Symbols.\nconst ON = Symbol('ON')\n\n// Declare constants.\nconst CANCEL_EVENTS = {\n  keydown: 'keyup',\n  mousedown: 'mouseup',\n  pointerdown: 'pointerup',\n}\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  HELD: 3,\n  HOLD: 4,\n  THROTTLE: 5,\n  DELAY: 6,\n}\nconst KEYPRESS_MODIFIERS = [\n  'alt',\n  'ctrl',\n  'meta',\n  'shift',\n]\n\n/**\n * Create the on directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  onDirectiveName,\n}) => ({\n  name: onDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const directive = attribute.getDirective()\n    let eventName = attribute.getKeyRaw()\n\n    // Check if required key is set.\n    if (!eventName) {\n      console.warn('Doars: \"' + directive + '\" directive must have a key.')\n      return\n    }\n\n    // Process keyboard events.\n    let key\n    if (eventName.startsWith('keydown-')) {\n      key = eventName.substring(8).toLowerCase()\n      eventName = 'keydown'\n    } else if (eventName.startsWith('keyup-')) {\n      key = eventName.substring(6).toLowerCase()\n      eventName = 'keyup'\n    }\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const value = attribute.getValue()\n\n    // Check if existing listener exists.\n    if (attribute[ON]) {\n      // Exit early if value has not changed.\n      if (attribute[ON].value === value) {\n        return\n      }\n\n      // Remove existing listener so we don't listen twice.\n      attribute[ON].target.removeEventListener(\n        attribute[ON].eventName,\n        attribute[ON].handler,\n      )\n\n      // Clear any ongoing timeouts.\n      if (attribute[ON].timeout) {\n        clearTimeout(attribute[ON].timeout)\n      }\n\n      // Delete directive data.\n      delete attribute[ON]\n    }\n\n    // Deconstruct attribute.\n    const modifiers = attribute.getModifiers()\n\n    // Process modifiers.\n\n    // Set listener options.\n    const listenerOptions = {}\n    if (modifiers.capture) {\n      listenerOptions.capture = true\n    }\n    if (modifiers.once) {\n      listenerOptions.once = true\n    }\n    if (modifiers.passive && !modifiers.prevent) {\n      listenerOptions.passive = true\n    }\n\n    // Process execution modifiers.\n    let executionModifier = EXECUTION_MODIFIERS.NONE\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500\n      }\n    } else if (modifiers.held) {\n      executionModifier = EXECUTION_MODIFIERS.HELD\n      if (modifiers.held === true) {\n        modifiers.held = 500\n      }\n    } else if (modifiers.hold) {\n      executionModifier = EXECUTION_MODIFIERS.HOLD\n      if (modifiers.hold === true) {\n        modifiers.hold = 500\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500\n      }\n    } else if (modifiers.delay) {\n      executionModifier = EXECUTION_MODIFIERS.DELAY\n      if (modifiers.delay === true) {\n        modifiers.delay = 500\n      }\n    }\n\n    // Store keypress modifiers.\n    const keypressModifiers = []\n    if (key) {\n      // Convert command and super to meta.\n      modifiers.meta = modifiers.meta ? true : modifiers.cmd || modifiers.super\n\n      for (const modifier of KEYPRESS_MODIFIERS) {\n        if (modifiers[modifier]) {\n          keypressModifiers.push(modifier)\n        }\n      }\n    }\n\n    // Set listener target and start listening.\n    let target = element\n    if (modifiers.document || modifiers.outside) {\n      target = document\n    } else if (modifiers.window) {\n      target = window\n    }\n\n    const handler = (\n      event,\n    ) => {\n      // Prevent repeat calls if prevent is set.\n      if (attribute[ON].prevent) {\n        return\n      }\n\n      // Disallow repeat calls if the modifier is not present.\n      if (!modifiers.repeat && event.repeat) {\n        return\n      }\n\n      // Only fire when self is provided if the target is the element itself.\n      if (modifiers.self && event.target !== element) {\n        return\n      }\n\n      // Don't fire with outside modifier unless the event came from outside.\n      if (modifiers.outside && element.contains(event.target)) {\n        return\n      }\n\n      // For keyboard events check the key is pressed.\n      if ((eventName === 'keydown' || eventName === 'keyup') && key) {\n        // Check if all key press modifiers are held.\n        for (const keypressModifier of keypressModifiers) {\n          if (!event[keypressModifier + 'Key']) {\n            return\n          }\n        }\n\n        // Convert key.\n        let eventKey = modifiers.code ? event.code : event.key\n        if (eventKey === ' ') {\n          eventKey = 'space'\n        }\n        eventKey = eventKey.toLowerCase()\n\n        // Check if the key matches.\n        if (eventKey !== key) {\n          return\n        }\n      }\n\n      // Prevent default if the prevent modifier is present.\n      if (modifiers.prevent) {\n        event.preventDefault()\n      }\n      // Stop propagation if the stop modifier is present.\n      if (modifiers.stop) {\n        event.stopPropagation()\n      }\n\n      const execute = (\n      ) => {\n        // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n        processExpression(\n          component,\n          attribute.clone(),\n          value,\n          {\n            $event: event,\n            $events: attribute[ON].buffer,\n          },\n          { return: false },\n        )\n\n        // Reset the buffer.\n        attribute[ON].buffer = []\n      }\n\n      // Store event in buffer.\n      attribute[ON].buffer.push(event)\n\n      // Check if we need to apply an execution modifier.\n      switch (executionModifier) {\n        case EXECUTION_MODIFIERS.BUFFER:\n          // Exit early if buffer is not full.\n          if (attribute[ON].buffer.length < modifiers.buffer) {\n            return\n          }\n\n          execute()\n          return\n\n        case EXECUTION_MODIFIERS.DEBOUNCE:\n          // Clear existing timeout.\n          if (attribute[ON].timeout) {\n            clearTimeout(attribute[ON].timeout)\n            attribute[ON].timeout = null\n          }\n\n          // Setup timeout and execute expression when it finishes.\n          attribute[ON].timeout = setTimeout(execute, modifiers.debounce)\n          return\n\n        // Execute the event when let go after the given time has exceeded.\n        case EXECUTION_MODIFIERS.HELD:\n          // Check if cancelable.\n          if (!(eventName in CANCEL_EVENTS)) {\n            console.warn('Doars: \"' + directive + '\" directive, event of name \"' + eventName + '\" is not cancelable and can not have \"held\" modifier.')\n            return\n          }\n          const cancelHeldName = CANCEL_EVENTS[eventName]\n\n          // Store time of holding down.\n          const nowHeld = window.performance.now()\n\n          attribute[ON].cancel = (cancelEvent) => {\n            // Check if minimum time has passed.\n            if (window.performance.now() - nowHeld < modifiers.held) {\n              attribute[ON].prevent = false\n              return\n            }\n\n            // For keyboard events check any required key has been depressed.\n            if (cancelHeldName === 'keyup' && key) {\n              // Check if all key press modifiers are held.\n              for (const keypressModifier of keypressModifiers) {\n                if (!cancelEvent[keypressModifier + 'Key']) {\n                  attribute[ON].prevent = false\n                  return\n                }\n              }\n\n              // Convert key.\n              let eventKey = modifiers.code ? cancelEvent.code : cancelEvent.key\n              if (eventKey === ' ') {\n                eventKey = 'space'\n              }\n              eventKey = eventKey.toLowerCase()\n\n              // Check if the key matches.\n              if (eventKey !== key) {\n                attribute[ON].prevent = false\n                return\n              }\n            }\n\n            // Only fire when self is provided if the target is the element itself.\n            if (modifiers.self && cancelEvent.target !== element) {\n              attribute[ON].prevent = false\n              return\n            }\n\n            // Don't fire with outside modifier unless the event came from outside.\n            if (modifiers.outside && element.contains(cancelEvent.target)) {\n              attribute[ON].prevent = false\n              return\n            }\n\n            // Execute expression.\n            execute()\n          }\n\n          // Prevent repeat calls.\n          attribute[ON].prevent = true\n\n          target.addEventListener(cancelHeldName, attribute[ON].cancel, { once: true })\n          return\n\n        // Execute event when keys have been held down for the given time.\n        case EXECUTION_MODIFIERS.HOLD:\n          // Check if cancelable.\n          if (!(eventName in CANCEL_EVENTS)) {\n            console.warn('Doars: \"' + directive + '\" directive, event of name \"' + eventName + '\" is not cancelable and can not have \"hold\" modifier.')\n            return\n          }\n          const cancelHoldName = CANCEL_EVENTS[eventName]\n\n          attribute[ON].cancel = (\n            cancelEvent,\n          ) => {\n            // For keyboard events check any required key has been depressed.\n            if (cancelHoldName === 'keyup' && key) {\n              let keyLetGo = false\n\n              // Check if all key press modifiers are held.\n              for (const keypressModifier of keypressModifiers) {\n                if (!cancelEvent[keypressModifier + 'Key']) {\n                  keyLetGo = true\n                }\n              }\n\n              // Convert key.\n              let eventKey = modifiers.code ? cancelEvent.code : cancelEvent.key\n              if (eventKey === ' ') {\n                eventKey = 'space'\n              }\n              eventKey = eventKey.toLowerCase()\n\n              // Check if the key matches.\n              if (eventKey === key) {\n                keyLetGo = true\n              }\n\n              if (!keyLetGo) {\n                attribute[ON].prevent = false\n                return\n              }\n            }\n\n            // Only fire when self is provided if the target is the element itself.\n            if (modifiers.self && cancelEvent.target !== element) {\n              attribute[ON].prevent = false\n              return\n            }\n\n            // Don't fire with outside modifier unless the event came from outside.\n            if (modifiers.outside && element.contains(cancelEvent.target)) {\n              attribute[ON].prevent = false\n              return\n            }\n\n            // Prevent timeout from firing.\n            clearTimeout(attribute[ON].timeout)\n          }\n          target.addEventListener(cancelHoldName, attribute[ON].cancel, { once: true })\n\n          // Prevent repeat calls.\n          attribute[ON].prevent = true\n\n          // Setup timeout and execute expression when it finishes.\n          attribute[ON].timeout = setTimeout(() => {\n            // Ensure cancel is removed.\n            target.removeEventListener(cancelHoldName, attribute[ON].cancel)\n\n            // Allow calls again.\n            attribute[ON].prevent = false\n\n            // Execute expression.\n            execute()\n          }, modifiers.hold)\n          return\n\n        case EXECUTION_MODIFIERS.THROTTLE:\n          // Get current time in milliseconds.\n          const nowThrottle = window.performance.now()\n\n          // Exit early if throttle time has not passed.\n          if (attribute[ON].lastExecution && nowThrottle - attribute[ON].lastExecution < modifiers.throttle) {\n            return\n          }\n\n          execute()\n\n          // Store new latest execution time.\n          attribute[ON].lastExecution = nowThrottle\n          return\n\n        case EXECUTION_MODIFIERS.DELAY:\n          // Prevent repeat calls.\n          attribute[ON].prevent = true\n\n          // Setup timeout and execute expression when it finishes.\n          attribute[ON].timeout = setTimeout(() => {\n            // Allow calls again.\n            attribute[ON].prevent = false\n\n            // Execute expression.\n            execute()\n          }, modifiers.delay)\n          return\n      }\n\n      // Otherwise execute expression immediately.\n      execute()\n    }\n\n    target.addEventListener(\n      eventName,\n      handler,\n      listenerOptions,\n    )\n\n    // Store listener data on the component.\n    attribute[ON] = {\n      buffer: [],\n      eventName,\n      handler,\n      target,\n      timeout: attribute[ON] ? attribute[ON].timeout : undefined,\n      value,\n      prevent: false,\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Exit early if no listeners can be found.\n    if (!attribute[ON]) {\n      return\n    }\n\n    // Remove existing listener.\n    attribute[ON].target\n      .removeEventListener(\n        attribute[ON].eventName,\n        attribute[ON].handler,\n      )\n\n    // Clear any ongoing callbacks and timeouts.\n    if (attribute[ON].cancel) {\n      attribute[ON].target\n        .removeEventListener(\n          CANCEL_EVENTS[attribute[ON].eventName],\n          attribute[ON].cancel,\n        )\n    }\n    if (attribute[ON].timeout) {\n      clearTimeout(attribute[ON].timeout)\n    }\n\n    // Delete directive data.\n    delete attribute[ON]\n  },\n})\n", "// Import symbols.\nimport {\n  REFERENCES,\n  REFERENCES_CACHE,\n} from '../symbols.js'\n\n/**\n * @typedef {import('../Attribute.js').default} Attribute\n * @typedef {import('../Component.js').default} Component\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Destroys the directive.\n * @param {Component} component The component the directive is part of.\n * @param {Attribute} attribute The attribute the directive is part of.\n * @returns {undefined}\n */\nconst destroy = (\n  component,\n  attribute,\n) => {\n  // Exit early if not set.\n  if (!component[REFERENCES]) {\n    return\n  }\n\n  // Deconstruct attribute.\n  const attributeId = attribute.getId()\n\n  // Exit early if not the same attribute.\n  if (!component[REFERENCES][attributeId]) {\n    return\n  }\n\n  // Deconstruct component.\n  const library = component.getLibrary()\n  const componentId = component.getId()\n\n  // Deconstruct attribute.\n  const name = component[REFERENCES][attributeId].name\n\n  // Remove reference from object.\n  delete component[REFERENCES][attributeId]\n\n  // Remove context cache.\n  delete component[REFERENCES_CACHE]\n\n  // Remove object if it is empty now.\n  if (Object.keys(component[REFERENCES]).length === 0) {\n    delete component[REFERENCES]\n  }\n\n  // Trigger references update.\n  library.update([{\n    id: componentId,\n    path: '$references.' + name,\n  }])\n}\n\n/**\n * Create the reference directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  referenceDirectiveName,\n}) => ({\n  name: referenceDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct component.\n    const library = component.getLibrary()\n    const componentId = component.getId()\n\n    // Deconstruct attribute.\n    const directive = attribute.getDirective()\n    const element = attribute.getElement()\n    const attributeId = attribute.getId()\n\n    const {\n      referenceDirectiveEvaluate,\n    } = library.getOptions()\n\n    // Process attribute name.\n    let name = attribute.getValue()\n    name = referenceDirectiveEvaluate\n      ? processExpression(\n        component,\n        attribute,\n        name,\n      )\n      : name.trim()\n\n    // Check if value is a valid variable name.\n    if (\n      !name ||\n      typeof (name) !== 'string' ||\n      !/^[_$a-z]{1}[_\\-$a-z0-9]{0,}$/i.test(name)\n    ) {\n      destroy(component, attribute)\n      console.warn('Doars: \"' + directive + '\" directive\\'s value not a valid variable name: \"' + name.toString() + '\".')\n      return\n    }\n\n    // Check if references object exists.\n    if (!component[REFERENCES]) {\n      component[REFERENCES] = {}\n    }\n\n    // Store reference.\n    component[REFERENCES][attributeId] = {\n      element,\n      name,\n    }\n\n    // Remove context cache.\n    delete component[REFERENCES_CACHE]\n\n    // Trigger references update.\n    library.update([{\n      id: componentId,\n      path: '$references.' + name,\n    }])\n  },\n\n  destroy,\n})\n", "// Import utilities.\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\nconst TAG_SELECT = 'SELECT'\nconst CHECKED = 'checked'\nconst SELECTED = 'selected'\nconst TYPE_CHECKBOX = 'checkbox'\n\n/**\n * Create the select directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  selectDirectiveName,\n}) => ({\n  name: selectDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const directive = attribute.getDirective()\n\n    // Check if placed on a select tag.\n    const type = element.getAttribute('type')\n    if (element.tagName !== TAG_SELECT && !(element.tagName === 'INPUT' && (type === TYPE_CHECKBOX || type === 'radio'))) {\n      console.warn('Doars: \"' + directive + '\" directive must be placed on a `select` tag or `input` of type checkbox or radio.')\n      return\n    }\n\n    const set = (\n      data,\n    ) => {\n      // Iterate over the select options.\n      if (element.tagName === TAG_SELECT) {\n        for (const option of Array.from(element.options)) {\n          // Update option if the selected value has changed.\n          const select = Array.isArray(data) ? data.includes(option.value) : data === option.value\n          if (option.selected !== select) {\n            // Update option's status.\n            option.selected = select\n\n            // Update option's attribute.\n            if (select) {\n              option.setAttribute(SELECTED, '')\n            } else {\n              option.removeAttribute(SELECTED)\n            }\n          }\n        }\n      } else if (type === TYPE_CHECKBOX) {\n        // Update option if the checked value has changed.\n        const checked = data.includes(element.value)\n        if (element.checked !== checked) {\n          // Update checked attribute.\n          if (checked) {\n            element.setAttribute(CHECKED, '')\n          } else {\n            element.removeAttribute(CHECKED)\n          }\n        }\n      } else {\n        // Update option if the checked value has changed.\n        const checked = data === element.value\n        if (element.checked !== checked) {\n          // Update checked attribute.\n          if (checked) {\n            element.setAttribute(CHECKED, '')\n          } else {\n            element.removeAttribute(CHECKED)\n          }\n        }\n      }\n    }\n\n    // Execute attribute value.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n})\n", "// Import utilities.\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport {\n  transitionIn,\n  transitionOut,\n} from '@doars/common/src/utilities/Transition.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the show directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  showDirectiveName,\n}) => ({\n  name: showDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct component and attribute.\n    const libraryOptions = component.getLibrary().getOptions()\n    const element = attribute.getElement()\n\n    const set = (\n    ) => {\n      // Get stored data.\n      const data = attribute.getData()\n\n      // Cancel previous transition.\n      if (data.transition) {\n        data.transition()\n      }\n\n      // Assign display based on truthiness of expression result.\n      let transition\n      if (data.result) {\n        element.style.display = null\n        transition = transitionIn(libraryOptions, element)\n      } else {\n        transition = transitionOut(libraryOptions, element, () => {\n          element.style.display = 'none'\n        })\n      }\n\n      // Store new transition.\n      attribute.setData(\n        Object.assign({}, data, {\n          transition,\n        }),\n      )\n    }\n\n    // Execute attribute value.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Get stored data.\n    const data = attribute.getData()\n\n    // Handle promises.\n    if (isPromise(result)) {\n      // Store results.\n      attribute.setData(\n        Object.assign({}, data, {\n          result,\n        }),\n      )\n\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData().result !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else if (!data || data.result !== result) {\n      // Store results.\n      attribute.setData(\n        Object.assign({}, data, {\n          result,\n        }),\n      )\n\n      set()\n    }\n  },\n})\n", "import { createAutoContexts } from '../utilities/Context.js'\nimport {\n  getDeeply,\n  setDeeply,\n} from '@doars/common/src/utilities/Object.js'\nimport { escapeHtml } from '@doars/common/src/utilities/String.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n// Symbols.\nconst SYNC = Symbol('SYNC')\n\n/**\n * Create the sync directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  syncDirectiveName,\n}) => ({\n  name: syncDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const directive = attribute.getDirective()\n\n    // Store whether this call is an update.\n    const isNew = !attribute[SYNC]\n\n    if (isNew) {\n      // Check if placed on a valid tag.\n      if (\n        !(element.tagName === 'DIV' && element.hasAttribute('contenteditable')) &&\n        element.tagName !== 'INPUT' &&\n        element.tagName !== 'SELECT' &&\n        element.tagName !== 'TEXTAREA'\n      ) {\n        console.warn('Doars: \"' + directive + '\" directive must be placed on an `<input>`, `<select>`, `<textarea>` tag, or a content editable `div`.')\n        return\n      }\n    }\n\n    // Deconstruct attribute.\n    let value = attribute.getValue().trim()\n    const key = attribute.getKey()\n    if (key) {\n      value = '$' + key + '.' + value\n    }\n\n    // Check if value is a valid variable name.\n    if (!/^[_$a-z]{1}[._$a-z0-9]{0,}$/i.test(value)) {\n      console.warn('Doars: \"' + directive + '\" directive\\'s value not a valid variable name \"' + value + '\".')\n      return\n    }\n    const valueSplit = value.split('.')\n\n    if (isNew) {\n      // Set handler that updates data based of node tag.\n      let handler\n      switch (element.tagName) {\n        case 'DIV':\n          handler = (\n          ) => {\n            // Update value.\n            const [contexts, destroyContexts] = createAutoContexts(\n              component,\n              attribute.clone(),\n            )\n            setDeeply(\n              contexts,\n              valueSplit,\n              escapeHtml(element.innerText),\n            )\n            destroyContexts()\n          }\n          break\n\n        case 'INPUT':\n          handler = (\n          ) => {\n            const elementValue = escapeHtml(element.value)\n            // Setup contexts.\n            const [contexts, destroyContexts] = createAutoContexts(\n              component,\n              attribute.clone(),\n            )\n\n            if (element.type === 'checkbox') {\n              // Get current value.\n              const dataValue = getDeeply(contexts, valueSplit)\n\n              // Update value.\n              if (element.checked) {\n                if (!dataValue) {\n                  setDeeply(contexts, valueSplit, [elementValue])\n                } if (!dataValue.includes(element.value)) {\n                  dataValue.push(elementValue)\n                }\n              } else if (dataValue) {\n                const index = dataValue.indexOf(element.value)\n                if (index >= 0) {\n                  dataValue.splice(index, 1)\n                }\n              }\n            } else if (element.type === 'radio') {\n              // Get current value.\n              const dataValue = getDeeply(contexts, valueSplit)\n\n              if (element.checked) {\n                if (dataValue !== element.value) {\n                  setDeeply(contexts, valueSplit, elementValue)\n                }\n              } else if (dataValue === element.value) {\n                setDeeply(contexts, valueSplit, null)\n              }\n            } else {\n              setDeeply(contexts, valueSplit, elementValue)\n            }\n\n            // Cleanup contexts.\n            destroyContexts()\n          }\n          break\n\n        case 'TEXTAREA':\n          handler = (\n          ) => {\n            // Update value.\n            const [contexts, destroyContexts] = createAutoContexts(\n              component,\n              attribute.clone(),\n            )\n            setDeeply(\n              contexts,\n              valueSplit,\n              escapeHtml(element.innerText),\n            )\n            destroyContexts()\n          }\n          break\n\n        case 'SELECT':\n          handler = (\n          ) => {\n            // Create contexts.\n            const [contexts, destroyContexts] = createAutoContexts(\n              component,\n              attribute.clone(),\n            )\n\n            if (element.multiple) {\n              // Combine options.\n              const elementValues = []\n              for (const option of element.selectedOptions) {\n                elementValues.push(\n                  escapeHtml(option.value),\n                )\n              }\n              // Update value.\n              setDeeply(contexts, valueSplit, [elementValues.join('\\',\\'')])\n            } else {\n              // Update value.\n              setDeeply(contexts, valueSplit, escapeHtml(element.selectedOptions[0].value))\n            }\n\n            // Cleanup contexts.\n            destroyContexts()\n          }\n          break\n      }\n\n      // Add event listener.\n      element.addEventListener('input', handler)\n\n      // Store handler wrapper.\n      attribute[SYNC] = handler\n    }\n\n    const dataValue = processExpression(\n      component,\n      attribute.clone(),\n      value,\n    )\n    switch (element.tagName) {\n      case 'DIV':\n      case 'TEXTAREA':\n        // Check if current value is different than attribute value.\n        if (dataValue !== element.innerText) {\n          // Update current value.\n          element.innerText = dataValue\n        }\n        break\n\n      case 'INPUT':\n        if (element.type === 'checkbox') {\n          // Update option if the checked value has changed.\n          const checked = dataValue.includes(element.value)\n          if (element.checked !== checked) {\n            // Update checked value.\n            element.checked = checked\n\n            // Update checked attribute.\n            if (checked) {\n              element.setAttribute('checked', '')\n            } else {\n              element.removeAttribute('checked')\n            }\n          }\n        } else if (element.type === 'radio') {\n          // Update option if the checked value has changed.\n          const checked = dataValue === element.value\n          if (element.checked !== checked) {\n            // Update checked value.\n            element.checked = checked\n\n            // Update checked attribute.\n            if (checked) {\n              element.setAttribute('checked', '')\n            } else {\n              element.removeAttribute('checked')\n            }\n          }\n        } else {\n          // Check if current value is different than attribute value.\n          if (dataValue !== element.value) {\n            // Update current value.\n            element.setAttribute('value', dataValue)\n          }\n        }\n        break\n\n      case 'SELECT':\n        // Iterate over the select options.\n        for (const option of Array.from(element.options)) {\n          // Update option if the selected value has changed.\n          const select = Array.isArray(dataValue) ? dataValue.includes(option.value) : dataValue === option.value\n          if (option.selected !== select) {\n            // Update option status.\n            option.selected = select\n\n            // Update option attribute.\n            if (select) {\n              option.setAttribute('selected', '')\n            } else {\n              option.removeAttribute('selected')\n            }\n          }\n        }\n        break\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Exit early if nothing to destroy.\n    if (!attribute[SYNC]) {\n      return\n    }\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Remove existing event listeners.\n    element.removeEventListener('input', attribute[SYNC])\n\n    // Remove data from attribute.\n    delete attribute[SYNC]\n  },\n})\n", "import { isPromise } from '@doars/common/src/utilities/Promise.js'\n\n/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the text directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  textDirectiveName,\n}) => ({\n  name: textDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    const set = (text) => {\n      // Assign text.\n      if (modifiers.content) {\n        if (element.textContent !== text) {\n          element.textContent = text\n        }\n      } else if (element.innerText !== text) {\n        element.innerText = text\n      }\n    }\n\n    // Execute value and retrieve result.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n})\n", "/**\n * @typedef {import('../Directive.js').Directive} Directive\n * @typedef {import('../Doars.js').DoarsOptions} DoarsOptions\n */\n\n/**\n * Create the watch directive.\n * @param {DoarsOptions} options Library options.\n * @returns {Directive} The directive.\n */\nexport default ({\n  watchDirectiveName,\n}) => ({\n  name: watchDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) =>\n    // Execute attribute expression.\n    processExpression(\n      component,\n      attribute.clone(),\n      attribute.getValue(),\n      {},\n      { return: false },\n    ),\n})\n", "// Import symbols.\nimport { ATTRIBUTES, COMPONENT } from './symbols.js'\n\n// Import classes.\nimport Component from './Component.js'\n\n// Import contexts.\nimport createChildrenContext from './contexts/children.js'\nimport createComponentContext from './contexts/component.js'\nimport createElementContext from './contexts/element.js'\nimport createDispatchContext from './contexts/dispatch.js'\nimport createForContext from './contexts/for.js'\nimport createInContextContext from './contexts/inContext.js'\nimport createNextSiblingContext from './contexts/nextSibling.js'\nimport createNextTickContext from './contexts/nextTick.js'\nimport createParentContext from './contexts/parent.js'\nimport createPreviousSiblingContext from './contexts/previousSibling.js'\nimport createReferencesContext from './contexts/references.js'\nimport createSiblingsContext from './contexts/siblings.js'\nimport createStateContext from './contexts/state.js'\nimport createStoreContext from './contexts/store.js'\nimport createWatchContext from './contexts/watch.js'\n\n// Import directives.\nimport createAttributeDirective from './directives/attribute.js'\nimport createCloakDirective from './directives/cloak.js'\nimport createForDirective from './directives/for.js'\nimport createHtmlDirective from './directives/html.js'\nimport createIfDirective from './directives/if.js'\nimport createInitializedDirective from './directives/initialized.js'\nimport createOnDirective from './directives/on.js'\nimport createReferenceDirective from './directives/reference.js'\nimport createSelectDirective from './directives/select.js'\nimport createShowDirective from './directives/show.js'\nimport createSyncDirective from './directives/sync.js'\nimport createTextDirective from './directives/text.js'\nimport createWatchDirective from './directives/watch.js'\n\n// Import event dispatcher.\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'\n\n// Import utilities.\nimport { closestComponent } from './utilities/Component.js'\nimport { walk } from '@doars/common/src/utilities/Element.js'\n\n/**\n * @typedef {import('./Attribute.js').default} Attribute\n * @typedef {import('./Context.js').Context} Context\n * @typedef {import('./Directive.js').Directive} Directive\n */\n\n/**\n * @callback ExpressionProcessor Executes value in the correct context.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {string} expression Expression to execute.\n * @param {object|null} extra Optional extra context items.\n * @param {object|null} options Optional options object.\n * @returns {any} Result of expression.\n */\n\n/**\n * @typedef {{[key:string]:Directive}} ContextMap Object that maps names of contexts to the context.\n */\n/**\n * @typedef {{[key:string]:Directive}} DirectiveMap Object that maps names of directives to the directive.\n */\n\n/**\n * @typedef Trigger\n * @type {object}\n * @property {string|symbol} id The identifier of the changed resource.\n * @property {string} path The path leading to the changed value on the resource.\n */\n\n/**\n * @typedef _DoarsOptions\n * @type {object}\n * @property {?string} prefix The prefix of the directive's attribute names.\n * @property {?string} processor The expression processor to use.\n * @property {?HTMLElement|string} root The element or selector of an element to scan and keep track of.\n * @property {?boolean} allowInlineScript When setting the innerHTML or outerHTML inline scripts are not automatically ran. Enabling this wil ensure the inline scripts are executed.\n * @property {?boolean} forContextDeconstruct Whether to require the `$for` prefix when trying to accessing data from the for context.\n * @property {?boolean} stateContextDeconstruct Whether to require the `$state` prefix when trying to accessing data from the state context.\n * @property {?boolean} storeContextDeconstruct Whether to require the `$store` prefix when trying to accessing data from the store context.\n * @property {?object} storeContextInitial The initial data of the data store context.\n * @property {?boolean} indicatorDirectiveEvaluate If set to false the indicator directive's value is read as a string literal instead of an expression to process.\n * @property {?boolean} referenceDirectiveEvaluate If set to false the reference directive's value is read as a string literal instead of an expression to process.\n * @property {?boolean} selectFromElementDirectiveEvaluate If set to false the select from element directive's value is read as a string literal instead of an expression to process.\n * @property {?boolean} targetDirectiveEvaluate If set to false the target directive's value is read as a string literal instead of an expression to process.\n * @property {?string} childrenContextName The name of the children context.\n * @property {?string} componentContextName The name of the component context.\n * @property {?string} dispatchContextName The name of the dispatch context.\n * @property {?string} elementContextName The name of the element context.\n * @property {?string} forContextName The name of the for context.\n * @property {?string} inContextContextName The name of the inContext context.\n * @property {?string} nextSiblingContextName The name of the next sibling context.\n * @property {?string} nextTickContextName The name of the nextTick context.\n * @property {?string} parentContextName The name of the parent context.\n * @property {?string} previousSiblingContextName The name of the previous sibling context.\n * @property {?string} referencesContextName The name of the references context.\n * @property {?string} siblingsContextName The name of the siblings context.\n * @property {?string} stateContextName The name of the state context.\n * @property {?string} storeContextName The name of the store context.\n * @property {?string} watchContextName The name of the watch context.\n * @property {?string} attributeDirectiveName The name of the attribute directive.\n * @property {?string} cloakDirectiveName The name of the cloak directive.\n * @property {?string} forDirectiveName The name of the for directive.\n * @property {?string} htmlDirectiveName The name of the html directive.\n * @property {?string} ifDirectiveName The name of the if directive.\n * @property {?string} ignoreDirectiveName The name of the ignore directive.\n * @property {?string} indicatorDirectiveName The name of the indicator directive.\n * @property {?string} initializedDirectiveName The name of the initialized directive.\n * @property {?string} onDirectiveName The name of the on directive.\n * @property {?string} referenceDirectiveName The name of the reference directive.\n * @property {?string} selectDirectiveName The name of the select directive.\n * @property {?string} selectFromElementDirectiveName The name of the select from element directive.\n * @property {?string} showDirectiveName The name of the show directive.\n * @property {?string} stateDirectiveName The name of the state directive.\n * @property {?string} syncDirectiveName The name of the sync directive.\n * @property {?string} targetDirectiveName The name of the target directive.\n * @property {?string} textDirectiveName The name of the text directive.\n * @property {?string} transitionDirectiveName The name of the transition directive.\n * @property {?string} watchDirectiveName The name of the watch directive.\n * @property {?string} redirectHeaderName The name of the redirect header.\n * @property {?string} requestHeaderName The name of the request header.\n * @property {?string} titleHeaderName The name of the title header.\n */\n\n/**\n * @typedef DoarsOptions\n * @type {object}\n * @property {string} prefix The prefix of the directive's attribute names.\n * @property {string} processor The expression processor to use.\n * @property {HTMLElement|string} root The element or selector of an element to scan and keep track of.\n * @property {boolean} allowInlineScript When setting the innerHTML or outerHTML inline scripts are not automatically ran. Enabling this wil ensure the inline scripts are executed.\n * @property {boolean} forContextDeconstruct Whether to require the `$for` prefix when trying to accessing data from the for context.\n * @property {boolean} stateContextDeconstruct Whether to require the `$state` prefix when trying to accessing data from the state context.\n * @property {boolean} storeContextDeconstruct Whether to require the `$store` prefix when trying to accessing data from the store context.\n * @property {object} storeContextInitial The initial data of the data store context.\n * @property {boolean} indicatorDirectiveEvaluate If set to false the indicator directive's value is read as a string literal instead of an expression to process.\n * @property {boolean} referenceDirectiveEvaluate If set to false the reference directive's value is read as a string literal instead of an expression to process.\n * @property {boolean} selectFromElementDirectiveEvaluate If set to false the select from element directive's value is read as a string literal instead of an expression to process.\n * @property {boolean} targetDirectiveEvaluate If set to false the target directive's value is read as a string literal instead of an expression to process.\n * @property {string} childrenContextName The name of the children context.\n * @property {string} componentContextName The name of the component context.\n * @property {string} dispatchContextName The name of the dispatch context.\n * @property {string} elementContextName The name of the element context.\n * @property {string} forContextName The name of the for context.\n * @property {string} inContextContextName The name of the inContext context.\n * @property {string} nextSiblingContextName The name of the next sibling context.\n * @property {string} nextTickContextName The name of the nextTick context.\n * @property {string} parentContextName The name of the parent context.\n * @property {string} previousSiblingContextName The name of the previous sibling context.\n * @property {string} referencesContextName The name of the references context.\n * @property {string} siblingsContextName The name of the siblings context.\n * @property {string} stateContextName The name of the state context.\n * @property {string} storeContextName The name of the store context.\n * @property {string} watchContextName The name of the watch context.\n * @property {string} attributeDirectiveName The name of the attribute directive.\n * @property {string} cloakDirectiveName The name of the cloak directive.\n * @property {string} forDirectiveName The name of the for directive.\n * @property {string} htmlDirectiveName The name of the html directive.\n * @property {string} ifDirectiveName The name of the if directive.\n * @property {string} ignoreDirectiveName The name of the ignore directive.\n * @property {string} indicatorDirectiveName The name of the indicator directive.\n * @property {string} initializedDirectiveName The name of the initialized directive.\n * @property {string} onDirectiveName The name of the on directive.\n * @property {string} referenceDirectiveName The name of the reference directive.\n * @property {string} selectDirectiveName The name of the select directive.\n * @property {string} selectFromElementDirectiveName The name of the select from element directive.\n * @property {string} showDirectiveName The name of the show directive.\n * @property {string} stateDirectiveName The name of the state directive.\n * @property {string} syncDirectiveName The name of the sync directive.\n * @property {string} targetDirectiveName The name of the target directive.\n * @property {string} textDirectiveName The name of the text directive.\n * @property {string} transitionDirectiveName The name of the transition directive.\n * @property {string} watchDirectiveName The name of the watch directive.\n * @property {string} redirectHeaderName The name of the redirect header.\n * @property {string} requestHeaderName The name of the request header.\n * @property {string} titleHeaderName The name of the title header.\n */\n\nexport default class Doars extends EventDispatcher {\n  /**\n   * Create instance.\n   * @param {_DoarsOptions} options Options.\n   */\n  constructor(\n    options,\n  ) {\n    super()\n\n    // Deconstruct options.\n    let {\n      prefix,\n      processor,\n      root,\n    } = options = Object.freeze(Object.assign({\n      prefix: 'd',\n      processor: 'execute',\n      root: document.body,\n\n      allowInlineScript: false,\n      forContextDeconstruct: true,\n      stateContextDeconstruct: true,\n      storeContextDeconstruct: false,\n      storeContextInitial: {},\n      indicatorDirectiveEvaluate: true,\n      referenceDirectiveEvaluate: true,\n      selectFromElementDirectiveEvaluate: true,\n      targetDirectiveEvaluate: true,\n\n      // Context names must pass regex: /^[_$a-z]{1}[_$a-z0-9]{0,}$/i.test(name)\n      childrenContextName: '$children',\n      componentContextName: '$component',\n      dispatchContextName: '$dispatch',\n      elementContextName: '$element',\n      forContextName: '$for',\n      inContextContextName: '$inContext',\n      nextSiblingContextName: '$nextSibling',\n      nextTickContextName: '$nextTick',\n      parentContextName: '$parent',\n      previousSiblingContextName: '$previousSibling',\n      referencesContextName: '$references',\n      siblingsContextName: '$siblings',\n      stateContextName: '$state',\n      storeContextName: '$store',\n      watchContextName: '$watch',\n\n      // Directive names must pass regex: /^[_\\-$a-z]{1}[_\\-$a-z0-9]{0,}$/i.test(name)\n      attributeDirectiveName: 'attribute',\n      cloakDirectiveName: 'cloak',\n      forDirectiveName: 'for',\n      htmlDirectiveName: 'html',\n      ifDirectiveName: 'if',\n      ignoreDirectiveName: 'ignore',\n      indicatorDirectiveName: 'indicator',\n      initializedDirectiveName: 'initialized',\n      onDirectiveName: 'on',\n      referenceDirectiveName: 'reference',\n      selectDirectiveName: 'select',\n      selectFromElementDirectiveName: 'select',\n      showDirectiveName: 'show',\n      stateDirectiveName: 'state',\n      syncDirectiveName: 'sync',\n      targetDirectiveName: 'target',\n      textDirectiveName: 'text',\n      transitionDirectiveName: 'transition',\n      watchDirectiveName: 'watch',\n\n      // Header names must pass regex: /^[_\\-$a-z]{1}[_\\-$a-z0-9]{0,}$/i.test(name)\n      redirectHeaderName: 'redirect',\n      requestHeaderName: 'request',\n      titleHeaderName: 'title',\n    }, options))\n    // If root is a string assume it is a selector.\n    if (typeof (root) === 'string') {\n      root = options.root = document.querySelector(root)\n    }\n    // Validate options.\n    if (!prefix) {\n      console.error('Doars: `prefix` option not set.')\n      return\n    }\n    if (typeof (prefix) !== 'string') {\n      console.error('Doars: `prefix` option must be of type string.')\n      return\n    }\n    if (!root) {\n      console.error('Doars: `root` option not set.')\n      return\n    }\n    if (typeof (root) !== 'object') {\n      console.error('Doars: `root` option must be a string or HTMLElement.')\n      return\n    }\n\n    // Create unique identifier.\n    const id = Symbol('ID_DOARS')\n\n    // Create private variables.\n    let isEnabled = false,\n      isUpdating = false,\n      mutations,\n      observer,\n      triggers\n\n    /** @type {Array<Component>} */\n    const components = []\n    const\n      contextsBase = {},\n      contexts = [\n        createChildrenContext(options),\n        createComponentContext(options),\n        createElementContext(options),\n        createDispatchContext(options),\n        createInContextContext(options),\n        createNextSiblingContext(options),\n        createNextTickContext(options),\n        createParentContext(options),\n        createPreviousSiblingContext(options),\n        createReferencesContext(options),\n        createSiblingsContext(options),\n        createWatchContext(options),\n\n        // Order of `store`, `state` and `for` context is important for deconstruction.\n        createStoreContext(options),\n        createStateContext(options),\n        createForContext(options),\n      ]\n    const directives = [\n      // Must happen first as other directives can rely on it.\n      createReferenceDirective(options),\n\n      // Then execute those that modify the document tree, since it could make other directives redundant and save on processing.\n      createAttributeDirective(options),\n      createForDirective(options),\n      createHtmlDirective(options),\n      createIfDirective(options),\n      createTextDirective(options),\n\n      // Order does not matter any more.\n      createCloakDirective(options),\n      createInitializedDirective(options),\n      createOnDirective(options),\n      createSelectDirective(options),\n      createShowDirective(options),\n      createSyncDirective(options),\n      createWatchDirective(options),\n    ]\n    let directivesNames,\n      directivesObject,\n      directivesRegexp\n\n    // Get the expression processor.\n    const processorType = typeof (processor)\n    let processExpression\n    if (processorType === 'function') {\n      processExpression = processor\n    } else if (processorType === 'string' && this.constructor[processor + 'Expression']) {\n      processExpression = this.constructor[processor + 'Expression']\n    } else {\n      console.warn('Doars: Expression processor not found. Using fallback instead.')\n      processExpression = this.constructor.executeExpression ?? this.constructor.interpretExpression ?? this.constructor.callExpression\n    }\n    if (!processExpression) {\n      console.error('Doars: No expression processor available. Process option: ', process)\n    }\n\n    /**\n     * Get the unique identifier.\n     * @returns {symbol} Unique identifier.\n     */\n    this.getId = (\n    ) => {\n      return id\n    }\n\n    /**\n     * Get the current options.\n     * @returns {DoarsOptions} Current options.\n     */\n    this.getOptions = (\n    ) => {\n      return Object.assign({}, options)\n    }\n\n    /* State */\n\n    /**\n     * Whether this is currently enabled.\n     * @returns {boolean} Whether the library is enabled.\n     */\n    this.getEnabled = (\n    ) => {\n      return isEnabled\n    }\n\n    /**\n     * Enable the library.\n     * @returns {Doars} This instance.\n     */\n    this.enable = (\n    ) => {\n      if (isEnabled) {\n        return this\n      }\n\n      // Setup values.\n      isUpdating = false\n      mutations = []\n      triggers = {}\n\n      // Dispatch event.\n      this.dispatchEvent('enabling', [this])\n\n      // Mark as enabled.\n      isEnabled = true\n\n      // Create list of directive names.\n      directivesNames = directives.map((directive) => directive.name)\n\n      // Create directives object.\n      directivesObject = {}\n      for (const directive of directives) {\n        directivesObject[directive.name] = directive\n      }\n\n      // Dynamically create expression for matching any attribute names to known directive keys.\n      directivesRegexp = new RegExp('^' + prefix + '-(' + directivesNames.join('|') + ')(?:[$-_.a-z0-9]{0,})?$', 'i') // eslint-disable-line prefer-regex-literals\n\n      // Create mutation observer.\n      observer = new MutationObserver((handleMutation).bind(this))\n      observer.observe(root, {\n        attributes: true,\n        childList: true,\n        subtree: true,\n      })\n\n      const {\n        stateDirectiveName,\n        ignoreDirectiveName,\n      } = this.getOptions()\n\n      // Scan for components.\n      const componentName = prefix + '-' + stateDirectiveName\n      const ignoreName = prefix + '-' + ignoreDirectiveName\n      const componentElements = [...root.querySelectorAll('[' + componentName + ']')]\n      // Remove any elements that should be ignored.\n      for (let i = componentElements.length - 1; i >= 0; i--) {\n        if (componentElements[i].closest('[' + ignoreName + ']')) {\n          componentElements.splice(i, 1)\n        }\n      }\n      addComponents((root.hasAttribute(componentName) && !root.hasAttribute(ignoreName)) ? root : null, ...componentElements)\n\n      // Dispatch events.\n      this.dispatchEvent('enabled', [this])\n      this.dispatchEvent('updated', [this])\n\n      return this\n    }\n\n    /**\n     * Disable the library.\n     * @returns {Doars} This instance.\n     */\n    this.disable = (\n    ) => {\n      if (!isEnabled) {\n        return this\n      }\n\n      // Disable mutation observer.\n      observer.disconnect()\n      observer = null\n\n      // Reset values.\n      isUpdating = mutations = triggers = null\n\n      // Dispatch event.\n      this.dispatchEvent('disabling', [this], { reverse: true })\n\n      // Remove components.\n      removeComponents(...components)\n\n      // Reset directives helper.\n      directivesNames = directivesObject = directivesRegexp = null\n\n      // Mark as disabled.\n      isEnabled = false\n\n      // Dispatch event.\n      this.dispatchEvent('disabled', [this], { reverse: true })\n\n      return this\n    }\n\n    /* Components */\n\n    /**\n     * Add components to instance.\n     * @param  {...HTMLElement} elements Elements to add as components.\n     * @returns {Array<Component>} List of added components.\n     */\n    const addComponents = (\n      ...elements\n    ) => {\n      const results = []\n      const resultElements = []\n      for (const element of elements) {\n        if (!element) {\n          continue\n        }\n\n        // Skip if already a component.\n        if (element[COMPONENT]) {\n          continue\n        }\n\n        // Create component.\n        const component = new Component(this, element)\n        // Add to list.\n        components.push(component)\n\n        // Add to results.\n        results.push(component)\n        resultElements.push(element)\n      }\n\n      if (resultElements.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('components-added', [this, resultElements])\n      }\n\n      // Initialize new components.\n      for (const component of results) {\n        component.initialize()\n      }\n\n      // Update all attributes on new components.\n      for (const component of results) {\n        component.updateAttributes(component.getAttributes())\n      }\n\n      return results\n    }\n\n    /**\n     * Remove components from instance.\n     * @param  {...Component} _components Components to remove.\n     * @returns {Array<HTMLElement>} List of elements of removed components.\n     */\n    const removeComponents = (\n      ..._components\n    ) => {\n      const results = []\n      for (const component of _components) {\n        // Skip if not in list.\n        const index = components.indexOf(component)\n        if (index < 0) {\n          continue\n        }\n\n        // Add to results.\n        results.push(component.getElement())\n\n        // Destroy component.\n        component.destroy()\n        // Remove from list.\n        components.splice(index, 1)\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('components-removed', [this, results])\n      }\n\n      return results\n    }\n\n    /* Simple contexts */\n\n    /**\n     * Get simple contexts.\n     * @returns {ContextMap} Stored simple contexts.\n     */\n    this.getSimpleContexts = (\n    ) => Object.assign({}, contextsBase)\n\n    /**\n     * Add a value directly to the contexts without needing to use an object or having to deal with indices.\n     * @param {string} name Property name under which to add the context.\n     * @param {Context} value The value to add, null removes the context.\n     * @returns {boolean} Whether the value was successfully set.\n     */\n    this.setSimpleContext = (\n      name,\n      value = null,\n    ) => {\n      // Delete context if value is null.\n      if (value === null) {\n        delete contextsBase[name]\n\n        // Dispatch event.\n        this.dispatchEvent('simple-context-removed', [this, name])\n        return true\n      }\n\n      // Validate name.\n      if (!name.match('^([a-zA-Z_$][a-zA-Z\\\\d_$]*)$')) {\n        console.warn('Doars: name of a bind can not start with a \"$\".')\n        return false\n      }\n\n      // Store value on contexts base.\n      contextsBase[name] = value\n\n      // Dispatch event.\n      this.dispatchEvent('simple-context-added', [this, name, value])\n\n      return true\n    }\n\n    /**\n     * Adds simple contexts by looping through the object and calling the the setSimpleContext function with the data.\n     * @param {Array<Context>} contexts An object where the key is the name for the simple context and the value the simple context.\n     * @returns {Array<Context>} Which simple context was successfully set.\n     */\n    this.setSimpleContexts = (\n      contexts,\n    ) => {\n      const result = {}\n      for (const name in contexts) {\n        if (Object.hasOwnProperty.call(contexts, name)) {\n          result[name] = this.setSimpleContext(name, contexts[name])\n        }\n      }\n      return result\n    }\n\n    /* Contexts */\n\n    /**\n     * Get list contexts.\n     * @returns {Array<Context>} List of contexts.\n     */\n    this.getContexts = (\n    ) => [...contexts]\n\n    /**\n     * Add contexts at the index. *Can only be called when NOT enabled.*\n     * @param {number} index Index to start adding at.\n     * @param {...Context} _contexts List of contexts to add.\n     * @returns {Array<Context>|undefined} List of added contexts.\n     */\n    this.addContexts = (\n      index,\n      ..._contexts\n    ) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to add contexts after being enabled!')\n        return\n      }\n\n      if (index < 0) {\n        index = contexts.length + (index % contexts.length)\n      } else if (index > contexts.length) {\n        index = contexts.length\n      }\n\n      const results = []\n      for (let i = 0; i < _contexts.length; i++) {\n        // Get context from list.\n        const context = _contexts[i]\n\n        // Skip if already in list.\n        if (contexts.includes(context)) {\n          continue\n        }\n\n        // Add to list.\n        contexts.splice(index + i, 0, context)\n\n        // Add to results.\n        results.push(context)\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('contexts-added', [this, results])\n      }\n\n      return results\n    }\n\n    /**\n     * Remove contexts. *Can only be called when NOT enabled.*\n     * @param {...Context} _contexts List of contexts to remove.\n     * @returns {Array<Context>|undefined} List of removed contexts.\n     */\n    this.removeContexts = (\n      ..._contexts\n    ) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to remove contexts after being enabled!')\n        return\n      }\n\n      const results = []\n      for (const context of _contexts) {\n        // Skip if not in list.\n        const index = contexts.indexOf(context)\n        if (index < 0) {\n          continue\n        }\n\n        // Remove from list.\n        contexts.slice(index, 1)\n\n        // Add to results.\n        results.push(context)\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('contexts-removed', [this, results])\n      }\n\n      return results\n    }\n\n    /* Directives */\n\n    /**\n     * Get list directives.\n     * @returns {Array<Directive>} List of directives.\n     */\n    this.getDirectives = (\n    ) => [...directives]\n\n    /**\n     * Get list of directive names.\n     * @returns {Array<string>} List of directive names.\n     */\n    this.getDirectivesNames = (\n    ) => [...directivesNames]\n\n    /**\n     * Get object of directives with the directive name as key.\n     * @returns {DirectiveMap} Object of directives.\n     */\n    this.getDirectivesObject = (\n    ) => Object.assign({}, directivesObject)\n\n    /**\n     * Check whether a name matches that of a directive.\n     * @param {string} attributeName Name of the attribute to match.\n     * @returns {boolean} Whether the name matches that of a directive.\n     */\n    this.isDirectiveName = (\n      attributeName,\n    ) => directivesRegexp.test(attributeName)\n\n    /**\n     * Add directives at the index. *Can only be called when NOT enabled.*\n     * @param {number} index Index to start adding at.\n     * @param  {...Directive} _directives List of directives to add.\n     * @returns {Array<Directive>|undefined} List of added directives.\n     */\n    this.addDirectives = (\n      index,\n      ..._directives\n    ) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to add directives after being enabled!')\n        return\n      }\n\n      if (index < 0) {\n        index = directives.length + (index % directives.length)\n      } else if (index > directives.length) {\n        index = directives.length\n      }\n\n      const results = []\n      for (let i = 0; i < _directives.length; i++) {\n        // Get directive from list.\n        const directive = _directives[i]\n\n        // Skip if already in list.\n        if (directives.includes(directive)) {\n          continue\n        }\n\n        // Add to list.\n        directives.splice(index + i, 0, directive)\n\n        // Add to results.\n        results.push(directive)\n      }\n\n      if (results.length > 0) {\n        // Reset directives helpers.\n        directivesNames = directivesObject = directivesRegexp = null\n\n        // Dispatch event.\n        this.dispatchEvent('directives-added', [this, results])\n      }\n\n      return results\n    }\n\n    /**\n     * Remove directives. *Can only be called when NOT enabled.*\n     * @param  {...Directive} _directives List of directives to remove.\n     * @returns {Array<Directive>|undefined} List of removed directives.\n     */\n    this.removeDirectives = (\n      ..._directives\n    ) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to remove directives after being enabled!')\n        return\n      }\n\n      const results = []\n      for (const directive of _directives) {\n        // Skip if not in list.\n        const index = directives.indexOf(directive)\n        if (index < 0) {\n          continue\n        }\n\n        // Remove from list.\n        directives.slice(index, 1)\n\n        // Add to results\n        results.push(directive)\n      }\n\n      if (results.length > 0) {\n        // Reset directives helpers.\n        directivesNames = directivesObject = directivesRegexp = null\n\n        // Dispatch event.\n        this.dispatchEvent('directives-removed', [this, results])\n      }\n\n      return results\n    }\n\n    /* Update */\n\n    this.getProcessor = () => {\n      return processExpression\n    }\n\n    /**\n     * Update directives based on triggers. *Can only be called when enabled.*\n     * @param {Array<Trigger>} _triggers List of triggers to update with.\n     */\n    this.update = (\n      _triggers,\n    ) => {\n      if (!isEnabled) {\n        // Exit early since it needs to enabled first.\n        return\n      }\n\n      if (_triggers) {\n        // Add new triggers to existing triggers.\n        for (const trigger of _triggers) {\n          // Deconstruct new trigger.\n          const {\n            id,\n            path,\n          } = trigger\n\n          // Create list at id if not already there.\n          if (!(id in triggers)) {\n            triggers[id] = [\n              path,\n            ]\n            continue\n          }\n\n          // Add path to list at id.\n          if (!triggers[id].includes(path)) {\n            triggers[id].push(path)\n          }\n        }\n      }\n\n      // Don't update while another update is going on.\n      if (isUpdating) {\n        return\n      }\n\n      // Check if there is something to update.\n      if (Object.getOwnPropertySymbols(triggers).length === 0) {\n        return\n      }\n\n      // Set as updating.\n      isUpdating = true\n\n      // Move update triggers to local scope only.\n      _triggers = Object.freeze(triggers)\n      triggers = {}\n\n      this.dispatchEvent('updating', [this, _triggers])\n\n      // Update each component and collect any triggers.\n      for (const component of components) {\n        component.update(_triggers)\n        // If this ever needs to be done in hierarchical order try the following. Go over each component and check if its parent is further down in the list. If so place the component directly after the parent. Then continue iteration over the components. This sorting only has to happen when a component is added to or moved in the hierarchy.\n      }\n\n      // Set as NOT updating.\n      isUpdating = false\n\n      // If there are triggers again then update again.\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        console.warn('Doars: during an update another update has been triggered. This should not happen unless an expression in one of the directives is causing a infinite loop by mutating the state.')\n        // Use an animation frame to delay the update to prevent freezing and hope it resolves itself.\n        window.requestAnimationFrame(() => this.update())\n        return\n      }\n\n      // If there are any mutation to handle then handle them.\n      if (mutations.length > 0) {\n        handleMutation()\n        return\n      }\n\n      this.dispatchEvent('updated', [this, _triggers])\n    }\n\n    /**\n     * Handle document mutations by update internal data and executing directives.\n     * @param {Array<MutationRecord>} newMutations List of mutations.\n     */\n    const handleMutation = (\n      newMutations,\n    ) => {\n      // Add mutations to existing list.\n      mutations.push(...newMutations)\n\n      // Don't handle mutations while an update is going on.\n      if (isUpdating) {\n        return\n      }\n\n      // Check if there are any mutations to handle.\n      if (mutations.length === 0) {\n        return\n      }\n\n      // Set as updating.\n      isUpdating = true\n\n      // Get mutations to handle.\n      newMutations = [...mutations]\n      mutations = []\n\n      const {\n        stateDirectiveName,\n        ignoreDirectiveName,\n      } = this.getOptions()\n\n      // Construct component name.\n      const componentName = prefix + '-' + stateDirectiveName\n      const ignoreName = prefix + '-' + ignoreDirectiveName\n\n      // Store new attribute and elements that define new components.\n      const componentsToAdd = []\n      const componentsToRemove = []\n\n      const remove = (element) => {\n        // Skip if not an element.\n        if (element.nodeType !== 1) {\n          return\n        }\n\n        // Check if element is a component itself.\n        if (element[COMPONENT]) {\n          // Add component to remove list.\n          componentsToRemove.unshift(element[COMPONENT])\n          // Scan for more components inside this.\n          const componentElements = element.querySelectorAll(componentName)\n          for (const componentElement of componentElements) {\n            if (componentElement[COMPONENT]) {\n              componentsToRemove.unshift(componentElement)\n            }\n          }\n        } else {\n          // Create iterator for walking over all elements in the component, skipping elements that are components and adding those to the remove list.\n          const iterator = walk(element, (element) => {\n            if (element[COMPONENT]) {\n              componentsToRemove.unshift(element[COMPONENT])\n              return false\n            }\n            return true\n          })\n          do {\n            // Check if element has attributes.\n            if (!element[ATTRIBUTES]) {\n              continue\n            }\n\n            // Remove attributes from their component.\n            for (const attribute of element[ATTRIBUTES]) {\n              attribute.getComponent().removeAttribute(attribute)\n            }\n          } while (element = iterator())\n        }\n      }\n      const add = (\n        element,\n      ) => {\n        // Skip if not an element.\n        if (element.nodeType !== 1) {\n          return\n        }\n\n        // Skip if inside an ignore tag.\n        const ignoreParent = element.closest('[' + ignoreName + ']')\n        if (ignoreParent) {\n          return\n        }\n\n        // Scan for new components and add them to the list.\n        const componentElements = element.querySelectorAll('[' + componentName + ']')\n        for (const componentElement of componentElements) {\n          // Skip if inside an ignore tag.\n          const ignoreParent = componentElement.closest('[' + ignoreName + ']')\n          if (ignoreParent) {\n            continue\n          }\n\n          componentsToAdd.push(componentElement)\n        }\n\n        // Check if this elements defines a new component.\n        if (element.hasAttribute(componentName)) {\n          // Store new component element and exit early.\n          componentsToAdd.push(element)\n          return\n        }\n\n        // Find nearest component.\n        const component = closestComponent(element)\n        if (component) {\n          // Scan for and update new attributes.\n          const attributes = component.scanAttributes(element)\n          component.updateAttributes(attributes)\n        }\n      }\n\n      // Iterate over mutations.\n      for (const mutation of newMutations) {\n        if (mutation.type === 'childList') {\n          // Iterate over removed elements.\n          for (const element of mutation.removedNodes) {\n            remove(element)\n          }\n\n          // Iterate over added elements.\n          for (const element of mutation.addedNodes) {\n            add(element)\n          }\n        } else if (mutation.type === 'attributes') {\n          const element = mutation.target\n          // Check if new component is defined.\n          if (mutation.attributeName === componentName) {\n            // If a component is already defined ignore the change.\n            if (element[COMPONENT]) {\n              continue\n            }\n\n            // Get nearest component, this will become the parent.\n            const component = closestComponent(element)\n            if (component) {\n              // Remove attributes part of nearest component, that will become part of the new component.\n              let currentElement = element\n              const iterator = walk(element, (element) => element.hasAttribute(componentName))\n              do {\n                for (const attribute of currentElement[ATTRIBUTES]) {\n                  component.removeAttribute(attribute)\n                }\n              } while (currentElement = iterator())\n            }\n\n            // Add new component.\n            addComponents(element)\n            continue\n          } else if (mutation.attributeName === ignoreName) {\n            if (element.hasAttribute(ignoreName)) {\n              // Remove everything inside.\n              remove(element)\n              continue\n            }\n\n            // Add everything inside.\n            add(element)\n            continue\n          }\n\n          // Check if a directive is added.\n          if (!directivesRegexp.test(mutation.attributeName)) {\n            continue\n          }\n\n          // Get component of mutated element.\n          const component = closestComponent(element)\n          if (!component) {\n            continue\n          }\n\n          // Get attribute from component and value from element.\n          let attribute = null\n          for (const targetAttribute of element[ATTRIBUTES]) {\n            if (targetAttribute.getName() === mutation.attributeName) {\n              attribute = targetAttribute\n              break\n            }\n          }\n          const value = element.getAttribute(mutation.attributeName)\n\n          // If no attribute found add it.\n          if (!attribute) {\n            if (value) {\n              component.addAttribute(element, mutation.attributeName, value)\n            }\n            continue\n          }\n\n          // Update attribute.\n          attribute.setValue(value)\n          component.updateAttribute(attribute)\n        }\n      }\n\n      // Remove old components.\n      if (componentsToRemove.length > 0) {\n        removeComponents(...componentsToRemove)\n      }\n      // Add new components.\n      if (componentsToAdd.length > 0) {\n        addComponents(...componentsToAdd)\n      }\n\n      // Set as NOT updating.\n      isUpdating = false\n\n      // If there are any mutation to handle then handle them.\n      if (mutations.length > 0) {\n        handleMutation()\n        return\n      }\n\n      // If there are any triggers then trigger an update.\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        this.update()\n      }\n    }\n  }\n}\n", "// Import context.\nimport { createContexts } from './Context.js'\n\n/**\n * @typedef {import('../Attribute.js').default} Attribute\n * @typedef {import('../Component.js').default} Component\n */\n\n/**\n * Executes value in the correct context.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {string} expression Expression to execute.\n * @param {object|null} extra Optional extra context items.\n * @param {object|null} options Optional options object.\n * @returns {any} Result of expression.\n */\nexport const execute = (\n  component,\n  attribute,\n  expression,\n  extra = null,\n  options = null,\n) => {\n  // Override default with given options.\n  options = Object.assign({\n    return: true,\n  }, options)\n\n  // Collect update triggers.\n  const triggers = []\n  const update = (id, context) => {\n    triggers.push({\n      id,\n      path: context,\n    })\n  }\n\n  // Create function context.\n  let {\n    after,\n    before,\n    contexts,\n    destroy,\n  } = createContexts(\n    component,\n    attribute,\n    update,\n    extra,\n  )\n\n  // Apply options.\n  if (options.return) {\n    before += 'return '\n  }\n\n  // Try to execute code.\n  let result\n  try {\n    result = new Function(...Object.keys(contexts), before + expression + after)(...Object.values(contexts)) // eslint-disable-line no-new-func\n  } catch (error) {\n    console.error('ExpressionError in:', expression, '\\n' + error.name + ': ' + error.message)\n    result = null\n  }\n\n  // Invoke destroy.\n  destroy()\n\n  // Dispatch update triggers.\n  if (triggers.length > 0) {\n    component.getLibrary().update(triggers)\n  }\n\n  return result\n}\n\nexport default {\n  execute,\n}\n", "import Doars from './Doars.js'\nimport { execute } from './utilities/Execute.js'\n\nDoars.executeExpression = execute\n\nexport default Doars\n"],
  "mappings": "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",
  "names": ["ATTRIBUTES", "COMPONENT", "FOR", "REFERENCES", "REFERENCES_CACHE", "EventDispatcher", "events", "name", "callback", "options", "eventData", "index", "i", "parameters", "event", "escapeHtml", "text", "kebabToCamel", "match", "character", "parseAttributeModifiers", "modifiers", "result", "modifier", "hyphenIndex", "key", "value", "tmpValue", "type", "parseAttributeName", "prefix", "name", "full", "directive", "keyRaw", "parseForExpression", "expression", "variables", "parseSelector", "selector", "attributes", "selectorSegment", "Attribute", "_Attribute", "EventDispatcher", "component", "element", "name", "value", "isClone", "id", "ATTRIBUTES", "accessedItems", "data", "directive", "key", "keyRaw", "modifiersRaw", "modifiers", "_directive", "_keyRaw", "_key", "_modifiers", "parseAttributeName", "parseAttributeModifiers", "_value", "_data", "indexInElement", "path", "paths", "accessedAtId", "PROXY_TRAPS", "RevocableProxy_default", "target", "handler", "revoked", "revocableHandler", "key", "parameters", "ProxyDispatcher", "EventDispatcher", "options", "map", "target", "path", "key", "handler", "deleted", "receiver", "value", "revocable", "RevocableProxy_default", "property", "closestComponent", "element", "COMPONENT", "fromString", "string", "stringStart", "html", "template", "isSame", "a", "b", "walk", "element", "filter", "index", "iterator", "child", "Component", "library", "element", "id", "prefix", "stateDirectiveName", "processExpression", "attributes", "hasUpdated", "isInitialized", "data", "proxy", "state", "COMPONENT", "children", "parent", "closestComponent", "dispatchEvent", "name", "detail", "_parent", "componentName", "value", "Attribute", "ProxyDispatcher", "directives", "key", "attribute", "directive", "triggers", "child", "directivesKeys", "index", "directiveIndex", "i", "indexInAttributes", "ignoreDirectiveName", "ignoreName", "newAttributes", "iterator", "walk", "triggerIds", "updatedAttributes", "createContexts", "component", "attribute", "update", "extra", "library", "contexts", "deconstructed", "after", "before", "creatableContexts", "destroyFunctions", "creatableContext", "result", "name", "destroyFunction", "createContextsProxy", "data", "revocable", "RevocableProxy_default", "target", "property", "createAutoContexts", "triggers", "id", "context", "destroy", "children_default", "childrenContextName", "component", "attribute", "update", "childrenContexts", "revocable", "RevocableProxy_default", "target", "key", "receiver", "child", "createContextsProxy", "component_default", "componentContextName", "component", "element_default", "elementContextName", "component", "attribute", "dispatch_default", "dispatchContextName", "component", "name", "detail", "for_default", "forContextDeconstruct", "forContextName", "component", "attribute", "element", "componentElement", "items", "target", "data", "FOR", "key", "revocable", "RevocableProxy_default", "item", "inContext_default", "inContextContextName", "component", "attribute", "callback", "newTriggers", "contextUpdate", "id", "path", "contexts", "destroy", "createContexts", "result", "nextSibling_default", "nextSiblingContextName", "component", "attribute", "update", "parent", "siblings", "index", "contexts", "destroy", "createContextsProxy", "nextTick_default", "nextTickContextName", "component", "attribute", "update", "callbacks", "isInitialized", "initialize", "library", "handleUpdate", "stopListening", "contexts", "destroy", "createContexts", "callback", "parent_default", "parentContextName", "component", "attribute", "update", "parent", "contexts", "destroy", "createContextsProxy", "previousSibling_default", "previousSiblingContextName", "component", "attribute", "update", "parent", "siblings", "index", "contexts", "destroy", "createContextsProxy", "references_default", "referencesContextName", "component", "attribute", "REFERENCES", "cache", "REFERENCES_CACHE", "references", "attributeIds", "id", "element", "name", "revocable", "RevocableProxy_default", "target", "propertyKey", "receiver", "siblings_default", "siblingsContextName", "component", "attribute", "update", "parent", "siblingsContexts", "revocable", "RevocableProxy_default", "sibling", "target", "key", "receiver", "child", "createContextsProxy", "createState_default", "name", "id", "state", "proxy", "component", "attribute", "update", "onDelete", "target", "path", "onGet", "onSet", "revocable", "RevocableProxy_default", "state_default", "stateContextDeconstruct", "stateContextName", "component", "attribute", "update", "utilities", "proxy", "state", "createState_default", "deepAssign", "target", "sources", "source", "isObject", "key", "value", "getDeeply", "object", "path", "objectTemp", "i", "setDeeply", "createStateContext_default", "name", "id", "state", "proxy", "deconstruct", "createState_default", "store_default", "storeContextDeconstruct", "storeContextInitial", "storeContextName", "data", "deepAssign", "proxy", "ProxyDispatcher", "state", "createStateContext_default", "watch_default", "watchContextName", "component", "attribute", "callbacks", "contextIsDestroyed", "directiveIsDestroyed", "isInitialized", "processExpression", "initialized", "library", "onUpdate", "_", "triggers", "ids", "newTriggers", "contextUpdate", "id", "path", "callback", "contexts", "destroy", "createContexts", "stopHandling", "addAttributes", "element", "data", "name", "className", "copyAttributes", "existingNode", "newNode", "existingAttributes", "newAttributes", "attributeNamespaceURI", "attributeValue", "fromValue", "attributeName", "attribute", "j", "removeAttributes", "setAttribute", "key", "value", "setAttributes", "nativePromise", "isPromise", "value", "attribute_default", "attributeDirectiveName", "component", "attribute", "processExpression", "directive", "element", "modifiers", "set", "value", "parseSelector", "setAttributes", "key", "setAttribute", "result", "isPromise", "resultResolved", "TRANSITION_NAME", "transition", "type", "libraryOptions", "element", "callback", "transitionDirectiveName", "dispatchEvent", "phase", "name", "value", "timeout", "requestFrame", "isDone", "selectors", "parseSelector", "addAttributes", "removeAttributes", "styles", "duration", "transitionIn", "transitionOut", "cloak_default", "cloakDirectiveName", "component", "attribute", "element", "libraryOptions", "transitionIn", "_readdScript", "element", "newScript", "readdScripts", "elements", "iterate", "walk", "maybeScript", "createVariables", "names", "values", "variables", "i", "indexInSiblings", "elements", "value", "offset", "FOR", "setAfter", "component", "update", "template", "index", "allowInlineScript", "libraryOptions", "existingIndex", "element", "sibling", "readdScripts", "transitionIn", "removeAfter", "maxLength", "transitionOut", "for_default", "forDirectiveName", "attribute", "processExpression", "directive", "modifiers", "expression", "parseForExpression", "triggers", "id", "set", "iterable", "data", "iterableType", "isArray", "length", "e", "keys", "key", "result", "isPromise", "resultResolved", "DECODE_LOOKUP", "DECODE_REGEXP", "decode", "string", "DECODE_REGEXP", "character", "DECODE_LOOKUP", "morphNode", "existingNode", "newNode", "nodeType", "nodeName", "copyAttributes", "_updateInput", "_updateAttribute", "_updateTextarea", "morphTree", "existingTree", "newTree", "options", "fromString", "_updateChildren", "_updateTree", "newValue", "existingValue", "name", "existingChild", "newChild", "morphed", "existingMatch", "offset", "i", "isSame", "j", "html_default", "allowInlineScript", "htmlDirectiveName", "component", "attribute", "processExpression", "directive", "element", "modifiers", "set", "html", "decode", "child", "morphTree", "i", "root", "readdScripts", "result", "isPromise", "resultResolved", "if_default", "allowInlineScript", "ifDirectiveName", "component", "attribute", "processExpression", "libraryOptions", "directive", "modifiers", "template", "set", "result", "data", "element", "transition", "readdScripts", "transitionIn", "transitionOut", "isPromise", "INITIALIZED", "destroy", "component", "attribute", "element", "name", "initialized_default", "initializedDirectiveName", "processExpression", "value", "handler", "detail", "ON", "CANCEL_EVENTS", "EXECUTION_MODIFIERS", "KEYPRESS_MODIFIERS", "on_default", "onDirectiveName", "component", "attribute", "processExpression", "directive", "eventName", "key", "element", "value", "modifiers", "listenerOptions", "executionModifier", "keypressModifiers", "modifier", "target", "handler", "event", "keypressModifier", "eventKey", "execute", "cancelHeldName", "nowHeld", "cancelEvent", "cancelHoldName", "keyLetGo", "nowThrottle", "destroy", "component", "attribute", "REFERENCES", "attributeId", "library", "componentId", "name", "REFERENCES_CACHE", "reference_default", "referenceDirectiveName", "processExpression", "directive", "element", "referenceDirectiveEvaluate", "TAG_SELECT", "CHECKED", "SELECTED", "TYPE_CHECKBOX", "select_default", "selectDirectiveName", "component", "attribute", "processExpression", "element", "directive", "type", "set", "data", "option", "select", "checked", "result", "isPromise", "resultResolved", "show_default", "showDirectiveName", "component", "attribute", "processExpression", "libraryOptions", "element", "set", "data", "transition", "transitionIn", "transitionOut", "result", "isPromise", "resultResolved", "SYNC", "sync_default", "syncDirectiveName", "component", "attribute", "processExpression", "element", "directive", "isNew", "value", "key", "valueSplit", "handler", "contexts", "destroyContexts", "createAutoContexts", "setDeeply", "escapeHtml", "elementValue", "dataValue", "getDeeply", "index", "elementValues", "option", "checked", "select", "text_default", "textDirectiveName", "component", "attribute", "processExpression", "element", "modifiers", "set", "text", "result", "isPromise", "resultResolved", "watch_default", "watchDirectiveName", "component", "attribute", "processExpression", "Doars", "EventDispatcher", "options", "_a", "_b", "prefix", "processor", "root", "id", "isEnabled", "isUpdating", "mutations", "observer", "triggers", "components", "contextsBase", "contexts", "children_default", "component_default", "element_default", "dispatch_default", "inContext_default", "nextSibling_default", "nextTick_default", "parent_default", "previousSibling_default", "references_default", "siblings_default", "watch_default", "store_default", "state_default", "for_default", "directives", "reference_default", "attribute_default", "html_default", "if_default", "text_default", "cloak_default", "initialized_default", "on_default", "select_default", "show_default", "sync_default", "directivesNames", "directivesObject", "directivesRegexp", "processorType", "processExpression", "directive", "handleMutation", "stateDirectiveName", "ignoreDirectiveName", "componentName", "ignoreName", "componentElements", "i", "addComponents", "removeComponents", "elements", "results", "resultElements", "element", "COMPONENT", "component", "Component", "_components", "index", "name", "value", "result", "_contexts", "context", "attributeName", "_directives", "_triggers", "trigger", "path", "newMutations", "componentsToAdd", "componentsToRemove", "remove", "componentElement", "iterator", "walk", "ATTRIBUTES", "attribute", "add", "closestComponent", "attributes", "mutation", "currentElement", "targetAttribute", "execute", "component", "attribute", "expression", "extra", "options", "triggers", "update", "id", "context", "after", "before", "contexts", "destroy", "createContexts", "result", "error", "Doars", "execute", "DoarsExecute_default"]
}
