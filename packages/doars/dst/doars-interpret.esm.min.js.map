{
  "version": 3,
  "sources": ["../src/symbols.js", "../../common/src/events/EventDispatcher.js", "../../common/src/utils/String.js", "../src/Attribute.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/ProxyDispatcher.js", "../../common/src/utils/Attribute.js", "../../common/src/utils/Element.js", "../../common/src/utils/Morph.js", "../src/utils/Component.js", "../../common/src/utils/Transition.js", "../src/Component.js", "../src/contexts/children.js", "../src/contexts/component.js", "../src/contexts/element.js", "../src/contexts/dispatch.js", "../src/contexts/for.js", "../src/contexts/inContext.js", "../src/contexts/nextTick.js", "../src/contexts/parent.js", "../src/contexts/references.js", "../src/contexts/state.js", "../../common/src/utils/Promise.js", "../src/directives/attribute.js", "../src/directives/cloak.js", "../src/directives/for.js", "../../common/src/utils/Html.js", "../src/directives/html.js", "../src/directives/if.js", "../src/directives/initialized.js", "../src/directives/on.js", "../src/directives/reference.js", "../src/directives/select.js", "../src/directives/show.js", "../src/utils/Context.js", "../../common/src/utils/Object.js", "../src/directives/sync.js", "../src/directives/text.js", "../src/directives/watch.js", "../src/Doars.js", "../../interpret/src/parse.js", "../../interpret/src/run.js", "../../interpret/src/index.js", "../src/utils/Interpret.js", "../src/DoarsInterpret.js"],
  "sourcesContent": ["export const ATTRIBUTES = Symbol('ATTRIBUTES');\nexport const COMPONENT = Symbol('COMPONENT');\nexport const FOR = Symbol('FOR');\nexport const INITIALIZED = Symbol('INITIALIZED');\nexport const ON = Symbol('ON');\nexport const REFERENCES = Symbol('REFERENCES');\nexport const REFERENCES_CACHE = Symbol('REFERENCES_CACHE');\nexport const SYNC = Symbol('SYNC');", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {};\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = [];\n      } // Add to events.\n\n\n      events[name].push({\n        callback: callback,\n        options: options\n      });\n    };\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n\n\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return;\n      }\n\n      const eventData = events[name]; // Get index of callback in events.\n\n      let index = -1;\n\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return;\n      } // Remove item from events.\n\n\n      eventData.splice(index, 1); // Remove event if list is empty.\n\n      if (Object.keys(eventData).length === 0) {\n        delete events[name];\n      }\n    };\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeEventListeners = name => {\n      if (!name) {\n        return;\n      } // Remove all handlers with the event name.\n\n\n      delete events[name];\n    };\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {};\n    };\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n\n\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return;\n      } // Get events by trigger name.\n\n\n      const eventData = events[name]; // Dispatch a call to each event.\n\n      for (let i = 0; i < eventData.length; i++) {\n        const event = options && options.reverse ? eventData[eventData.length - (i + 1)] : eventData[i]; // If once is truthy then remove the callback.\n\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1);\n        } // Execute callback.\n\n\n        event.callback(...parameters);\n      }\n    };\n  }\n\n}\n\nexport default EventDispatcher;", "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {String} text String to escape.\n * @returns {String} Escaped string.\n */\nexport const escapeHtml = text => {\n  return text.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, '\\\\\\'').replace(/\\\"/g, '\\\\\"').replace(/\\n/g, '\\\\n');\n};\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {String} text String to modify.\n * @returns {String} Converted string.\n */\n\nexport const kebabToCamel = text => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase());\n};\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<String>} modifiers List of modifiers to parse.\n * @returns {Object} Parsed modifiers.\n */\n\nexport const parseAttributeModifiers = modifiers => {\n  const result = {};\n\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-'); // If no hyphen then set the modifiers to true.\n\n    if (hyphenIndex < 0) {\n      result[modifier] = true;\n      continue;\n    } // If it starts with hyphen then set the modifier to false.\n\n\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false;\n      continue;\n    } // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n\n\n    const key = modifier.substring(0, hyphenIndex);\n    let value = modifier.substring(hyphenIndex + 1);\n    let tmpValue = value; // Try to remove time suffixes.\n\n    let type;\n\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2);\n    } else if (value.endsWith('s')) {\n      type = 's';\n      tmpValue = value.substring(-1);\n    } else if (value.endsWith('m')) {\n      type = 'm';\n      tmpValue = value.substring(-1);\n    } else if (value.endsWith('h')) {\n      type = 'h';\n      tmpValue = value.substring(-1);\n    } // Try to parse the value as a number.\n\n\n    tmpValue = Number.parseInt(tmpValue);\n\n    if (!isNaN(tmpValue)) {\n      value = tmpValue; // Convert to milliseconds if given in a different format.\n\n      switch (type) {\n        case 'h':\n          value *= 60;\n\n        case 'm':\n          value *= 60;\n\n        case 's':\n          value *= 1000;\n          break;\n      }\n    } // Store modifier data.\n\n\n    result[key] = value;\n  }\n\n  return result;\n};\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {String} name Name to parse.\n * @returns {Array<String>} list of segments.\n */\n\nexport const parseAttributeName = (prefix, name) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'));\n\n  if (!name) {\n    return;\n  } // Deconstruct match.\n\n\n  let [full, directive, keyRaw, modifiers] = name; // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n\n  keyRaw = keyRaw !== '' ? keyRaw : null;\n  const key = keyRaw ? kebabToCamel(keyRaw) : null; // Ensure modifiers is and array.\n\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []; // Return result a single array.\n\n  return [directive, keyRaw, key, modifiers];\n};\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n */\n\nexport const parseForExpression = expression => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i);\n\n  if (!match) {\n    return;\n  } // Remove parenthesis.\n\n\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, ''); // Parse for variables.\n\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i);\n\n  if (!variables) {\n    return;\n  }\n\n  variables.shift();\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables] // Convert it to an array instead of a regular expression match.\n\n  };\n};\n/**\n * Parse selector to an attributes object.\n * @param {String} selector Selector to parse.\n * @returns {Object} Attributes. Do note the class property is a list of strings not a single string.\n */\n\nexport const parseSelector = selector => {\n  // Convert to array.\n  if (typeof selector === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/);\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.');\n    return;\n  }\n\n  const attributes = {};\n\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim(); // Base what to do of the leading character.\n\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1);\n        break;\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1); // Add to classlist.\n\n        if (!attributes.class) {\n          attributes.class = [];\n        }\n\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment);\n        }\n\n        break;\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i); // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n\n        attributes[key] = value;\n        break;\n    }\n  }\n\n  return attributes;\n};\nexport default {\n  escapeHtml: escapeHtml,\n  kebabToCamel: kebabToCamel,\n  parseAttributeModifiers: parseAttributeModifiers,\n  parseAttributeName: parseAttributeName,\n  parseForExpression: parseForExpression,\n  parseSelector: parseSelector\n};", "// Import event dispatcher.\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'; // Import symbols.\n\nimport { ATTRIBUTES } from './symbols.js'; // Import utils.\n\nimport { parseAttributeName, parseAttributeModifiers } from '@doars/common/src/utils/String.js';\nexport default class Attribute extends EventDispatcher {\n  /**\n   * Create instance.\n   * @param {Component} component Component instance.\n   * @param {HTMLElement} element Element.\n   * @param {String} name Attribute name (with library prefix removed).\n   * @param {String} value Attribute value.\n   * @param {Boolean} isClone Whether this will be a clone of an existing attribute.\n   */\n  constructor(component, element, name, value, isClone = false) {\n    super(); // Create unique ID.\n\n    const id = Symbol('ID_ATTRIBUTE');\n\n    if (!isClone) {\n      // Add attribute reference to the element.\n      if (!element[ATTRIBUTES]) {\n        element[ATTRIBUTES] = [];\n      }\n\n      element[ATTRIBUTES].push(this);\n    } // Create private variables.\n\n\n    let accessedItems = {},\n        data = null,\n        directive,\n        key,\n        keyRaw,\n        modifiersRaw,\n        modifiers; // Parse and store name.\n\n    if (name) {\n      // Parse and store attribute name.\n      const [_directive, _keyRaw, _key, _modifiers] = parseAttributeName(component.getLibrary().getOptions().prefix, name);\n      directive = _directive;\n      key = _key;\n      keyRaw = _keyRaw;\n      modifiersRaw = _modifiers; // Parse and store modifiers.\n\n      if (_modifiers) {\n        modifiers = parseAttributeModifiers(_modifiers);\n      }\n    }\n    /**\n     * Get the component this attribute is a part of.\n     * @returns {Component} Attribute's component.\n     */\n\n\n    this.getComponent = () => {\n      return component;\n    };\n    /**\n     * Get the element this attribute belongs to.\n     * @returns {HTMLElement} Element.\n     */\n\n\n    this.getElement = () => {\n      return element;\n    };\n    /**\n     * Get attribute id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get the directive this attribute matches.\n     * @returns {String} Directive name.\n     */\n\n\n    this.getDirective = () => {\n      return directive;\n    };\n    /**\n     * Get the optional key of the attribute.\n     * @returns {String} Key.\n     */\n\n\n    this.getKey = () => {\n      return key;\n    };\n    /**\n     * Get the optional key of the attribute before being processed.\n     * @returns {String} Raw key.\n     */\n\n\n    this.getKeyRaw = () => {\n      return keyRaw;\n    };\n    /**\n     * Get the optional modifiers of the attribute.\n     * @returns {Object} Modifiers object.\n     */\n\n\n    this.getModifiers = () => {\n      return Object.assign({}, modifiers);\n    };\n    /**\n     * Get the optional modifiers of the attribute before being processed.\n     * @returns {Array<String>} List of raw modifiers.\n     */\n\n\n    this.getModifiersRaw = () => {\n      return modifiersRaw;\n    };\n    /**\n     * Get attribute's name.\n     * @returns {String} Attribute name.\n     */\n\n\n    this.getName = () => {\n      return name;\n    };\n    /**\n     * Get the attribute's value.\n     * @returns {String} Value.\n     */\n\n\n    this.getValue = () => {\n      return value;\n    };\n    /**\n     * Set the attribute's value.\n     * @param {String} value New value.\n     */\n\n\n    this.setValue = _value => {\n      value = _value; // Dispatch changed event.\n\n      this.dispatchEvent('changed', [this]);\n    };\n    /**\n     * Clear custom data set.\n     */\n\n\n    this.clearData = () => {\n      data = null;\n    };\n    /**\n     * Whether there is data set.\n     * @returns {boolean} Whether data is set.\n     */\n\n\n    this.hasData = () => {\n      return data !== null;\n    };\n    /**\n     * Get custom data set previously.\n     * @returns {any} the data.\n     */\n\n\n    this.getData = () => {\n      return data;\n    };\n    /**\n     * Set custom attribute data.\n     * @param {any} data Some data.\n     */\n\n\n    this.setData = _data => {\n      data = _data;\n    };\n    /**\n     * Destroy the attribute.\n     */\n\n\n    this.destroy = () => {\n      // Clear data.\n      this.setData(null); // Clear accessed.\n\n      this.clearAccessed(); // Remove attribute from element's attributes.\n\n      const indexInElement = element[ATTRIBUTES].indexOf(this);\n\n      if (indexInElement >= 0) {\n        element[ATTRIBUTES].splice(indexInElement, 1);\n      } // Dispatch destroy event.\n\n\n      this.dispatchEvent('destroyed', [this]); // Remove all listeners.\n\n      this.removeAllEventListeners();\n    };\n    /**\n     * Mark an item as accessed.\n     * @param {Symbol} id Unique identifier.\n     * @param {String} path Context path.\n     */\n\n\n    this.accessed = (id, path) => {\n      if (!accessedItems[id]) {\n        accessedItems[id] = [];\n      } else if (accessedItems[id].includes(path)) {\n        return;\n      }\n\n      accessedItems[id].push(path); // Dispatch accessed event.\n\n      this.dispatchEvent('accessed', [this, id, path]);\n    };\n    /**\n     * Clear list of accessed items.\n     */\n\n\n    this.clearAccessed = () => {\n      accessedItems = {};\n    };\n    /**\n     * Check if attribute accessed any of the item's paths.\n     * @param {Symbol} id Unique identifier.\n     * @param {Array<String>} paths Contexts path.\n     * @returns {Boolean} Whether any item's path was accessed.\n     */\n\n\n    this.hasAccessed = (id, paths) => {\n      if (!(id in accessedItems)) {\n        return false;\n      }\n\n      const accessedAtId = accessedItems[id];\n\n      for (const path of paths) {\n        if (accessedAtId.includes(path)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * Creates a clone of the attribute without copying over the id and accessed values.\n     * @returns {Attribute} Cloned attribute.\n     */\n\n\n    this.clone = () => {\n      // Create new attribute as clone.\n      return new Attribute(component, element, name, value, true);\n    };\n  }\n\n}", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = ['apply', 'construct', 'defineProperty', 'deleteProperty', 'get', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf'];\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\n\nexport default ((target, handler) => {\n  // Keep track of status.\n  let revoked = false; // Add revocable handlers for each given handlers.\n\n  const revocableHandler = {};\n\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy');\n        return;\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters);\n      }\n\n      return Reflect[key](...parameters);\n    };\n  } // Return proxy and revoke method.\n\n\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true;\n    }\n  };\n});", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'; // Import event dispatcher.\n\nimport EventDispatcher from './EventDispatcher.js';\n\nclass ProxyDispatcher extends EventDispatcher {\n  constructor(options = {}) {\n    super();\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true\n    }, options); // Setup WeakMap for keep track of created proxies.\n\n    const map = new WeakMap();\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n\n    this.add = (target, path = []) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target);\n      } // Recursively create proxies for each property.\n\n\n      for (const key in target) {\n        if (target[key] && typeof target[key] === 'object') {\n          target[key] = this.add(target[key], [...path, key]);\n        }\n      } // Create handler and add the handler for which a callback exits..\n\n\n      const handler = {};\n\n      if (options.delete) {\n        handler.deleteProperty = (target, key) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true;\n          } // Remove proxy.\n\n\n          this.remove(target, key); // Delete property.\n\n          const deleted = Reflect.deleteProperty(target, key); // Dispatch delete event.\n\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]]);\n          } // Return deleted.\n\n\n          return deleted;\n        };\n      }\n\n      if (options.get) {\n        handler.get = (target, key, receiver) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver]);\n          } // Return value from object.\n\n\n          return Reflect.get(target, key, receiver);\n        };\n      }\n\n      if (options.set) {\n        handler.set = (target, key, value, receiver) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true;\n          } // Add proxy if value is an object.\n\n\n          if (typeof value === 'object') {\n            value = this.add(value, [...path, key]);\n          } // Store value.\n\n\n          target[key] = value; // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver]); // Return success.\n\n          return true;\n        };\n      } // Create proxy.\n\n\n      const revocable = RevocableProxy(target, handler); // Store target at proxy.\n\n      map.set(revocable, target); // Return proxy.\n\n      return revocable.proxy;\n    };\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n\n\n    this.remove = target => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return;\n      }\n\n      const revocable = map.get(target);\n      map.delete(revocable); // Recursively remove properties as well.\n\n      for (const property in revocable.proxy) {\n        if (typeof revocable.proxy[property] === 'object') {\n          this.remove(revocable.proxy[property]);\n        }\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    };\n  }\n\n}\n\nexport default ProxyDispatcher;", "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className);\n      }\n\n      continue;\n    } // Set attribute.\n\n\n    element.setAttribute(name, data[name]);\n  }\n};\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\n\nexport const copyAttributes = (existingNode, newNode) => {\n  const existingAttributes = existingNode.attributes;\n  const newAttributes = newNode.attributes;\n  let attributeNamespaceURI = null;\n  let attributeValue = null;\n  let fromValue = null;\n  let attributeName = null;\n  let attribute = null;\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i];\n    attributeName = attribute.name;\n    attributeNamespaceURI = attribute.namespaceURI;\n    attributeValue = attribute.value;\n\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName;\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName);\n\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue);\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue);\n      } else {\n        fromValue = existingNode.getAttribute(attributeName);\n\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName);\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue);\n          }\n        }\n      }\n    }\n  } // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n\n\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j];\n\n    if (attribute.specified !== false) {\n      attributeName = attribute.name;\n      attributeNamespaceURI = attribute.namespaceURI;\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName;\n\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName);\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n};\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\n\nexport const removeAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className);\n      }\n\n      continue;\n    } // Check if optional values match.\n\n\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue;\n    } // Remove attribute.\n\n\n    element.removeAttribute(name);\n  }\n};\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\n\nexport const setAttribute = (element, key, data) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = '';\n    } // Exit early if nothing will change.\n\n\n    if (element.getAttribute(key) === data) {\n      return;\n    } // Update attribute.\n\n\n    element.setAttribute(key, data); // Exit special cases early.\n\n    return;\n  } // If checked attribute then set the checked property instead.\n\n\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data;\n      return;\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ');\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';');\n    }\n  } // Update attribute on element.\n\n\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key);\n  } else {\n    element.setAttribute(key, data);\n  }\n};\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\n\nexport const setAttributes = (element, data) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name]);\n  }\n};\nexport default {\n  addAttributes: addAttributes,\n  copyAttributes: copyAttributes,\n  removeAttributes: removeAttributes,\n  setAttribute: setAttribute\n};", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = string => {\n  const template = document.createElement('template');\n  template.innerHTML = string;\n  return template.content.childNodes[0];\n};\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\n\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling);\n  } else {\n    reference.parentNode.appendChild(node);\n  }\n};\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\n\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b);\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false;\n  }\n\n  if (a.type === 3) {\n    // Text node.\n    return a.nodeValue === b.nodeValue;\n  }\n\n  return false;\n};\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\n\nexport const walk = (element, filter) => {\n  let index = -1;\n  let iterator = null;\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator();\n\n      if (child) {\n        return child;\n      }\n    } // Get next child that passes the filter.\n\n\n    let child = null;\n\n    do {\n      index++;\n\n      if (index >= element.childElementCount) {\n        return null;\n      }\n\n      child = element.children[index];\n    } while (!filter(child)); // Setup iterator for child.\n\n\n    if (child.childElementCount) {\n      iterator = walk(child, filter);\n    } // Return the child.\n\n\n    return child;\n  };\n};\nexport default {\n  fromString: fromString,\n  insertAfter: insertAfter,\n  isSame: isSame,\n  walk: walk\n};", "// Based on choo's nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme).\n// Import utils.\nimport { copyAttributes } from './Attribute.js';\nimport { fromString as ElementFromString, isSame as ElementIsSame } from './Element.js';\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\n\nexport const morphNode = (existingNode, newNode) => {\n  const nodeType = newNode.nodeType;\n  const nodeName = newNode.nodeName; // Element node.\n\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode);\n  } // Text node or comment node.\n\n\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue;\n    }\n  } // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n\n\n  if (nodeName === 'INPUT') {\n    updateInput(existingNode, newNode);\n  } else if (nodeName === 'OPTION') {\n    updateAttribute(existingNode, newNode, 'selected');\n  } else if (nodeName === 'TEXTAREA') {\n    updateTextarea(existingNode, newNode);\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\n\nexport const morphTree = (existingTree, newTree, options) => {\n  if (typeof existingTree !== 'object') {\n    throw new Error('Existing tree should be an object.');\n  }\n\n  if (typeof newTree === 'string') {\n    newTree = ElementFromString(newTree);\n  } else if (typeof newTree !== 'object') {\n    throw new Error('New tree should be an object.');\n  } // Check if outer or inner html should be updated. Always update children if root node is a document fragment.\n\n\n  if (options && options.childrenOnly || newTree.nodeType === 11) {\n    updateChildren(existingTree, newTree);\n    return existingTree;\n  }\n\n  return updateTree(existingTree, newTree);\n};\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\nconst updateInput = (existingNode, newNode) => {\n  // The \"value\" attribute is special for the <input> element since it sets the\n  // initial value. Changing the \"value\" attribute without changing the \"value\"\n  // property will have no effect since it is only used to the set the initial\n  // value. Similar for the \"checked\" attribute, and \"disabled\".\n  const newValue = newNode.value;\n  const existingValue = existingNode.value;\n  updateAttribute(existingNode, newNode, 'checked');\n  updateAttribute(existingNode, newNode, 'disabled'); // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate;\n  } // Persist file value since file inputs can't be changed programmatically\n\n\n  if (existingNode.type === 'file') {\n    return;\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue);\n    existingNode.value = newValue;\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = '';\n    existingNode.removeAttribute('value');\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value');\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue;\n  }\n};\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateTextarea = (existingNode, newNode) => {\n  const newValue = newNode.value;\n\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue;\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and visa versa. This ignores an empty update.\n    if (existingNode.firstChild.nodeValue === existingNode.placeholder && newValue === '') {\n      return;\n    }\n\n    existingNode.firstChild.nodeValue = newValue;\n  }\n};\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateAttribute = (existingNode, newNode, name) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name];\n\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '');\n    } else {\n      existingNode.removeAttribute(name);\n    }\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\n\n\nconst updateTree = (existingTree, newTree) => {\n  if (!existingTree) {\n    return newTree;\n  }\n\n  if (!newTree) {\n    return null;\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree;\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree;\n  }\n\n  morphNode(existingTree, newTree);\n  updateChildren(existingTree, newTree);\n  return existingTree;\n};\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\n\n\nconst updateChildren = (existingNode, newNode) => {\n  let existingChild, newChild, morphed, existingMatch; // The offset is only ever increased, and used for [i - offset] in the loop\n\n  let offset = 0;\n\n  for (let i = 0;; i++) {\n    existingChild = existingNode.childNodes[i];\n    newChild = newNode.childNodes[i - offset]; // Both nodes are empty, do nothing\n\n    if (!existingChild && !newChild) {\n      break; // There is no new child, remove old\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild);\n      i--; // There is no old child, add new\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild);\n      offset++; // Both nodes are the same, morph\n    } else if (ElementIsSame(existingChild, newChild)) {\n      morphed = updateTree(existingChild, newChild);\n\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild);\n        offset++;\n      } // Both nodes do not share an ID or a placeholder, try reorder\n\n    } else {\n      existingMatch = null; // Try and find a similar node somewhere in the tree\n\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (ElementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j];\n          break;\n        }\n      } // If there was a node with the same ID or placeholder in the old list\n\n\n      if (existingMatch) {\n        morphed = updateTree(existingMatch, newChild);\n        if (morphed !== existingMatch) offset++;\n        existingNode.insertBefore(morphed, existingChild); // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = updateTree(existingChild, newChild);\n\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild);\n          offset++;\n        } // Insert the node at the index if we couldn't morph or find a matching node\n\n      } else {\n        existingNode.insertBefore(newChild, existingChild);\n        offset++;\n      }\n    }\n  }\n};\n\nexport default {\n  morphNode: morphNode,\n  morphTree: morphTree\n};", "// Import symbols.\nimport { COMPONENT } from '../symbols.js';\n/**\n * Get closest component in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Component} Closest component.\n */\n\nexport const closestComponent = element => {\n  if (!element.parentElement) {\n    return;\n  }\n\n  element = element.parentElement;\n\n  if (element[COMPONENT]) {\n    return element[COMPONENT];\n  }\n\n  return closestComponent(element);\n};\nexport default {\n  closestComponent: closestComponent\n};", "// Import utils.\nimport { parseSelector } from './String.js';\nimport { addAttributes, removeAttributes } from './Attribute.js'; // Transition name.\n\nconst TRANSITION_NAME = '-transition:';\n/**\n * Transition an element.\n * @param {String} type Type of transition, for example 'in' and 'out'.\n * @param {Component} component Component the transitioning element is part of.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n */\n\nexport const transition = (type, component, element, callback = null) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Get library options.\n\n\n  const {\n    prefix\n  } = component.getLibrary().getOptions(); // Transition attribute name.\n\n  const transitionName = prefix + TRANSITION_NAME + type; // Setup dispatcher function.\n\n  const dispatchEvent = phase => {\n    element.dispatchEvent(new CustomEvent('transition-' + phase));\n    element.dispatchEvent(new CustomEvent('transition-' + type + '-' + phase));\n  }; // Declare variables for later.\n\n\n  let name, value, timeout, requestFrame;\n  let isDone = false;\n  const selectors = {}; // Process transition during attribute.\n\n  name = transitionName;\n  value = element.getAttribute(name); // Parse and apply returned selector.\n\n  if (value) {\n    selectors.during = parseSelector(value);\n    addAttributes(element, selectors.during);\n  } // Process transition from attribute.\n\n\n  name = transitionName + '.from';\n  value = element.getAttribute(name); // Parse and apply returned selector.\n\n  if (value) {\n    selectors.from = parseSelector(value);\n    addAttributes(element, selectors.from);\n  } // Dispatch transition event.\n\n\n  dispatchEvent('start');\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null; // If cancelled then stop immediately.\n\n    if (isDone) {\n      return;\n    } // Remove from selector.\n\n\n    if (selectors.from) {\n      removeAttributes(element, selectors.from);\n      selectors.from = undefined;\n    } // Process transition to attribute.\n\n\n    name = transitionName + '.to';\n    value = element.getAttribute(name); // Parse and apply returned selector.\n\n    if (value) {\n      selectors.to = parseSelector(value);\n      addAttributes(element, selectors.to);\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n      // Dispatch end event.\n      dispatchEvent('end'); // Invoke callback.\n\n      if (callback) {\n        callback();\n      } // Mark as done.\n\n\n      isDone = true;\n      return;\n    } // Get computes style.\n\n\n    const styles = getComputedStyle(element);\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;\n\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000;\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null; // If cancelled then stop immediately.\n\n      if (isDone) {\n        return;\n      } // Remove during selector.\n\n\n      if (selectors.during) {\n        removeAttributes(element, selectors.during);\n        selectors.during = undefined;\n      } // Remove to selector.\n\n\n      if (selectors.to) {\n        removeAttributes(element, selectors.to);\n        selectors.to = undefined;\n      } // Dispatch end event.\n\n\n      dispatchEvent('end'); // Invoke callback.\n\n      if (callback) {\n        callback();\n      } // Mark as done.\n\n\n      isDone = true;\n    }, duration);\n  });\n  return () => {\n    if (!isDone) {\n      return;\n    }\n\n    isDone = true; // Remove applied selector.\n\n    if (selectors.during) {\n      removeAttributes(element, selectors.during);\n      selectors.during = undefined;\n    }\n\n    if (selectors.from) {\n      removeAttributes(element, selectors.from);\n      selectors.from = undefined;\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to);\n      selectors.to = undefined;\n    } // Clear request animation frame and timeout.\n\n\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame);\n      requestFrame = null;\n    } else if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    } // Dispatch end event.\n\n\n    dispatchEvent('end'); // Invoke callback.\n\n    if (callback) {\n      callback();\n    }\n  };\n};\n/**\n * Transition an element in.\n * @param {Component} component Component the transitioning element is part of.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n */\n\nexport const transitionIn = (component, element, callback) => {\n  return transition('in', component, element, callback);\n};\n/**\n * Transition an element out.\n * @param {Component} component Component the transitioning element is part of.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n */\n\nexport const transitionOut = (component, element, callback) => {\n  return transition('out', component, element, callback);\n};\nexport default {\n  transition: transition,\n  transitionIn: transitionIn,\n  transitionOut: transitionOut\n};", "// Import symbols.\nimport { COMPONENT } from './symbols.js'; // Import classes.\n\nimport Attribute from './Attribute.js'; // Import proxy dispatcher.\n\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'; // Import utils.\n\nimport { morphTree } from '@doars/common/src/utils/Morph.js';\nimport { closestComponent } from './utils/Component.js';\nimport { transition, transitionIn, transitionOut } from '@doars/common/src/utils/Transition.js';\nimport { walk } from '@doars/common/src/utils/Element.js';\nexport default class Component {\n  /**\n   * Create instance.\n   * @param {Doars} library Library instance.\n   * @param {HTMLElement} element Element.\n   */\n  constructor(library, element) {\n    // Create unique ID.\n    const id = Symbol('ID_COMPONENT'); // Deconstruct library options.\n\n    const {\n      prefix,\n      processor\n    } = library.getOptions(); // Get the expression processor.\n\n    const processorType = typeof processor;\n    let processExpression;\n\n    if (processorType === 'function') {\n      processExpression = processor;\n    } else if (processorType === 'string' && library.constructor[processor + 'Expression']) {\n      processExpression = library.constructor[processor + 'Expression'];\n    } else {\n      console.warn('Doars: Expression processor not found. Using fallback instead.');\n      processExpression = library.constructor.executeExpression ?? library.constructor.interpretExpression ?? library.constructor.callExpression;\n    }\n\n    if (!processExpression) {\n      console.error('Doars: No expression processor available. Process option: ', process);\n    } // Create a immutable object with the directive utilities.\n\n\n    const directiveUtils = Object.freeze({\n      morphTree: morphTree,\n      processExpression: processExpression,\n      transition: transition,\n      transitionIn: transitionIn,\n      transitionOut: transitionOut\n    }); // create private variables.\n\n    let attributes = [],\n        hasUpdated = false,\n        isInitialized = false,\n        data,\n        proxy,\n        state; // Check if element has a state attribute.\n\n    if (!element.attributes[prefix + '-state']) {\n      console.error('Doars: element given to component does not contain a state attribute!');\n      return;\n    } // Add reference to element.\n\n\n    element[COMPONENT] = this; // Update position in hierarchy.\n\n    const children = []; // Get current parent component.\n\n    let parent = closestComponent(element);\n\n    if (parent) {\n      // Add to list of children in parent.\n      if (!parent.getChildren().includes(this)) {\n        parent.getChildren().push(this); // Trigger children update.\n\n        library.update([{\n          id: parent.getId(),\n          path: 'children'\n        }]);\n      }\n    }\n    /**\n     * Get the attributes in this component.\n     * @returns {Array<Attribute>} List of attributes.\n     */\n\n\n    this.getAttributes = () => {\n      return attributes;\n    };\n    /**\n     * Get child components in hierarchy of this component.\n     * @returns {Array<Component>} List of components.\n     */\n\n\n    this.getChildren = () => {\n      return children;\n    };\n    /**\n     * Get root element of the component.\n     * @returns {HTMLElement} Element.\n     */\n\n\n    this.getElement = () => {\n      return element;\n    };\n    /**\n     * Get component id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get the library instance this component is from.\n     * @returns {Doars} Doars instance.\n     */\n\n\n    this.getLibrary = () => {\n      return library;\n    };\n    /**\n     * Get parent component in hierarchy of this component.\n     * @returns {Component} Component.\n     */\n\n\n    this.getParent = () => {\n      return parent;\n    };\n    /**\n     * Get the event dispatcher of state's proxy.\n     * @returns {ProxyDispatcher} State's proxy dispatcher.\n     */\n\n\n    this.getProxy = () => {\n      return proxy;\n    };\n    /**\n     * Get the component's state.\n     * @returns {Proxy} State.\n     */\n\n\n    this.getState = () => {\n      return state;\n    };\n    /**\n     * Set new parent component of this component.\n     * @param {Component} _parent Parent component.\n     */\n\n\n    this.setParent = _parent => {\n      parent = _parent;\n    };\n    /**\n     * Initialize the component.\n     */\n\n\n    this.initialize = () => {\n      if (isInitialized) {\n        return;\n      } // Set as enabled.\n\n\n      isInitialized = true; // Get component's state attribute.\n\n      const componentName = prefix + '-state';\n      const value = element.attributes[componentName].value; // Process expression for generating the state using a mock attribute.\n\n      data = processExpression(this, new Attribute(this, element, null, value), value);\n\n      if (data === null) {\n        data = {};\n      } else if (typeof data !== 'object' || Array.isArray(data)) {\n        console.error('Doars: component tag must return an object!');\n        return;\n      } // Create proxy dispatcher for state.\n\n\n      proxy = new ProxyDispatcher(); // Add data to dispatcher to create the state.\n\n      state = proxy.add(data); // Scan for attributes.\n\n      this.scanAttributes(element);\n    };\n    /**\n     * Destroy the component.\n     */\n\n\n    this.destroy = () => {\n      if (!isInitialized) {\n        return;\n      }\n\n      if (attributes.length > 0) {\n        // Filter out directives without a destroy function.\n        const directives = library.getDirectivesObject();\n\n        for (const key in directives) {\n          if (!directives[key].destroy) {\n            directives[key] = undefined;\n          }\n        }\n\n        for (const attribute of attributes) {\n          // Clean up attribute if the directive has a destroy function.\n          const directive = directives[attribute.getKey()];\n\n          if (directive) {\n            directive.destroy(this, attribute, directiveUtils);\n          } // Destroy the attribute.\n\n\n          attribute.destroy();\n        }\n      } // Remove reference from element.\n\n\n      delete element[COMPONENT]; // Reset variables.\n\n      attributes = []; // Set as not initialized.\n\n      isInitialized = false; // Remove state and state handling.\n\n      proxy.remove(data);\n      state = null;\n      proxy = null;\n      data = null; // Store update triggers.\n\n      const triggers = []; // Set children as children of parent.\n\n      if (children.length > 0) {\n        for (const child of children) {\n          // Set new parent of children.\n          child.setParent(parent); // Add parent update trigger.\n\n          triggers.push({\n            id: child.getId(),\n            path: 'parent'\n          });\n        } // Add children update trigger.\n\n\n        triggers.push({\n          id: id,\n          path: 'children'\n        });\n      }\n\n      if (parent) {\n        if (children.length > 0) {\n          // Add children to parent.\n          parent.getChildren().push(...children); // Add children update trigger.\n\n          triggers.push({\n            id: parent.getId(),\n            path: 'children'\n          });\n        } // Add parent update trigger.\n\n\n        triggers.push({\n          id: id,\n          path: 'parent'\n        });\n      } // Dispatch triggers.\n\n\n      if (triggers.length > 0) {\n        library.update(triggers);\n      } // Dispatch event.\n\n\n      dispatchEvent('destroyed', {\n        element: element,\n        id: id\n      });\n    };\n    /**\n     * Create and add an attribute. Assumes this attribute has not been added before.\n     * @param {HTMLElement} element Attribute element.\n     * @param {String} name Name of the attribute.\n     * @param {String} value Value of the attribute.\n     * @returns {Attribute} New attribute.\n     */\n\n\n    this.addAttribute = (element, name, value) => {\n      // Get directive keys from library.\n      const directivesKeys = library.getDirectivesNames(); // Create and add attribute.\n\n      const attribute = new Attribute(this, element, name, value); // Get index to add attribute at.\n\n      let index = attribute.length;\n      const directiveIndex = directivesKeys.indexOf(attribute.getDirective());\n\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        // If the other attribute is further down the keys list than add it after that item.\n        if (directivesKeys.indexOf(attributes[i].getDirective()) <= directiveIndex) {\n          index = i + 1;\n          break;\n        }\n      } // Add to list of attributes.\n\n\n      attributes.splice(index, 0, attribute); // Return new attribute.\n\n      return attribute;\n    };\n    /**\n     * Remove an attribute.\n     * @param {Attribute} attribute The attribute to remove.\n     */\n\n\n    this.removeAttribute = attribute => {\n      // Get index of attribute in list.\n      const indexInAttributes = attributes.indexOf(attribute);\n\n      if (indexInAttributes < 0) {\n        return;\n      } // Get directives.\n\n\n      const directives = library.getDirectivesObject; // Attribute has been removed, call the destroy directive.\n\n      const directive = directives[attribute.getKey()];\n\n      if (directive && directive.destroy) {\n        directive.destroy(this, attribute, directiveUtils);\n      } // Remove attribute from list.\n\n\n      attributes.splice(indexInAttributes, 1); // Destroy attribute.\n\n      attribute.destroy();\n    };\n    /**\n     * Scans element for new attributes. It assumes this element as not been read before and is part of the component.\n     * @param {HTMLElement} element Element to scan.\n     * @returns {Array<Attribute>} New attributes.\n     */\n\n\n    this.scanAttributes = element => {\n      // Get component's state attribute.\n      const componentName = prefix + '-state';\n      const ignoreName = prefix + '-ignore'; // Store new attributes.\n\n      const newAttributes = []; // Create iterator for walking over all elements in the component, skipping elements that are components or contain the ignore directive.\n\n      const iterator = walk(element, element => !element.hasAttribute(componentName) && !element.hasAttribute(ignoreName)); // Start on the given element then continue iterating over all children.\n\n      do {\n        for (const {\n          name,\n          value\n        } of element.attributes) {\n          // Skip attribute if it is not that of a directive.\n          if (library.isDirectiveName(name)) {\n            newAttributes.push(this.addAttribute(element, name, value));\n          }\n        }\n      } while (element = iterator()); // Return new attributes.\n\n\n      return newAttributes;\n    };\n    /**\n     * Update an attribute.\n     * @param {Attribute} attribute The attribute to update.\n     */\n\n\n    this.updateAttribute = attribute => {\n      // Check if the attribute is still relevant, since the attribute or element could have been removed.\n      if (!attribute.getElement() || attribute.getValue() === null || attribute.getValue() === undefined) {\n        this.removeAttribute(attribute);\n        return;\n      } // Get directives.\n\n\n      const directives = library.getDirectivesObject(); // Clear accessed.\n\n      attribute.clearAccessed(); // Process directive on attribute.\n\n      const directive = directives[attribute.getDirective()];\n\n      if (directive) {\n        directive.update(this, attribute, directiveUtils);\n      }\n    };\n    /**\n     * Update the specified attributes of the component.\n     * @param {Array<Attribute>} attributes Attributes to update.\n     */\n\n\n    this.updateAttributes = attributes => {\n      if (!isInitialized || attributes.length <= 0) {\n        if (!hasUpdated) {\n          // Dispatch updated event anyway.\n          hasUpdated = true;\n          dispatchEvent('updated', {\n            attributes: attributes,\n            element: element,\n            id: id\n          });\n        }\n\n        return;\n      }\n\n      for (const attribute of attributes) {\n        this.updateAttribute(attribute);\n      } // Dispatch updated event.\n\n\n      hasUpdated = true;\n      dispatchEvent('updated', {\n        attributes: attributes,\n        element: element,\n        id: id\n      });\n    };\n    /**\n     * Start updating the component's attributes.\n     * @param {Array<Object>} triggers List of triggers.\n     */\n\n\n    this.update = triggers => {\n      if (!isInitialized) {\n        return;\n      } // Get all ids of triggers.\n\n\n      const triggerIds = Object.getOwnPropertySymbols(triggers); // Update all attributes whose accessed items match any update trigger.\n\n      const updatedAttributes = [];\n\n      for (const attribute of attributes) {\n        for (const id of triggerIds) {\n          if (attribute.hasAccessed(id, triggers[id])) {\n            this.updateAttribute(attribute);\n            updatedAttributes.push(attribute);\n          }\n        }\n      } // Dispatch updated event.\n\n\n      if (!hasUpdated || updatedAttributes.length > 0) {\n        hasUpdated = true;\n        dispatchEvent('updated', {\n          attributes: updatedAttributes,\n          element: element,\n          id: id\n        });\n      }\n    };\n    /**\n     * Dispatch an event from this component.\n     * @param {String} name Name of the event.\n     */\n\n\n    const dispatchEvent = (name, detail) => {\n      element.dispatchEvent(new CustomEvent(prefix + '-' + name, {\n        detail: detail,\n        bubbles: true\n      }));\n    };\n  }\n\n}", "export default {\n  name: '$children',\n  create: (component, attribute, update, {\n    createContextsProxy,\n    RevocableProxy\n  }) => {\n    // Create contexts proxy for children.\n    let children;\n    const revocable = RevocableProxy(component.getChildren(), {\n      get: (target, key, receiver) => {\n        if (!children) {\n          // Create list of child contexts.\n          children = target.map(child => createContextsProxy(child, attribute, update)); // Set children of this component as accessed.\n\n          attribute.accessed(component.getId(), 'children');\n        } // If not a number then do a normal access.\n\n\n        if (isNaN(key)) {\n          return Reflect.get(children, key, receiver);\n        } // Return context from child.\n\n\n        const child = Reflect.get(children, key, receiver);\n\n        if (child) {\n          return child.contexts;\n        }\n      }\n    });\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        // Call destroy on all created contexts.\n        if (children) {\n          children.forEach(child => child.destroy());\n        } // Revoke proxy.\n\n\n        revocable.revoke();\n      }\n    };\n  }\n};", "export default {\n  name: '$component',\n  create: component => {\n    // Return the component's element.\n    return {\n      value: component.getElement()\n    };\n  }\n};", "export default {\n  name: '$element',\n  create: (component, attribute) => {\n    // Return the attribute's element.\n    return {\n      value: attribute.getElement()\n    };\n  }\n};", "export default {\n  name: '$dispatch',\n  create: component => {\n    // Return the dispatch method.\n    return {\n      value: (name, detail = {}) => {\n        // Dispatch the event after the elements have updated.\n        component.getElement().dispatchEvent(new CustomEvent(name, {\n          detail: detail,\n          bubbles: true\n        }));\n      }\n    };\n  }\n};", "// Import symbols.\nimport { FOR } from '../symbols.js';\nexport default {\n  deconstruct: true,\n  name: '$for',\n  create: (component, attribute, update, {\n    RevocableProxy\n  }) => {\n    // Exit early in parent contexts.\n    if (component !== attribute.getComponent()) {\n      return;\n    } // Deconstruct attribute.\n\n\n    let element = attribute.getElement(); // Walk up the tree until the component's root element is found.\n\n    const componentElement = component.getElement(),\n          items = [],\n          target = {};\n\n    while (element && !element.isSameNode(componentElement)) {\n      // Check if element has for symbol.\n      const data = element[FOR];\n\n      if (data) {\n        items.push(data);\n\n        for (const key in data.variables) {\n          target[key] = data.variables[key];\n        }\n      } // Go up the document tree.\n\n\n      element = element.parentNode;\n    }\n\n    if (items.length === 0) {\n      return;\n    } // Create revocable proxy.\n\n\n    const revocable = RevocableProxy(target, {\n      get: (target, key) => {\n        for (const item of items) {\n          if (key in item.variables) {\n            // Mark as accessed for data.\n            attribute.accessed(item.id, '$for'); // Return value at key.\n\n            return item.variables[key];\n          }\n        }\n      }\n    }); // Set keys and return values.\n\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        revocable.revoke();\n      }\n    };\n  }\n};", "export default {\n  name: '$inContext',\n  create: (component, attribute, update, {\n    createContexts\n  }) => {\n    return {\n      value: callback => {\n        // Collect update triggers.\n        const triggers = [];\n\n        const contextUpdate = (id, context) => {\n          triggers.push({\n            id: id,\n            path: context\n          });\n        }; // Create contexts.\n\n\n        const {\n          contexts,\n          destroy\n        } = createContexts(component, attribute, contextUpdate, {}); // Invoke callback and store its result.\n\n        const result = callback(contexts); // Destroy contexts.\n\n        destroy(); // Dispatch update triggers.\n\n        if (triggers.length > 0) {\n          component.getLibrary().update(triggers);\n        } // Return callback's result.\n\n\n        return result;\n      }\n    };\n  }\n};", "export default {\n  name: '$nextTick',\n  create: (component, attribute, update, {\n    createContexts\n  }) => {\n    // Keep track of callbacks.\n    let callbacks; // The setup process is delayed since we only want this code to run if the context is used.\n\n    let isSetup = false;\n\n    const setup = () => {\n      // Exit early if already setup.\n      if (isSetup) {\n        return;\n      }\n\n      isSetup = true; // Deconstruct component.\n\n      const library = component.getLibrary(); // Setup callbacks list.\n\n      callbacks = []; // Remove and invoke each callback in the list.\n\n      const handleUpdate = () => {\n        // Stop listening the update has happened.\n        stopListening(); // Create function context.\n\n        const {\n          contexts,\n          destroy\n        } = createContexts(component, attribute, update, {}); // Invoke all callbacks.\n\n        for (const callback of callbacks) {\n          callback(contexts);\n        } // Destroy contexts.\n\n\n        destroy();\n      }; // Stop listening for the update event and attribute changes.\n\n\n      const stopListening = () => {\n        // Stop listening for updated event.\n        library.removeEventListener('updated', handleUpdate); // Remove self from listening.\n\n        attribute.removeEventListener('changed', stopListening);\n        attribute.removeEventListener('destroyed', stopListening);\n      }; // Listen to the libraries updated event.\n\n\n      library.addEventListener('updated', handleUpdate); // Stop listening if the attribute changes since this directive will be run again.\n\n      attribute.addEventListener('changed', stopListening);\n      attribute.addEventListener('destroyed', stopListening);\n    };\n\n    return {\n      value: callback => {\n        // Do delayed setup now.\n        setup(); // Add callback to list.\n\n        callbacks.push(callback);\n      }\n    };\n  }\n};", "export default {\n  name: '$parent',\n  create: (component, attribute, update, {\n    createContextsProxy\n  }) => {\n    // Deconstruct component.\n    const parent = component.getParent();\n\n    if (!parent) {\n      return {\n        key: '$parent',\n        value: null\n      };\n    } // Create contexts proxy for parent.\n\n\n    const {\n      contexts,\n      destroy\n    } = createContextsProxy(parent, attribute, update);\n    return {\n      value: contexts,\n      destroy: destroy\n    };\n  }\n};", "// Import symbols.\nimport { REFERENCES, REFERENCES_CACHE } from '../symbols.js';\nexport default {\n  name: '$references',\n  create: (component, attribute, update, {\n    RevocableProxy\n  }) => {\n    // Exit early if no references exist.\n    if (!component[REFERENCES]) {\n      return {\n        key: '$references',\n        value: []\n      };\n    } // Generate references cache.\n\n\n    let cache = component[REFERENCES_CACHE];\n\n    if (!cache) {\n      // Get references from component.\n      const references = component[REFERENCES];\n      const attributeIds = Object.getOwnPropertySymbols(references); // Convert references to a named object.\n\n      cache = {};\n\n      for (const id of attributeIds) {\n        const {\n          element,\n          name\n        } = references[id];\n        cache[name] = element;\n      }\n\n      component[REFERENCES_CACHE] = cache;\n    } // Create revocable proxy.\n\n\n    const revocable = RevocableProxy(cache, {\n      get: (target, propertyKey, receiver) => {\n        // Mark references as accessed.\n        attribute.accessed(component.getId(), '$references.' + propertyKey); // Return reference.\n\n        return Reflect.get(target, propertyKey, receiver);\n      }\n    }); // Return references proxy.\n\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        revocable.revoke();\n      }\n    };\n  }\n};", "export default {\n  deconstruct: true,\n  name: '$state',\n  create: (component, attribute, update, {\n    RevocableProxy\n  }) => {\n    // Deconstruct component.\n    const proxy = component.getProxy();\n    const state = component.getState();\n\n    if (!proxy || !state) {\n      return;\n    } // Create event handlers.\n\n\n    const onDelete = (target, path) => update(component.getId(), '$state.' + path.join('.'));\n\n    const onGet = (target, path) => attribute.accessed(component.getId(), '$state.' + path.join('.'));\n\n    const onSet = (target, path) => update(component.getId(), '$state.' + path.join('.')); // Add event listeners.\n\n\n    proxy.addEventListener('delete', onDelete);\n    proxy.addEventListener('get', onGet);\n    proxy.addEventListener('set', onSet); // Wrap in a revocable proxy.\n\n    const revocable = RevocableProxy(state, {});\n    return {\n      value: revocable.proxy,\n      // Remove event listeners.\n      destroy: () => {\n        proxy.removeEventListener('delete', onDelete);\n        proxy.removeEventListener('get', onGet);\n        proxy.removeEventListener('set', onSet); // Revoke access to state.\n\n        revocable.revoke();\n      }\n    };\n  }\n};", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function\n/* A native object */\n).replace('Function', 'Promise') // Replace identifier.\n.replace(/\\(.*\\)/, '()'); // Remove possible FormalParameterList.\n\nexport const isNativePromise = value => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise;\n};\nexport const isPromise = value => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]';\n};\nexport default {\n  isPromise: isPromise,\n  isNativePromise: isNativePromise\n};", "// Import utils.\nimport { setAttribute, setAttributes } from '@doars/common/src/utils/Attribute.js';\nimport { isPromise } from '@doars/common/src/utils/Promise.js';\nimport { parseSelector } from '@doars/common/src/utils/String.js';\nexport default {\n  name: 'attribute',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = value => {\n      if (modifiers.selector) {\n        if (typeof value !== 'string') {\n          console.error('Doars: Value returned to attribute directive must be a string if the selector modifier is set.');\n          return;\n        }\n\n        value = parseSelector(value);\n        setAttributes(element, value);\n        return;\n      } // Deconstruct attribute.\n\n\n      const key = attribute.getKeyRaw();\n\n      if (!key) {\n        // Set attributes on element.\n        if (typeof value === 'object' && !Array.isArray(value)) {\n          setAttributes(element, value);\n        } else {\n          console.error('Doars: Value returned to attribute directive of invalid type.');\n        }\n\n        return;\n      } // Set attribute on element at key.\n\n\n      setAttribute(element, key, value);\n    }; // Execute attribute value.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "export default {\n  name: 'cloak',\n  update: function (component, attribute, {\n    transitionIn\n  }) {\n    // Deconstruct attribute.\n    const element = attribute.getElement(); // Remove attribute from element.\n\n    element.removeAttribute(component.getLibrary().getOptions().prefix + '-' + this.name); // Transition in.\n\n    transitionIn(component, element);\n  }\n};", "// Import symbols.\nimport { FOR } from '../symbols.js'; // Import utils.\n\nimport { insertAfter } from '@doars/common/src/utils/Element.js';\nimport { isPromise } from '@doars/common/src/utils/Promise.js';\nimport { parseForExpression } from '@doars/common/src/utils/String.js';\nimport { transitionIn, transitionOut } from '@doars/common/src/utils/Transition.js';\n/**\n * Add values add object by name in given order.\n * @param {Array<String>} names Names of values.\n * @param  {...Any} values Values to add to object.\n * @returns {Object} Resulting object with values at names.\n */\n\nconst createVariables = (names, ...values) => {\n  const variables = {};\n\n  for (let i = 0; i < values.length; i++) {\n    if (i >= names.length) {\n      break;\n    }\n\n    variables[names[i]] = values[i];\n  }\n\n  return variables;\n};\n/**\n * Finds the index of an element in list matching the value.\n * @param {HTMLElement} elements List of elements to search through.\n * @param {Any} value Value to compare to.\n * @param {Number} index The index to start searching after.\n */\n\n\nconst indexInSiblings = (elements, value, index = -1) => {\n  index++;\n\n  if (index >= elements.length) {\n    return -1;\n  }\n\n  if (elements[index][FOR].value === value) {\n    return index;\n  }\n\n  return indexInSiblings(elements, value, index);\n};\n/**\n * Adds item to document at right index.\n * @param {Component} component Component attribute is part of.\n * @param {Function} update Update trigger function.\n * @param {DocumentFragment} template Template of items.\n * @param {Array<HTMLElement>} elements Existing item elements.\n * @param {Number} index Index to start looking from.\n * @param {Any} value Value of item to add.\n * @param {Object} variables Variables associated with item.\n */\n\n\nconst setAfter = (component, update, template, elements, index, value, variables) => {\n  const existingIndex = indexInSiblings(elements, value, index);\n\n  if (existingIndex >= 0) {\n    // Exit early it is already in place.\n    if (existingIndex === index + 1) {\n      return;\n    } // Get existing element to move.\n\n\n    const element = elements[existingIndex]; // Move element after element at index or directly after the template.\n\n    insertAfter(elements[index] ? elements[index] : template, element); // Update all attributes using this for item's data.\n\n    update(element[FOR].id);\n    return;\n  } // Create new element from template.\n\n\n  let element = document.importNode(template.content, true); // Add element after template or element at index.\n\n  const sibling = index === -1 ? template : elements[index];\n  insertAfter(sibling, element); // Get HTMLElement reference instead of DocumentFragment.\n\n  element = sibling.nextElementSibling; // Transition in.\n\n  transitionIn(component, element); // Store data.\n\n  element[FOR] = {\n    id: Symbol('ID_FOR'),\n    value: value,\n    variables: variables\n  }; // Store reference.\n\n  elements.splice(index + 1, 0, element);\n};\n/**\n * Removes elements after maximum length.\n * @param {Array<HTMLElement>} elements List of existing elements.\n * @param {Number} maxLength Maximum number of elements.\n */\n\n\nconst removeAfter = (component, elements, maxLength) => {\n  // Exit early if length is not exceeded.\n  if (elements.length < maxLength) {\n    return;\n  } // Iterate over exceeding elements.\n\n\n  for (let i = elements.length - 1; i >= maxLength; i--) {\n    // Remove element from list.\n    const element = elements[i];\n    elements.splice(i, 1); // Transition out.\n\n    transitionOut(component, element, () => {\n      element.remove();\n    });\n  }\n};\n\nexport default {\n  name: 'for',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const template = attribute.getElement(); // Check if placed on a template tag.\n\n    if (template.tagName !== 'TEMPLATE') {\n      console.warn('Doars: `for` directive must be placed on a `<template>` tag.');\n      return;\n    }\n\n    const expression = parseForExpression(attribute.getValue());\n\n    if (!expression) {\n      console.error('Doars: Error in `for` expression: ', attribute.getValue());\n      return;\n    } // Setup update method.\n\n\n    const triggers = {};\n\n    const update = id => {\n      if (!triggers[id]) {\n        triggers[id] = ['$for'];\n      }\n    };\n\n    const set = iterable => {\n      // Get stored data.\n      const data = attribute.getData(); // Get list of elements already made by this attribute.\n\n      const elements = data.elements ? data.elements : []; // Process iterable based on type.\n\n      const iterableType = typeof iterable;\n\n      if (iterableType === 'number') {\n        for (let index = 0; index < iterable; index++) {\n          // Setup variables for context.\n          const variables = createVariables(expression.variables, index); // Add element based on data after previously iterated value.\n\n          setAfter(component, update, template, elements, index - 1, iterable, variables);\n        } // Remove old values.\n\n\n        removeAfter(component, elements, iterable);\n      } else if (iterableType === 'string') {\n        for (let index = 0; index < iterable.length; index++) {\n          // Get value at index.\n          const value = iterable[index]; // Setup variables for context.\n\n          const variables = createVariables(expression.variables, value, index); // Add element based on data after previously iterated value.\n\n          setAfter(component, update, template, elements, index - 1, value, variables);\n        } // Remove old values.\n\n\n        removeAfter(component, elements, iterable.length);\n      } else {\n        // We can't rely on Array.isArray since it might be a proxy, therefore we try to convert it to an array.\n        let isArray, length;\n\n        try {\n          const values = [...iterable];\n          isArray = true;\n          length = values.length;\n        } catch {}\n\n        if (isArray) {\n          for (let index = 0; index < length; index++) {\n            // Get value at index.\n            const value = iterable[index]; // Setup variables for context.\n\n            const variables = createVariables(expression.variables, value, index); // Add element based on data after previously iterated value.\n\n            setAfter(component, update, template, elements, index - 1, value, variables);\n          }\n        } else {\n          const keys = Object.keys(iterable);\n          length = keys.length;\n\n          for (let index = 0; index < length; index++) {\n            // Get value at index.\n            const key = keys[index];\n            const value = iterable[key]; // Setup variables for context.\n\n            const variables = createVariables(expression.variables, key, value, index); // Add element based on data after previously iterated value.\n\n            setAfter(component, update, template, elements, index - 1, value, variables);\n          }\n        } // Remove old values.\n\n\n        removeAfter(component, elements, length);\n      } // Dispatch triggers.\n\n\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        component.update(triggers);\n      } // Store results.\n\n\n      attribute.setData(Object.assign({}, data, {\n        elements: elements\n      }));\n    }; // Get iterable value.\n\n\n    let result; // Check if iterable is a number.\n\n    if (!isNaN(expression.iterable)) {\n      result = Number(expression.iterable);\n    } else {\n      // Get iterable data, and this will automatically mark the data as being accessed by this component.\n      result = processExpression(component, attribute, expression.iterable);\n    } // Get stored data.\n\n\n    const data = attribute.getData(); // Store results.\n\n    attribute.setData(Object.assign({}, data, {\n      result: result\n    })); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData().result !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  },\n  destroy: (component, attribute) => {\n    // Get stored data.\n    const data = attribute.getData(); // Get list of elements created by this attribute.\n\n    if (data.elements) {\n      // Iterate over generated elements.\n      for (const element of data.elements) {\n        // Transition out.\n        transitionOut(component, element, () => {\n          // Remove element.\n          element.remove();\n        });\n      }\n    }\n  }\n};", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"'\n};\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;'\n};\nconst ENCODE_REGEXP = /[&<>'\"]/g;\nexport const decode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(DECODE_REGEXP, character => {\n    return DECODE_LOOKUP[character];\n  });\n};\nexport const encode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, character => {\n    return ENCODE_LOOKUP[character];\n  });\n};\nexport default {\n  decode: decode,\n  encode: encode\n};", "// Import utils.\nimport { decode } from '@doars/common/src/utils/Html.js';\nimport { isPromise } from '@doars/common/src/utils/Promise.js';\nexport default {\n  name: 'html',\n  update: (component, attribute, {\n    processExpression,\n    morphTree\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = html => {\n      // Decode string.\n      if (modifiers.decode && typeof html === 'string') {\n        html = decode(html);\n      } // Morph if morph modifier is set.\n\n\n      if (modifiers.morph) {\n        // Ensure element only has one child.\n        if (element.children.length === 0) {\n          element.appendChild(document.createElement('div'));\n        } else if (element.children.length > 1) {\n          for (let i = element.children.length - 1; i >= 1; i--) {\n            element.children[i].remove();\n          }\n        } // Morph first child to given element tree.\n\n\n        const root = morphTree(element.children[0], html);\n\n        if (!element.children[0].isSameNode(root)) {\n          element.children[0].remove();\n          element.appendChild(root);\n        }\n\n        return;\n      } // Clone and set html as only child for HTMLElements.\n\n\n      if (html instanceof HTMLElement) {\n        for (const child of element.children) {\n          child.remove();\n        }\n\n        element.appendChild(html.cloneNode(true));\n        return;\n      } // Set html via inner html for strings.\n\n\n      if (typeof html === 'string') {\n        if (element.innerHTML !== html) {\n          element.innerHTML = html;\n        }\n\n        return;\n      }\n\n      console.error('Doars/directives/html: Unknown type returned to directive!');\n    }; // Execute value and retrieve result.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "// Import utils.\nimport { insertAfter } from '@doars/common/src/utils/Element.js';\nimport { isPromise } from '@doars/common/src/utils/Promise.js';\nexport default {\n  name: 'if',\n  update: (component, attribute, {\n    processExpression,\n    transitionIn,\n    transitionOut\n  }) => {\n    // Deconstruct attribute.\n    const template = attribute.getElement(); // Check if placed on a template tag.\n\n    if (template.tagName !== 'TEMPLATE') {\n      console.warn('Doars: `if` directive must be placed on a `<template>` tag.');\n      return;\n    } // Check if it only has one child.\n\n\n    if (template.childCount > 1) {\n      console.warn('Doars: `if` directive must have a single child node.');\n      return;\n    }\n\n    const set = result => {\n      // Get stored data.\n      const data = attribute.getData(); // Get existing reference element.\n\n      let element = data.element;\n      let transition = data.transition;\n\n      if (!result) {\n        // If the element exists then transition out and remove the element.\n        if (element) {\n          // Cancel previous transition.\n          if (transition) {\n            transition();\n          }\n\n          transition = transitionOut(component, element, () => {\n            element.remove();\n          });\n        }\n      } else if (!element) {\n        // If the reference does not exist create the element.\n        // Cancel previous transition.\n        if (transition) {\n          transition();\n        } // Create new element from template.\n\n\n        element = document.importNode(template.content, true); // Add element after the template element.\n\n        insertAfter(template, element); // Get HTMLElement reference instead of DocumentFragment.\n\n        element = template.nextElementSibling; // Transition element in.\n\n        transition = transitionIn(component, element);\n      } // Store results.\n\n\n      attribute.setData(Object.assign({}, data, {\n        element: element,\n        transition: transition\n      }));\n    }; // Execute expression.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Get stored data.\n\n    const data = attribute.getData(); // Store results.\n\n    attribute.setData(Object.assign({}, data, {\n      result: result\n    })); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(result => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData().result !== result) {\n          return;\n        }\n\n        set(result);\n      });\n    } else {\n      set(result);\n    }\n  },\n  destroy: (component, attribute, {\n    transitionOut\n  }) => {\n    // Get stored data.\n    const data = attribute.getData(); // If the element exists then transition out and remove the element.\n\n    if (data.element) {\n      transitionOut(component, data.element, () => {\n        data.element.remove();\n      });\n    }\n  }\n};", "// Import symbols.\nimport { INITIALIZED } from '../symbols.js';\n\nconst destroy = (component, attribute) => {\n  // Exit early if no listeners can be found.\n  if (!attribute[INITIALIZED]) {\n    return;\n  } // Deconstruct component.\n\n\n  const element = component.getElement(); // Create event name.\n\n  const name = component.getLibrary().getOptions().prefix + '-updated'; // Remove existing listener and delete directive data.\n\n  element.removeEventListener(name, attribute[INITIALIZED].handler);\n  delete attribute[INITIALIZED];\n};\n\nexport default {\n  name: 'initialized',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct component.\n    const element = component.getElement(); // Deconstruct attribute.\n\n    const value = attribute.getValue(); // Create event name.\n\n    const name = component.getLibrary().getOptions().prefix + '-updated'; // Check if existing listener exists.\n\n    if (attribute[INITIALIZED]) {\n      // Exit early if listener has not changed.\n      if (attribute[INITIALIZED].value === value) {\n        return;\n      } // Remove existing listener so we don' listen twice.\n\n\n      element.removeEventListener(name, attribute[INITIALIZED].handler);\n      delete attribute[INITIALIZED];\n    }\n\n    const handler = ({\n      detail\n    }) => {\n      // Only execute on self.\n      if (detail.element !== element) {\n        return;\n      } // Execute value using a copy of the attribute since this attribute does not need to update based on what it accesses.\n\n\n      processExpression(component, attribute.clone(), value, {}, {\n        return: false\n      }); // Call destroy.\n\n      destroy(component, attribute);\n    }; // Add listener to component.\n\n\n    element.addEventListener(name, handler, {\n      once: true\n    }); // Store listener data on the component.\n\n    attribute[INITIALIZED] = {\n      handler: handler,\n      value: value\n    };\n  },\n  destroy: destroy\n};", "// Import symbols.\nimport { ON } from '../symbols.js'; // Declare constants.\n\nconst CANCEL_EVENTS = {\n  keydown: 'keyup',\n  mousedown: 'mouseup',\n  pointerdown: 'pointerup'\n};\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  HELD: 3,\n  HOLD: 4,\n  THROTTLE: 5\n};\nconst KEYPRESS_MODIFIERS = ['alt', 'ctrl', 'meta', 'shift'];\nexport default {\n  name: 'on',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    let name = attribute.getKeyRaw(); // Check if required key is set.\n\n    if (!name) {\n      console.warn('Doars: `on` directive must have a key.');\n      return;\n    } // Process keyboard events.\n\n\n    let key;\n\n    if (name.startsWith('keydown-')) {\n      key = name.substring(8).toLowerCase();\n      name = 'keydown';\n    } else if (name.startsWith('keyup-')) {\n      key = name.substring(6).toLowerCase();\n      name = 'keyup';\n    } // Deconstruct attribute.\n\n\n    const element = attribute.getElement();\n    const value = attribute.getValue(); // Check if existing listener exists.\n\n    if (attribute[ON]) {\n      // Exit early if value has not changed.\n      if (attribute[ON].value === value) {\n        return;\n      } // Remove existing listener so we don't listen twice.\n\n\n      attribute[ON].target.removeEventListener(name, attribute[ON].handler); // Clear any ongoing timeouts.\n\n      if (attribute[ON].timeout) {\n        clearTimeout(attribute[ON].timeout);\n      } // Delete directive data.\n\n\n      delete attribute[ON];\n    } // Deconstruct attribute.\n\n\n    const modifiers = attribute.getModifiers(); // Process modifiers.\n    // Set listener options.\n\n    const options = {};\n\n    if (modifiers.capture) {\n      options.capture = true;\n    }\n\n    if (modifiers.once) {\n      options.once = true;\n    }\n\n    if (modifiers.passive) {\n      options.passive = true;\n    } // Process execution modifiers.\n\n\n    let executionModifier = EXECUTION_MODIFIERS.NONE;\n\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER;\n\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5;\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE;\n\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500;\n      }\n    } else if (modifiers.held) {\n      executionModifier = EXECUTION_MODIFIERS.HELD;\n\n      if (modifiers.held === true) {\n        modifiers.held = 500;\n      }\n    } else if (modifiers.hold) {\n      executionModifier = EXECUTION_MODIFIERS.HOLD;\n\n      if (modifiers.hold === true) {\n        modifiers.hold = 500;\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE;\n\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500;\n      }\n    } // Store keypress modifiers.\n\n\n    const keypressModifiers = [];\n\n    if (key) {\n      // Convert command and super to meta.\n      modifiers.meta = modifiers.meta ? true : modifiers.cmd || modifiers.super;\n\n      for (const modifier of KEYPRESS_MODIFIERS) {\n        if (modifiers[modifier]) {\n          keypressModifiers.push(modifier);\n        }\n      }\n    } // Set listener target and start listening.\n\n\n    let target = element;\n\n    if (modifiers.document || modifiers.outside) {\n      target = document;\n    } else if (modifiers.window) {\n      target = window;\n    }\n\n    const handler = event => {\n      // Prevent repeat calls if prevent is set.\n      if (attribute[ON].prevent) {\n        return;\n      } // Disallow repeat calls if the modifier is not present.\n\n\n      if (!modifiers.repeat && event.repeat) {\n        return;\n      } // Only fire when self is provided if the target is the element itself.\n\n\n      if (modifiers.self && event.target !== element) {\n        return;\n      } // Don't fire with outside modifier unless the event came from outside.\n\n\n      if (modifiers.outside && element.contains(event.target)) {\n        return;\n      } // For keyboard events check the key is pressed.\n\n\n      if ((name === 'keydown' || name === 'keyup') && key) {\n        // Check if all key press modifiers are held.\n        for (const keypressModifier of keypressModifiers) {\n          if (!event[keypressModifier + 'Key']) {\n            return;\n          }\n        } // Convert key.\n\n\n        let eventKey = modifiers.code ? event.code : event.key;\n\n        if (eventKey === ' ') {\n          eventKey = 'space';\n        }\n\n        eventKey = eventKey.toLowerCase(); // Check if the key matches.\n\n        if (eventKey !== key) {\n          return;\n        }\n      } // Prevent default if the prevent modifier is present.\n\n\n      if (modifiers.prevent) {\n        event.preventDefault();\n      } // Stop propagation if the stop modifier is present.\n\n\n      if (modifiers.stop) {\n        event.stopPropagation();\n      }\n\n      const execute = () => {\n        // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n        processExpression(component, attribute.clone(), value, {\n          $event: event,\n          $events: attribute[ON].buffer\n        }, {\n          return: false\n        }); // Reset the buffer.\n\n        attribute[ON].buffer = [];\n      }; // Store event in buffer.\n\n\n      attribute[ON].buffer.push(event); // Check if we need to apply an execution modifier.\n\n      switch (executionModifier) {\n        case EXECUTION_MODIFIERS.BUFFER:\n          // Exit early if buffer is not full.\n          if (attribute[ON].buffer.length < modifiers.buffer) {\n            return;\n          }\n\n          execute();\n          return;\n\n        case EXECUTION_MODIFIERS.DEBOUNCE:\n          // Clear existing timeout.\n          if (attribute[ON].timeout) {\n            clearTimeout(attribute[ON].timeout);\n            attribute[ON].timeout = null;\n          } // Setup timeout and execute expression when it finishes.\n\n\n          attribute[ON].timeout = setTimeout(execute, modifiers.debounce);\n          return;\n        // Execute the event when let go after the given time has exceeded.\n\n        case EXECUTION_MODIFIERS.HELD:\n          // Check if cancelable.\n          if (!(name in CANCEL_EVENTS)) {\n            console.warn('Doars: `on` directive, event of name \"' + name + '\" is not cancelable and can not have \"held\" modifier.');\n            return;\n          }\n\n          const cancelHeldName = CANCEL_EVENTS[name]; // Store time of holding down.\n\n          const nowHeld = window.performance.now();\n\n          attribute[ON].cancel = cancelEvent => {\n            // Check if minimum time has passed.\n            if (window.performance.now() - nowHeld < modifiers.held) {\n              attribute[ON].prevent = false;\n              return;\n            } // For keyboard events check any required key has been depressed.\n\n\n            if (cancelHeldName === 'keyup' && key) {\n              // Check if all key press modifiers are held.\n              for (const keypressModifier of keypressModifiers) {\n                if (!cancelEvent[keypressModifier + 'Key']) {\n                  attribute[ON].prevent = false;\n                  return;\n                }\n              } // Convert key.\n\n\n              let eventKey = modifiers.code ? cancelEvent.code : cancelEvent.key;\n\n              if (eventKey === ' ') {\n                eventKey = 'space';\n              }\n\n              eventKey = eventKey.toLowerCase(); // Check if the key matches.\n\n              if (eventKey !== key) {\n                attribute[ON].prevent = false;\n                return;\n              }\n            } // Only fire when self is provided if the target is the element itself.\n\n\n            if (modifiers.self && cancelEvent.target !== element) {\n              attribute[ON].prevent = false;\n              return;\n            } // Don't fire with outside modifier unless the event came from outside.\n\n\n            if (modifiers.outside && element.contains(cancelEvent.target)) {\n              attribute[ON].prevent = false;\n              return;\n            } // Execute expression.\n\n\n            execute();\n          }; // Prevent repeat calls.\n\n\n          attribute[ON].prevent = true;\n          target.addEventListener(cancelHeldName, attribute[ON].cancel, {\n            once: true\n          });\n          return;\n        // Execute event when keys have been held down for the given time.\n\n        case EXECUTION_MODIFIERS.HOLD:\n          // Check if cancelable.\n          if (!(name in CANCEL_EVENTS)) {\n            console.warn('Doars: `on` directive, event of name \"' + name + '\" is not cancelable and can not have \"hold\" modifier.');\n            return;\n          }\n\n          const cancelHoldName = CANCEL_EVENTS[name];\n\n          attribute[ON].cancel = cancelEvent => {\n            // For keyboard events check any required key has been depressed.\n            if (cancelHoldName === 'keyup' && key) {\n              let keyLetGo = false; // Check if all key press modifiers are held.\n\n              for (const keypressModifier of keypressModifiers) {\n                if (!cancelEvent[keypressModifier + 'Key']) {\n                  keyLetGo = true;\n                }\n              } // Convert key.\n\n\n              let eventKey = modifiers.code ? cancelEvent.code : cancelEvent.key;\n\n              if (eventKey === ' ') {\n                eventKey = 'space';\n              }\n\n              eventKey = eventKey.toLowerCase(); // Check if the key matches.\n\n              if (eventKey === key) {\n                keyLetGo = true;\n              }\n\n              if (!keyLetGo) {\n                attribute[ON].prevent = false;\n                return;\n              }\n            } // Only fire when self is provided if the target is the element itself.\n\n\n            if (modifiers.self && cancelEvent.target !== element) {\n              attribute[ON].prevent = false;\n              return;\n            } // Don't fire with outside modifier unless the event came from outside.\n\n\n            if (modifiers.outside && element.contains(cancelEvent.target)) {\n              attribute[ON].prevent = false;\n              return;\n            } // Prevent timeout from firing.\n\n\n            clearTimeout(attribute[ON].timeout);\n          };\n\n          target.addEventListener(cancelHoldName, attribute[ON].cancel, {\n            once: true\n          }); // Prevent repeat calls.\n\n          attribute[ON].prevent = true; // Setup timeout and execute expression when it finishes.\n\n          attribute[ON].timeout = setTimeout(() => {\n            // Ensure cancel is removed.\n            target.removeEventListener(cancelHoldName, attribute[ON].cancel); // Allow calls again.\n\n            attribute[ON].prevent = false; // Execute expression.\n\n            execute();\n          }, modifiers.hold);\n          return;\n\n        case EXECUTION_MODIFIERS.THROTTLE:\n          // Get current time in milliseconds.\n          const nowThrottle = window.performance.now(); // Exit early if throttle time has not passed.\n\n          if (attribute[ON].lastExecution && nowThrottle - attribute[ON].lastExecution < modifiers.throttle) {\n            return;\n          }\n\n          execute(); // Store new latest execution time.\n\n          attribute[ON].lastExecution = nowThrottle;\n          return;\n      } // Otherwise execute expression immediately.\n\n\n      execute();\n    };\n\n    target.addEventListener(name, handler, options); // Store listener data on the component.\n\n    attribute[ON] = {\n      buffer: [],\n      handler: handler,\n      target: target,\n      timeout: attribute[ON] ? attribute[ON].timeout : undefined,\n      value: value,\n      prevent: false\n    };\n  },\n  destroy: (component, attribute) => {\n    // Exit early if no listeners can be found.\n    if (!attribute[ON]) {\n      return;\n    } // Deconstruct attribute.\n\n\n    const key = attribute.getKeyRaw(); // Remove existing listener.\n\n    attribute[ON].target.removeEventListener(key, attribute[ON].handler); // Clear any ongoing callbacks and timeouts.\n\n    if (attribute[ON].cancel) {\n      attribute[ON].target.removeEventListener(CANCEL_EVENTS[key], attribute[ON].cancel);\n    }\n\n    if (attribute[ON].timeout) {\n      clearTimeout(attribute[ON].timeout);\n    } // Delete directive data.\n\n\n    delete attribute[ON];\n  }\n};", "// Import symbols.\nimport { REFERENCES, REFERENCES_CACHE } from '../symbols.js';\n\nconst destroy = (component, attribute) => {\n  // Exit early if not set.\n  if (!component[REFERENCES]) {\n    return;\n  } // Deconstruct attribute.\n\n\n  const attributeId = attribute.getId(); // Exit early if not the same attribute.\n\n  if (!component[REFERENCES][attributeId]) {\n    return;\n  } // Deconstruct component.\n\n\n  const library = component.getLibrary();\n  const componentId = component.getId(); // Deconstruct attribute.\n\n  const value = attribute.getValue().trim(); // Remove reference from object.\n\n  delete component[REFERENCES][attributeId]; // Remove context cache.\n\n  delete component[REFERENCES_CACHE]; // Remove object if it is empty now.\n\n  if (Object.keys(component[REFERENCES]).length === 0) {\n    delete component[REFERENCES];\n  } // Trigger references update.\n\n\n  library.update([{\n    id: componentId,\n    path: '$references.' + value\n  }]);\n};\n\nexport default {\n  name: 'reference',\n  update: (component, attribute) => {\n    // Deconstruct attribute.\n    const value = attribute.getValue().trim(); // Check if value is a valid variable name.\n\n    if (!/^[_$a-z]{1}[_\\-$a-z0-9]{0,}$/i.test(value)) {\n      destroy(component, attribute);\n      console.warn('Doars: `reference` directive\\'s value not a valid variable name: \"' + value + '\".');\n      return;\n    } // Deconstruct component.\n\n\n    const library = component.getLibrary();\n    const componentId = component.getId(); // Deconstruct attribute.\n\n    const element = attribute.getElement();\n    const attributeId = attribute.getId(); // Check if references object exists.\n\n    if (!component[REFERENCES]) {\n      component[REFERENCES] = {};\n    } // Store reference.\n\n\n    component[REFERENCES][attributeId] = {\n      element: element,\n      name: value\n    }; // Remove context cache.\n\n    delete component[REFERENCES_CACHE]; // Trigger references update.\n\n    library.update([{\n      id: componentId,\n      path: '$references.' + value\n    }]);\n  },\n  destroy: destroy\n};", "// Import utils.\nimport { isPromise } from '@doars/common/src/utils/Promise.js';\nconst TAG_SELECT = 'SELECT';\nconst CHECKED = 'checked';\nconst SELECTED = 'selected';\nconst TYPE_CHECKBOX = 'checkbox';\nexport default {\n  name: 'select',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement(); // Check if placed on a select tag.\n\n    const type = element.getAttribute('type');\n\n    if (element.tagName !== TAG_SELECT && !(element.tagName === 'INPUT' && (type === TYPE_CHECKBOX || type === 'radio'))) {\n      console.warn('Doars: `select` directive must be placed on a `select` tag or `input` of type checkbox or radio.');\n      return;\n    }\n\n    const set = data => {\n      // Iterate over the select options.\n      if (element.tagName === TAG_SELECT) {\n        for (const option of Array.from(element.options)) {\n          // Update option if the selected value has changed.\n          const select = Array.isArray(data) ? data.includes(option.value) : data === option.value;\n\n          if (option.selected !== select) {\n            // Update option's status.\n            option.selected = select; // Update option's attribute.\n\n            if (select) {\n              option.setAttribute(SELECTED, '');\n            } else {\n              option.removeAttribute(SELECTED);\n            }\n          }\n        }\n      } else if (type === TYPE_CHECKBOX) {\n        // Update option if the checked value has changed.\n        const checked = data.includes(element.value);\n\n        if (element.checked !== checked) {\n          // Update checked attribute.\n          if (checked) {\n            element.setAttribute(CHECKED, '');\n          } else {\n            element.removeAttribute(CHECKED);\n          }\n        }\n      } else {\n        // Update option if the checked value has changed.\n        const checked = data === element.value;\n\n        if (element.checked !== checked) {\n          // Update checked attribute.\n          if (checked) {\n            element.setAttribute(CHECKED, '');\n          } else {\n            element.removeAttribute(CHECKED);\n          }\n        }\n      }\n    }; // Execute attribute value.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "// Import utils.\nimport { isPromise } from '@doars/common/src/utils/Promise.js';\nexport default {\n  name: 'show',\n  update: (component, attribute, {\n    processExpression,\n    transitionIn,\n    transitionOut\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n\n    const set = () => {\n      // Get stored data.\n      const data = attribute.getData(); // Cancel previous transition.\n\n      if (data.transition) {\n        data.transition();\n      } // Assign display based on truthiness of expression result.\n\n\n      let transition;\n\n      if (data.result) {\n        element.style.display = null;\n        transition = transitionIn(component, element);\n      } else {\n        transition = transitionOut(component, element, () => {\n          element.style.display = 'none';\n        });\n      } // Store new transition.\n\n\n      attribute.setData(Object.assign({}, data, {\n        transition: transition\n      }));\n    }; // Execute attribute value.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Get stored data.\n\n    const data = attribute.getData(); // Handle promises.\n\n    if (isPromise(result)) {\n      // Store results.\n      attribute.setData(Object.assign({}, data, {\n        result: result\n      }));\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData().result !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else if (!data || data.result !== result) {\n      // Store results.\n      attribute.setData(Object.assign({}, data, {\n        result: result\n      }));\n      set();\n    }\n  }\n};", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js';\n/**\n * Create an object with utility function.\n * @returns {Object} Utils.\n */\n\nconst createContextUtils = () => {\n  return {\n    createContexts: createContexts,\n    createContextsProxy: createContextsProxy,\n    RevocableProxy: RevocableProxy\n  };\n};\n/**\n * Create component's contexts for an attributes expression.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {Function} update Called when update needs to be invoked.\n * @param {Object} extra Optional extra context items.\n * @returns {Array<Object, Function>} Expressions contexts and destroy functions.\n */\n\n\nexport const createContexts = (component, attribute, update, extra = null) => {\n  // Get library.\n  const library = component.getLibrary(); // Start with the simple contexts.\n\n  const contexts = library.getSimpleContexts();\n  let after = '',\n      before = '',\n      deconstructed = []; // Iterate over all contexts.\n\n  const creatableContexts = library.getContexts(); // Store destroy functions.\n\n  const destroyFunctions = [];\n\n  for (const creatableContext of creatableContexts) {\n    if (!creatableContext || !creatableContext.name) {\n      continue;\n    } // Get context result.\n\n\n    const result = creatableContext.create(component, attribute, update, createContextUtils());\n\n    if (!result || !result.value) {\n      continue;\n    } // Store destroy functions.\n\n\n    if (result.destroy && typeof result.destroy === 'function') {\n      destroyFunctions.push(result.destroy);\n    } // Deconstruct options if marked as such.\n\n\n    if (creatableContext.deconstruct && typeof result.value === 'object') {\n      deconstructed.push(creatableContext.name);\n      before += 'with(' + creatableContext.name + ') { ';\n      after += ' }';\n    } // Store result value in context results.\n\n\n    contexts[creatableContext.name] = result.value;\n  } // Add extra items to context.\n\n\n  if (typeof extra === 'object') {\n    for (const name in extra) {\n      contexts[name] = extra[name];\n    }\n  }\n\n  return {\n    contexts: contexts,\n    destroy: () => {\n      // Call all destroy functions.\n      for (const destroyFunction of destroyFunctions) {\n        destroyFunction(createContextUtils());\n      }\n    },\n    after: after,\n    before: before,\n    deconstructed: deconstructed\n  };\n};\n/**\n * Create component's contexts only after the context gets used.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {Object} extra Optional extra context items.\n * @param {Function} update Called when update needs to be invoked.\n * @returns {Proxy} Expressions contexts' proxy.\n */\n\nexport const createContextsProxy = (component, attribute, update, extra = null) => {\n  // Store context after first call.\n  let data = null; // Create context proxy.\n\n  const revocable = RevocableProxy({}, {\n    get: (target, property) => {\n      // Create context.\n      if (!data) {\n        data = createContexts(component, attribute, update, extra);\n      } // Check if name exists in context.\n\n\n      if (property in data.contexts) {\n        // Call accessed callback if element or state is accessed.\n        attribute.accessed(component.getId(), property); // Return value.\n\n        return data.contexts[property];\n      } // Try and get value from state.\n\n\n      if (data.contexts.$state) {\n        if (property in data.contexts.$state) {\n          // Call accessed callback if element or state is accessed.\n          attribute.accessed(component.getId(), '$state'); // Return value.\n\n          return data.contexts.$state[property];\n        }\n      }\n    }\n  }); // Return context.\n\n  return {\n    contexts: revocable.proxy,\n    destroy: () => {\n      // Call destroy on created context.\n      if (data && data.destroy) {\n        data.destroy(component, attribute);\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    }\n  };\n};\nexport const createAutoContexts = (component, attribute, extra = null) => {\n  // Collect update triggers.\n  const triggers = [];\n\n  const update = (id, context) => {\n    triggers.push({\n      id: id,\n      path: context\n    });\n  }; // Create function context.\n\n\n  let {\n    contexts,\n    destroy\n  } = createContexts(component, attribute, update, extra);\n  return [contexts, () => {\n    // Invoke destroy.\n    destroy(); // Dispatch update triggers.\n\n    if (triggers.length > 0) {\n      component.getLibrary().update(triggers);\n    }\n  }];\n};\nexport default {\n  createAutoContexts: createAutoContexts,\n  createContexts: createContexts,\n  createContextsProxy: createContextsProxy\n};", "/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (target, ...sources) => {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepAssign(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map(value => {\n          if (isObject(value)) {\n            return deepAssign({}, value);\n          }\n\n          return value;\n        });\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources);\n};\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\n\nexport const getDeeply = (object, path) => {\n  let objectTemp = object;\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]];\n  }\n\n  return objectTemp[path[i]];\n};\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\n\nexport const isObject = value => {\n  return value && typeof value === 'object' && !Array.isArray(value);\n};\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\n\nexport const setDeeply = (object, path, value) => {\n  // Exit early if not an object.\n  if (typeof object !== 'object') {\n    return;\n  }\n\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]; // Exit early if not an object.\n\n    if (typeof object !== 'object') {\n      return;\n    }\n  }\n\n  object[path[i]] = value;\n};\nexport default {\n  deepAssign: deepAssign,\n  getDeeply: getDeeply,\n  isObject: isObject,\n  setDeeply: setDeeply\n};", "// Import symbols.\nimport { SYNC } from '../symbols.js';\nimport { createAutoContexts } from '../utils/Context.js';\nimport { getDeeply, setDeeply } from '@doars/common/src/utils/Object.js';\nimport { escapeHtml } from '@doars/common/src/utils/String.js';\nexport default {\n  name: 'sync',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement(); // Store whether this call is an update.\n\n    const isNew = !attribute[SYNC];\n\n    if (isNew) {\n      // Check if placed on a valid tag.\n      if (!(element.tagName === 'DIV' && element.hasAttribute('contenteditable')) && element.tagName !== 'INPUT' && element.tagName !== 'SELECT' && element.tagName !== 'TEXTAREA') {\n        console.warn('Doars: `sync` directive must be placed on an `<input>`, `<select>`, `<textarea>` tag, or a content editable `div`.');\n        return;\n      }\n    } // Deconstruct attribute.\n\n\n    let value = attribute.getValue().trim();\n    const key = attribute.getKey();\n\n    if (key) {\n      value = '$' + key + '.' + value;\n    } // Check if value is a valid variable name.\n\n\n    if (!/^[_$a-z]{1}[._$a-z0-9]{0,}$/i.test(value)) {\n      console.warn('Doars: `sync` directive\\'s value not a valid variable name: \"' + value + '\".');\n      return;\n    }\n\n    value = value.split('.');\n\n    if (isNew) {\n      // Set handler that updates data based of node tag.\n      let handler;\n\n      switch (element.tagName) {\n        case 'DIV':\n          handler = () => {\n            // Update value.\n            const [contexts, destroyContexts] = createAutoContexts(component, attribute.clone());\n            setDeeply(contexts, value, escapeHtml(element.innerText));\n            destroyContexts();\n          };\n\n          break;\n\n        case 'INPUT':\n          handler = () => {\n            const attributeClone = attribute.clone();\n            const elementValue = escapeHtml(element.value); // Setup contexts.\n\n            const [contexts, destroyContexts] = createAutoContexts(component, attributeClone);\n\n            if (element.type === 'checkbox') {\n              // Get current value.\n              const dataValue = getDeeply(contexts, value); // Update value.\n\n              if (element.checked) {\n                if (!dataValue) {\n                  setDeeply(contexts, value, [elementValue]);\n                }\n\n                if (!dataValue.includes(element.value)) {\n                  dataValue.push(elementValue);\n                }\n              } else if (dataValue) {\n                const index = dataValue.indexOf(element.value);\n\n                if (index >= 0) {\n                  dataValue.splice(index, 1);\n                }\n              }\n            } else if (element.type === 'radio') {\n              // Get current value.\n              const dataValue = getDeeply(contexts, value);\n\n              if (element.checked) {\n                if (dataValue !== element.value) {\n                  setDeeply(contexts, value, elementValue);\n                }\n              } else if (dataValue === element.value) {\n                setDeeply(contexts, value, null);\n              }\n            } else {\n              setDeeply(contexts, value, elementValue);\n            } // Cleanup contexts.\n\n\n            destroyContexts();\n          };\n\n          break;\n\n        case 'TEXTAREA':\n          handler = () => {\n            // Update value.\n            const [contexts, destroyContexts] = createAutoContexts(component, attribute.clone());\n            setDeeply(contexts, value, escapeHtml(element.innerText));\n            destroyContexts();\n          };\n\n          break;\n\n        case 'SELECT':\n          handler = () => {\n            // Create contexts.\n            const [contexts, destroyContexts] = createAutoContexts(component, attribute.clone());\n\n            if (element.multiple) {\n              // Combine options.\n              const elementValues = [];\n\n              for (const option of element.selectedOptions) {\n                elementValues.push(escapeHtml(option.value));\n              } // Update value.\n\n\n              setDeeply(contexts, value, [elementValues.join('\\',\\'')]);\n            } else {\n              // Update value.\n              setDeeply(contexts, value, escapeHtml(element.selectedOptions[0].value));\n            } // Cleanup contexts.\n\n\n            destroyContexts();\n          };\n\n          break;\n      } // Add event listener.\n\n\n      element.addEventListener('input', handler); // Store handler wrapper.\n\n      attribute[SYNC] = handler;\n    }\n\n    const dataValue = processExpression(component, attribute, value);\n\n    switch (element.tagName) {\n      case 'DIV':\n      case 'TEXTAREA':\n        // Check if current value is different than attribute value.\n        if (dataValue !== element.innerText) {\n          // Update current value.\n          element.innerText = dataValue;\n        }\n\n        break;\n\n      case 'INPUT':\n        if (element.type === 'checkbox') {\n          // Update option if the checked value has changed.\n          const checked = dataValue.includes(element.value);\n\n          if (element.checked !== checked) {\n            // Update checked value.\n            element.checked = checked; // Update checked attribute.\n\n            if (checked) {\n              element.setAttribute('checked', '');\n            } else {\n              element.removeAttribute('checked');\n            }\n          }\n        } else if (element.type === 'radio') {\n          // Update option if the checked value has changed.\n          const checked = dataValue === element.value;\n\n          if (element.checked !== checked) {\n            // Update checked value.\n            element.checked = checked; // Update checked attribute.\n\n            if (checked) {\n              element.setAttribute('checked', '');\n            } else {\n              element.removeAttribute('checked');\n            }\n          }\n        } else {\n          // Check if current value is different than attribute value.\n          if (dataValue !== element.value) {\n            // Update current value.\n            element.setAttribute('value', dataValue);\n          }\n        }\n\n        break;\n\n      case 'SELECT':\n        // Iterate over the select options.\n        for (const option of Array.from(element.options)) {\n          // Update option if the selected value has changed.\n          const select = Array.isArray(dataValue) ? dataValue.includes(option.value) : dataValue === option.value;\n\n          if (option.selected !== select) {\n            // Update option status.\n            option.selected = select; // Update option attribute.\n\n            if (select) {\n              option.setAttribute('selected', '');\n            } else {\n              option.removeAttribute('selected');\n            }\n          }\n        }\n\n        break;\n    }\n  },\n  destroy: (component, attribute) => {\n    // Exit early if nothing to destroy.\n    if (!attribute[SYNC]) {\n      return;\n    } // Deconstruct attribute.\n\n\n    const element = attribute.getElement(); // Remove existing event listeners.\n\n    element.removeEventListener('input', attribute[SYNC]); // Remove data from attribute.\n\n    delete attribute[SYNC];\n  }\n};", "import { isPromise } from '@doars/common/src/utils/Promise.js';\nexport default {\n  name: 'text',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = text => {\n      // Assign text.\n      if (modifiers.content) {\n        if (element.textContent !== text) {\n          element.textContent = text;\n        }\n      } else if (element.innerText !== text) {\n        element.innerText = text;\n      }\n    }; // Execute value and retrieve result.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "export default {\n  name: 'watch',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const value = attribute.getValue(); // Execute attribute expression.\n\n    processExpression(component, attribute, value, {}, {\n      return: false\n    });\n  }\n};", "// Import symbols.\nimport { ATTRIBUTES, COMPONENT } from './symbols.js'; // Import classes.\n\nimport Component from './Component.js'; // Import contexts.\n\nimport contextChildren from './contexts/children.js';\nimport contextComponent from './contexts/component.js';\nimport contextElement from './contexts/element.js';\nimport contextDispatch from './contexts/dispatch.js';\nimport contextFor from './contexts/for.js';\nimport contextInContext from './contexts/inContext.js';\nimport contextNextTick from './contexts/nextTick.js';\nimport contextParent from './contexts/parent.js';\nimport contextReferences from './contexts/references.js';\nimport contextState from './contexts/state.js'; // Import directives.\n\nimport directiveAttribute from './directives/attribute.js';\nimport directiveCloak from './directives/cloak.js';\nimport directiveFor from './directives/for.js';\nimport directiveHtml from './directives/html.js';\nimport directiveIf from './directives/if.js';\nimport directiveInitialized from './directives/initialized.js';\nimport directiveOn from './directives/on.js';\nimport directiveReference from './directives/reference.js';\nimport directiveSelect from './directives/select.js';\nimport directiveShow from './directives/show.js';\nimport directiveSync from './directives/sync.js';\nimport directiveText from './directives/text.js';\nimport directiveWatch from './directives/watch.js'; // Import event dispatcher.\n\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'; // Import utils.\n\nimport { closestComponent } from './utils/Component.js';\nimport { walk } from '@doars/common/src/utils/Element.js';\nexport default class Doars extends EventDispatcher {\n  /**\n   * Create instance.\n   * @param {Object} options Options.\n   */\n  constructor(options) {\n    super(); // Deconstruct options.\n\n    let {\n      prefix,\n      root\n    } = options = Object.assign({\n      prefix: 'd',\n      processor: 'execute',\n      root: document.body.firstElementChild\n    }, options); // If root is a string assume it is a selector.\n\n    if (typeof root === 'string') {\n      options.root = root = document.querySelector(root);\n    } // Validate options.\n\n\n    if (!prefix) {\n      console.error('Doars: `prefix` option not set.');\n      return;\n    }\n\n    if (typeof prefix !== 'string') {\n      console.error('Doars: `prefix` option must be of type string.');\n      return;\n    }\n\n    if (!root) {\n      console.error('Doars: `root` option not set.');\n      return;\n    }\n\n    if (typeof root !== 'object') {\n      console.error('Doars: `root` option must be a string or HTMLElement.');\n      return;\n    } // Create unique identifier.\n\n\n    const id = Symbol('ID_DOARS'); // Create private variables.\n\n    let isEnabled = false,\n        isUpdating = false,\n        mutations,\n        observer,\n        triggers;\n    const components = [];\n    const contextsBase = {},\n          contexts = [contextChildren, contextComponent, contextElement, contextDispatch, contextInContext, contextNextTick, contextParent, contextReferences, // Order of `state` before `for` context is important for deconstruction.\n    contextState, contextFor];\n    const directives = [// Must happen first as other directives can rely on it.\n    directiveReference, // Then execute those that modify the document tree, since it could make other directives redundant and save on processing.\n    directiveAttribute, directiveFor, directiveHtml, directiveIf, directiveText, // Order does not matter any more.\n    directiveCloak, directiveInitialized, directiveOn, directiveSelect, directiveShow, directiveSync, directiveWatch];\n    let directivesNames, directivesObject, directivesRegexp;\n    /**\n     * Get the unique identifier.\n     * @returns {Symbol} Unique identifier.\n     */\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get the current options.\n     * @returns {Object} Current options.\n     */\n\n\n    this.getOptions = () => {\n      return Object.assign({}, options);\n    };\n    /* State */\n\n    /**\n     * Whether this is currently enabled.\n     * @returns {Boolean} Whether the library is enabled.\n     */\n\n\n    this.getEnabled = () => {\n      return isEnabled;\n    };\n    /**\n     * Enable the library.\n     * @returns {Doars} This instance.\n     */\n\n\n    this.enable = () => {\n      if (isEnabled) {\n        return this;\n      } // Setup values.\n\n\n      isUpdating = false;\n      mutations = [];\n      triggers = {}; // Dispatch event.\n\n      this.dispatchEvent('enabling', [this]); // Mark as enabled.\n\n      isEnabled = true; // Create list of directive names.\n\n      directivesNames = directives.map(directive => directive.name); // Create directives object.\n\n      directivesObject = {};\n\n      for (const directive of directives) {\n        directivesObject[directive.name] = directive;\n      } // Dynamically create expression for matching any attribute names to known directive keys.\n\n\n      directivesRegexp = new RegExp('^' + prefix + '-(' + directivesNames.join('|') + ')(?:[$-_.a-z0-9]{0,})?$', 'i'); // eslint-disable-line prefer-regex-literals\n      // Create mutation observer.\n\n      observer = new MutationObserver(handleMutation.bind(this));\n      observer.observe(root, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      }); // Scan for components.\n\n      const componentName = prefix + '-state';\n      const ignoreName = prefix + '-ignore';\n      const componentElements = [...root.querySelectorAll('[' + componentName + ']')]; // Remove any elements that should be ignored.\n\n      for (let i = componentElements.length - 1; i >= 0; i--) {\n        if (componentElements[i].closest('[' + ignoreName + ']')) {\n          componentElements.splice(i, 1);\n        }\n      }\n\n      addComponents(root.hasAttribute(componentName) && !root.hasAttribute(ignoreName) ? root : null, ...componentElements); // Dispatch events.\n\n      this.dispatchEvent('enabled', [this]);\n      this.dispatchEvent('updated', [this]);\n      return this;\n    };\n    /**\n     * Disable the library.\n     * @returns {Doars} This instance.\n     */\n\n\n    this.disable = () => {\n      if (!isEnabled) {\n        return this;\n      } // Disable mutation observer.\n\n\n      observer.disconnect();\n      observer = null; // Reset values.\n\n      isUpdating = mutations = triggers = null; // Dispatch event.\n\n      this.dispatchEvent('disabling', [this], {\n        reverse: true\n      }); // Remove components.\n\n      removeComponents(...components); // Reset directives helper.\n\n      directivesNames = directivesObject = directivesRegexp = null; // Mark as disabled.\n\n      isEnabled = false; // Dispatch event.\n\n      this.dispatchEvent('disabled', [this], {\n        reverse: true\n      });\n      return this;\n    };\n    /* Components */\n\n    /**\n     * Add components to instance.\n     * @param  {...HTMLElement} elements Elements to add as components.\n     * @returns {Array<Component>} List of added components.\n     */\n\n\n    const addComponents = (...elements) => {\n      const results = [];\n      const resultElements = [];\n\n      for (const element of elements) {\n        if (!element) {\n          continue;\n        } // Skip if already a component.\n\n\n        if (element[COMPONENT]) {\n          continue;\n        } // Create component.\n\n\n        const component = new Component(this, element); // Add to list.\n\n        components.push(component); // Add to results.\n\n        results.push(component);\n        resultElements.push(element);\n      }\n\n      if (resultElements.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('components-added', [this, resultElements]);\n      } // Initialize new components.\n\n\n      for (const component of results) {\n        component.initialize();\n      } // Update all attributes on new components.\n\n\n      for (const component of results) {\n        component.updateAttributes(component.getAttributes());\n      }\n\n      return results;\n    };\n    /**\n     * Remove components from instance.\n     * @param  {...Component} components Component to remove.\n     * @returns {Array<HTMLElement>} List of elements of removed components.\n     */\n\n\n    const removeComponents = (..._components) => {\n      const results = [];\n\n      for (const component of _components) {\n        // Skip if not in list.\n        const index = components.indexOf(component);\n\n        if (index < 0) {\n          continue;\n        } // Add to results.\n\n\n        results.push(component.getElement()); // Destroy component.\n\n        component.destroy(); // Remove from list.\n\n        components.splice(index, 1);\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('components-removed', [this, results]);\n      }\n\n      return results;\n    };\n    /* Simple contexts */\n\n    /**\n     * Get simple contexts.\n     * @returns {Object} Stored simple contexts.\n     */\n\n\n    this.getSimpleContexts = () => Object.assign({}, contextsBase);\n    /**\n     * Add a value directly to the contexts without needing to use an object or having to deal with indices.\n     * @param {String} name Property name under which to add the context.\n     * @param {Any} value The value to add, null removes the context.\n     * @returns {Boolean} Whether the value was successfully set.\n     */\n\n\n    this.setSimpleContext = (name, value = null) => {\n      // Delete context if value is null.\n      if (value === null) {\n        delete contextsBase[name]; // Dispatch event.\n\n        this.dispatchEvent('simple-context-removed', [this, name]);\n        return true;\n      } // Validate name.\n\n\n      if (!name.match('^([a-zA-Z_$][a-zA-Z\\d_$]*)$')) {\n        console.warn('Doars: name of a bind can not start with a \"$\".');\n        return false;\n      } // Store value on contexts base.\n\n\n      contextsBase[name] = value; // Dispatch event.\n\n      this.dispatchEvent('simple-context-added', [this, name, value]);\n      return true;\n    };\n    /* Contexts */\n\n    /**\n     * Get list contexts.\n     * @returns {Array<Object>} List of contexts.\n     */\n\n\n    this.getContexts = () => [...contexts];\n    /**\n     * Add contexts at the index. *Can only be called when NOT enabled.*\n     * @param {Number} index Index to start adding at.\n     * @param {...Object} _contexts List of contexts to add.\n     * @returns {Array<Object>} List of added contexts.\n     */\n\n\n    this.addContexts = (index, ..._contexts) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to add contexts after being enabled!');\n        return;\n      }\n\n      if (index < 0) {\n        index = contexts.length + index % contexts.length;\n      } else if (index > contexts.length) {\n        index = contexts.length;\n      }\n\n      const results = [];\n\n      for (let i = 0; i < _contexts.length; i++) {\n        // Get context from list.\n        const context = _contexts[i]; // Skip if already in list.\n\n        if (contexts.includes(context)) {\n          continue;\n        } // Add to list.\n\n\n        contexts.splice(index + i, 0, context); // Add to results.\n\n        results.push(context);\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('contexts-added', [this, results]);\n      }\n\n      return results;\n    };\n    /**\n     * Remove contexts. *Can only be called when NOT enabled.*\n     * @param {...Object} _contexts List of contexts to remove.\n     * @returns {Array<Object>} List of removed contexts.\n     */\n\n\n    this.removeContexts = (..._contexts) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to remove contexts after being enabled!');\n        return;\n      }\n\n      const results = [];\n\n      for (const context of _contexts) {\n        // Skip if not in list.\n        const index = contexts.indexOf(context);\n\n        if (index < 0) {\n          continue;\n        } // Remove from list.\n\n\n        contexts.slice(index, 1); // Add to results.\n\n        results.push(context);\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('contexts-removed', [this, results]);\n      }\n\n      return results;\n    };\n    /* Directives */\n\n    /**\n     * Get list directives.\n     * @returns {Array<Object>} List of directives.\n     */\n\n\n    this.getDirectives = () => [...directives];\n    /**\n     * Get list of directive names.\n     * @returns {Array<String>} List of directive names.\n     */\n\n\n    this.getDirectivesNames = () => [...directivesNames];\n    /**\n     * Get object of directives with the directive name as key.\n     * @returns {Object} Object of directives.\n     */\n\n\n    this.getDirectivesObject = () => Object.assign({}, directivesObject);\n    /**\n     * Check whether a name matches that of a directive.\n     * @param {String} attributeName Name of the attribute to match.\n     * @returns {Boolean} Whether the name matches that of a directive.\n     */\n\n\n    this.isDirectiveName = attributeName => directivesRegexp.test(attributeName);\n    /**\n     * Add directives at the index. *Can only be called when NOT enabled.*\n     * @param {Number} index Index to start adding at.\n     * @param  {...Object} _directives List of directives to add.\n     * @returns {Array<Object>} List of added directives.\n     */\n\n\n    this.addDirectives = (index, ..._directives) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to add directives after being enabled!');\n        return;\n      }\n\n      if (index < 0) {\n        index = directives.length + index % directives.length;\n      } else if (index > directives.length) {\n        index = directives.length;\n      }\n\n      const results = [];\n\n      for (let i = 0; i < _directives.length; i++) {\n        // Get directive from list.\n        const directive = _directives[i]; // Skip if already in list.\n\n        if (directives.includes(directive)) {\n          continue;\n        } // Add to list.\n\n\n        directives.splice(index + i, 0, directive); // Add to results.\n\n        results.push(directive);\n      }\n\n      if (results.length > 0) {\n        // Reset directives helpers.\n        directivesNames = directivesObject = directivesRegexp = null; // Dispatch event.\n\n        this.dispatchEvent('directives-added', [this, results]);\n      }\n\n      return results;\n    };\n    /**\n     * Remove directives. *Can only be called when NOT enabled.*\n     * @param  {...Object} _directives List of directives to remove.\n     * @returns {Array<Object>} List of removed directives.\n     */\n\n\n    this.removeDirectives = (..._directives) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to remove directives after being enabled!');\n        return;\n      }\n\n      const results = [];\n\n      for (const directive of _directives) {\n        // Skip if not in list.\n        const index = directives.indexOf(directive);\n\n        if (index < 0) {\n          continue;\n        } // Remove from list.\n\n\n        directives.slice(index, 1); // Add to results\n\n        results.push(directive);\n      }\n\n      if (results.length > 0) {\n        // Reset directives helpers.\n        directivesNames = directivesObject = directivesRegexp = null; // Dispatch event.\n\n        this.dispatchEvent('directives-removed', [this, results]);\n      }\n\n      return results;\n    };\n    /* Update */\n\n    /**\n     * Update directives based on triggers. *Can only be called when enabled.*\n     * @param {Array<Object>} _triggers List of triggers to update with.\n     */\n\n\n    this.update = _triggers => {\n      if (!isEnabled) {\n        // Exit early since it needs to enabled first.\n        return;\n      }\n\n      if (_triggers) {\n        // Add new triggers to existing triggers.\n        for (const trigger of _triggers) {\n          // Deconstruct new trigger.\n          const {\n            id,\n            path\n          } = trigger; // Create list at id if not already there.\n\n          if (!(id in triggers)) {\n            triggers[id] = [path];\n            continue;\n          } // Add path to list at id.\n\n\n          if (!triggers[id].includes(path)) {\n            triggers[id].push(path);\n          }\n        }\n      } // Don't update while another update is going on.\n\n\n      if (isUpdating) {\n        return;\n      } // Check if there is something to update.\n\n\n      if (Object.getOwnPropertySymbols(triggers).length === 0) {\n        return;\n      } // Set as updating.\n\n\n      isUpdating = true; // Move update triggers to local scope only.\n\n      _triggers = triggers;\n      triggers = {}; // Update each component and collect any triggers.\n\n      for (const component of components) {\n        component.update(_triggers); // If this ever needs to be done in hierarchical order try the following. Go over each component and check if its parent is further down in the list. If so place the component directly after the parent. Then continue iteration over the components. This sorting only has to happen when a component is added to or moved in the hierarchy.\n      } // Set as NOT updating.\n\n\n      isUpdating = false; // If there are triggers again then update again.\n\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        console.warn('Doars: during an update another update has been triggered. Normally this should not happen unless an expression in one of the directives is modifying a state which could cause a infinite loop!'); // Use an animation frame to delay the update to prevent freezing.\n\n        window.requestAnimationFrame(() => this.update());\n        return;\n      } // If there are any mutation to handle then handle them.\n\n\n      if (mutations.length > 0) {\n        handleMutation();\n        return;\n      }\n\n      this.dispatchEvent('updated', [this]);\n    };\n    /**\n     * Handle document mutations by update internal data and executing directives.\n     * @param {Array<MutationRecord>} newMutations List of mutations.\n     */\n\n\n    const handleMutation = newMutations => {\n      // Add mutations to existing list.\n      mutations.push(...newMutations); // Don't handle mutations while an update is going on.\n\n      if (isUpdating) {\n        return;\n      } // Check if there are any mutations to handle.\n\n\n      if (mutations.length === 0) {\n        return;\n      } // Set as updating.\n\n\n      isUpdating = true; // Get mutations to handle.\n\n      newMutations = [...mutations];\n      mutations = []; // Construct component name.\n\n      const componentName = prefix + '-state';\n      const ignoreName = prefix + '-ignore'; // Store new attribute and elements that define new components.\n\n      const componentsToAdd = [];\n      const componentsToRemove = [];\n\n      const remove = element => {\n        // Skip if not an element.\n        if (element.nodeType !== 1) {\n          return;\n        } // Check if element is a component itself.\n\n\n        if (element[COMPONENT]) {\n          // Add component to remove list.\n          componentsToRemove.unshift(element[COMPONENT]); // Scan for more components inside this.\n\n          const componentElements = element.querySelectorAll(componentName);\n\n          for (const componentElement of componentElements) {\n            if (componentElement[COMPONENT]) {\n              componentsToRemove.unshift(componentElement);\n            }\n          }\n        } else {\n          // Create iterator for walking over all elements in the component, skipping elements that are components and adding those to the remove list.\n          const iterator = walk(element, element => {\n            if (element[COMPONENT]) {\n              componentsToRemove.unshift(element[COMPONENT]);\n              return false;\n            }\n\n            return true;\n          });\n\n          do {\n            // Check if element has attributes.\n            if (!element[ATTRIBUTES]) {\n              continue;\n            } // Remove attributes from their component.\n\n\n            for (const attribute of element[ATTRIBUTES]) {\n              attribute.getComponent().removeAttribute(attribute);\n            }\n          } while (element = iterator());\n        }\n      };\n\n      const add = element => {\n        // Skip if not an element.\n        if (element.nodeType !== 1) {\n          return;\n        } // Skip if inside an ignore tag.\n\n\n        const ignoreParent = element.closest('[' + ignoreName + ']');\n\n        if (ignoreParent) {\n          return;\n        } // Scan for new components and add them to the list.\n\n\n        const componentElements = element.querySelectorAll('[' + componentName + ']');\n\n        for (const componentElement of componentElements) {\n          // Skip if inside an ignore tag.\n          const ignoreParent = componentElement.closest('[' + ignoreName + ']');\n\n          if (ignoreParent) {\n            continue;\n          }\n\n          componentsToAdd.push(componentElement);\n        } // Check if this elements defines a new component.\n\n\n        if (element.hasAttribute(componentName)) {\n          // Store new component element and exit early.\n          componentsToAdd.push(element);\n          return;\n        } // Find nearest component.\n\n\n        const component = closestComponent(element);\n\n        if (component) {\n          // Scan for and update new attributes.\n          const attributes = component.scanAttributes(element);\n          component.updateAttributes(attributes);\n        }\n      }; // Iterate over mutations.\n\n\n      for (const mutation of newMutations) {\n        if (mutation.type === 'childList') {\n          // Iterate over removed elements.\n          for (const element of mutation.removedNodes) {\n            remove(element);\n          } // Iterate over added elements.\n\n\n          for (const element of mutation.addedNodes) {\n            add(element);\n          }\n        } else if (mutation.type === 'attributes') {\n          const element = mutation.target; // Check if new component is defined.\n\n          if (mutation.attributeName === componentName) {\n            // If a component is already defined ignore the change.\n            if (element[COMPONENT]) {\n              continue;\n            } // Get nearest component, this will become the parent.\n\n\n            const component = closestComponent(element);\n\n            if (component) {\n              // Remove attributes part of nearest component, that will become part of the new component.\n              let currentElement = element;\n              const iterator = walk(element, element => element.hasAttribute(componentName));\n\n              do {\n                for (const attribute of currentElement[ATTRIBUTES]) {\n                  component.removeAttribute(attribute);\n                }\n              } while (currentElement = iterator());\n            } // Add new component.\n\n\n            addComponents(element);\n            continue;\n          } else if (mutation.attributeName === ignoreName) {\n            if (element.hasAttribute(ignoreName)) {\n              // Remove everything inside.\n              remove(element);\n              continue;\n            } // Add everything inside.\n\n\n            add(element);\n            continue;\n          } // Check if a directive is added.\n\n\n          if (!directivesRegexp.test(mutation.attributeName)) {\n            continue;\n          } // Get component of mutated element.\n\n\n          const component = closestComponent(element);\n\n          if (!component) {\n            continue;\n          } // Get attribute from component and value from element.\n\n\n          let attribute = null;\n\n          for (const targetAttribute of element[ATTRIBUTES]) {\n            if (targetAttribute.getName() === mutation.attributeName) {\n              attribute = targetAttribute;\n              break;\n            }\n          }\n\n          const value = element.getAttribute(mutation.attributeName); // If no attribute found add it.\n\n          if (!attribute) {\n            if (value) {\n              component.addAttribute(element, mutation.attributeName, value);\n            }\n\n            continue;\n          } // Update attribute.\n\n\n          attribute.setValue(value);\n          component.updateAttribute(attribute);\n        }\n      } // Remove old components.\n\n\n      if (componentsToRemove.length > 0) {\n        removeComponents(...componentsToRemove);\n      } // Add new components.\n\n\n      if (componentsToAdd.length > 0) {\n        addComponents(...componentsToAdd);\n      } // Set as NOT updating.\n\n\n      isUpdating = false; // If there are any mutation to handle then handle them.\n\n      if (mutations.length > 0) {\n        handleMutation();\n        return;\n      } // If there are any triggers then trigger an update.\n\n\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        this.update();\n      }\n    };\n  }\n\n}", "// Based on jsep, v1.3.6, https://github.com/EricSmekens/jsep#readme).\nimport { ARRAY, ASSIGN, BINARY, CALL, CONDITION, IDENTIFIER, LITERAL, MEMBER, OBJECT, PROPERTY, SEQUENCE, UNARY, UPDATE } from './types.js'; // Character codes.\n\nconst SPACE_CODES = [9, // Tab\n10, // LF\n13, // CR\n32 // Space\n];\nconst OPENING_PARENTHESIS_CODE = 40; // (\n\nconst CLOSING_PARENTHESIS_CODE = 41; // )\n\nconst COMMA_CODE = 44; // ,\n\nconst PERIOD_CODE = 46; // .\n\nconst COLON_CODE = 58; // :\n\nconst QUESTION_MARK_CODE = 63; // ?\n\nconst OPENING_BRACKET_CODE = 91; // [\n\nconst CLOSING_BRACKET_CODE = 93; // ]\n\nconst CLOSING_BRACES_CODE = 125; // }\n// Operators.\n\nconst ASSIGNMENT_OPERATORS = ['=', '||=', '&&=', '??=', '*=', '**=', '/=', '%=', '+=', '-=' // '<<=',\n// '>>=',\n// '>>>=',\n// '&=',\n// '^=',\n// '|=',\n];\nconst BINARY_OPERATORS = {\n  '=': 1,\n  '||=': 1,\n  '&&=': 1,\n  '??=': 1,\n  '*=': 1,\n  '**=': 1,\n  '/=': 1,\n  '%=': 1,\n  '+=': 1,\n  '-=': 1,\n  // '<<=': 1,\n  // '>>=': 1,\n  // '>>>=': 1,\n  // '&=': 1,\n  // '^=': 1,\n  // '|=': 1,\n  '||': 2,\n  '&&': 3,\n  '??': 4,\n  // '|': 5,\n  // '^': 6,\n  // '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  // '<<': 10,\n  // '>>': 10,\n  // '>>>': 10,\n  '*': 11,\n  '/': 11,\n  '%': 11,\n  '+': 11,\n  '-': 11\n};\nconst UNARY_OPERATORS = ['-', '!', // '~',\n'+'];\nconst UPDATE_OPERATOR_DECREMENT = '--';\nconst UPDATE_OPERATOR_INCREMENT = '++'; // Literal lookup.\n\nconst LITERALS = {\n  'true': true,\n  'false': false,\n  'null': null,\n  'undefined': undefined\n};\n\nconst isDecimalDigit = character => character >= 48 && character <= 57; // Between 0 and 9\n\n\nconst isIdentifierPart = character => isIdentifierStart(character) || isDecimalDigit(character);\n\nconst isIdentifierStart = character => character === 36 // Dollar ($)\n|| character >= 48 && character <= 57 // Between 0 and 9\n|| character === 95 // Underscore\n|| character >= 65 && character <= 90 // Between A and Z\n|| character >= 97 && character <= 122; // Between a and z\n\n\nexport default (expression => {\n  let index = 0;\n\n  const gobbleArray = () => {\n    index++;\n    return {\n      type: ARRAY,\n      elements: gobbleParameters(CLOSING_BRACKET_CODE)\n    };\n  };\n\n  const gobbleParameters = termination => {\n    const parameters = [];\n    let closed = false;\n    let separatorCount = 0;\n\n    while (index < expression.length) {\n      gobbleSpaces();\n      let characterIndex = expression.charCodeAt(index);\n\n      if (characterIndex === termination) {\n        closed = true;\n        index++;\n\n        if (termination === CLOSING_PARENTHESIS_CODE && separatorCount && separatorCount >= parameters.length) {\n          throw new Error('Unexpected token ' + String.fromCharCode(termination));\n        }\n\n        break;\n      } else if (characterIndex === COMMA_CODE) {\n        index++;\n        separatorCount++;\n\n        if (separatorCount !== parameters.length) {\n          if (termination === CLOSING_PARENTHESIS_CODE) {\n            throw new Error('Unexpected token ,');\n          } else if (termination === CLOSING_BRACKET_CODE) {\n            for (let i = parameters.length; i < separatorCount; i++) {\n              parameters.push(null);\n            }\n          }\n        }\n      } else if (parameters.length !== separatorCount && separatorCount !== 0) {\n        throw new Error('Expected comma');\n      } else {\n        const node = gobbleExpression();\n\n        if (!node) {\n          throw new Error('Expected comma');\n        }\n\n        parameters.push(node);\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Expected ' + String.fromCharCode(termination));\n    }\n\n    return parameters;\n  };\n\n  const gobbleBinaryExpression = () => {\n    let left = gobbleToken();\n\n    if (!left) {\n      return left;\n    }\n\n    let operator = gobbleBinaryOperation();\n\n    if (!operator) {\n      return left;\n    }\n\n    let binaryOperationInfo = {\n      value: operator,\n      precedence: BINARY_OPERATORS[operator] || 0\n    };\n    let right = gobbleToken();\n\n    if (!right) {\n      throw new Error('Expected expression after ' + operator);\n    }\n\n    const stack = [left, binaryOperationInfo, right];\n    let node;\n\n    while (operator = gobbleBinaryOperation()) {\n      const precedence = BINARY_OPERATORS[operator] || 0;\n\n      if (precedence === 0) {\n        index -= operator.length;\n        break;\n      }\n\n      binaryOperationInfo = {\n        value: operator,\n        precedence: precedence\n      };\n      const currentBinaryOperation = operator;\n\n      while (stack.length > 2 && stack[stack.length - 2] > precedence) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        node = {\n          type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0 ? ASSIGN : BINARY,\n          operator: operator,\n          left,\n          right\n        };\n        stack.push(node);\n      }\n\n      node = gobbleToken();\n\n      if (!node) {\n        throw new Error('Expected expression after ' + currentBinaryOperation);\n      }\n\n      stack.push(binaryOperationInfo, node);\n    }\n\n    let i = stack.length - 1;\n    node = stack[i];\n\n    while (i > 1) {\n      operator = stack[i - 1].value;\n      node = {\n        type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0 ? ASSIGN : BINARY,\n        operator: operator,\n        left: stack[i - 2],\n        right: node\n      };\n      i -= 2;\n    }\n\n    return node;\n  };\n\n  const gobbleBinaryOperation = () => {\n    gobbleSpaces();\n    let toCheck = expression.substring(index, index + 3); // 3 = Maximum binary operator length.\n\n    let toCheckLength = toCheck.length;\n\n    while (toCheckLength > 0) {\n      if (BINARY_OPERATORS.hasOwnProperty(toCheck) && (!isIdentifierStart(expression.charCodeAt(index)) || index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))) {\n        index += toCheckLength;\n        return toCheck;\n      }\n\n      toCheck = toCheck.substring(0, --toCheckLength);\n    }\n\n    return false;\n  };\n\n  const gobbleExpression = () => {\n    let node = gobbleBinaryExpression();\n    gobbleSpaces();\n    node = gobbleTernary(node);\n    return node;\n  };\n\n  const gobbleExpressions = untilCharacterCode => {\n    let nodes = [];\n\n    while (index < expression.length) {\n      const characterIndex = expression.charCodeAt(index);\n\n      if (characterIndex === 59 // Semicolon (;)\n      || characterIndex === COMMA_CODE) {\n        index++;\n      } else {\n        const node = gobbleExpression();\n\n        if (node) {\n          nodes.push(node);\n        } else if (index < expression.length) {\n          if (characterIndex === untilCharacterCode) {\n            break;\n          }\n\n          throw new Error('Unexpected \"' + expression.charAt(index) + '\"');\n        }\n      }\n    }\n\n    return nodes;\n  };\n\n  const gobbleIdentifier = () => {\n    let character = expression.charCodeAt(index),\n        start = index;\n\n    if (isIdentifierStart(character)) {\n      index++;\n    } else {\n      throw new Error('Unexpected ' + expression.charAt(index));\n    }\n\n    while (index < expression.length) {\n      character = expression.charCodeAt(index);\n\n      if (isIdentifierPart(character)) {\n        index++;\n      } else {\n        break;\n      }\n    }\n\n    return {\n      type: IDENTIFIER,\n      name: expression.slice(start, index)\n    };\n  };\n\n  const gobbleNumericLiteral = () => {\n    let number = '';\n\n    while (isDecimalDigit(expression.charCodeAt(index))) {\n      number += expression.charAt(index++);\n    }\n\n    if (expression.charCodeAt(index) === PERIOD_CODE) {\n      number += expression.charAt(index++);\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++);\n      }\n    }\n\n    let character = expression.charAt(index);\n\n    if (character === 'e' || character === 'E') {\n      number += expression.charAt(index++);\n      character = expression.charAt(index);\n\n      if (character === '+' || character === '-') {\n        number += expression.charAt(index++);\n      }\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++);\n      }\n\n      if (!isDecimalDigit(expression.charCodeAt(index - 1))) {\n        throw new Error('Expected exponent (' + number + expression.charAt(index) + ')');\n      }\n    }\n\n    const characterCode = expression.charCodeAt(index);\n\n    if (isIdentifierStart(characterCode)) {\n      throw new Error('Variable names cannot start with a number (' + number + expression.charAt(index) + ')');\n    } else if (characterCode === PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === PERIOD_CODE) {\n      throw new Error('Unexpected period');\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(number) // raw: number,\n\n    };\n  };\n\n  const gobbleObjectExpression = () => {\n    // Check if opening brace \"{\"\n    if (expression.charCodeAt(index) !== 123) {\n      return;\n    }\n\n    index++;\n    const properties = [];\n\n    while (!isNaN(expression.charCodeAt(index))) {\n      gobbleSpaces();\n\n      if (expression.charCodeAt(index) === CLOSING_BRACES_CODE) {\n        index++;\n        return gobbleTokenProperty({\n          type: OBJECT,\n          properties\n        });\n      }\n\n      const key = gobbleToken();\n\n      if (!key) {\n        throw new Error('missing }');\n      }\n\n      gobbleSpaces();\n\n      if (key.type === IDENTIFIER && (expression.charCodeAt(index) === COMMA_CODE || expression.charCodeAt(index) === CLOSING_BRACES_CODE)) {\n        properties.push({\n          type: PROPERTY,\n          computed: false,\n          key: key,\n          value: key,\n          shorthand: true\n        });\n      } else if (expression.charCodeAt(index) === COLON_CODE) {\n        index++;\n        const value = gobbleExpression();\n\n        if (!value) {\n          throw new Error('unexpected object property');\n        }\n\n        const computed = key.type === ARRAY;\n        properties.push({\n          computed: computed,\n          key: computed ? key.elements[0] : key,\n          shorthand: false,\n          type: PROPERTY,\n          value: value\n        });\n        gobbleSpaces();\n      } else if (key) {\n        properties.push(key);\n      }\n\n      if (expression.charCodeAt(index) === COMMA_CODE) {\n        index++;\n      }\n    }\n\n    throw new Error('missing }');\n  };\n\n  const gobbleSequence = () => {\n    index++;\n    const nodes = gobbleExpressions(CLOSING_PARENTHESIS_CODE);\n\n    if (expression.charCodeAt(index) === CLOSING_PARENTHESIS_CODE) {\n      index++;\n\n      if (nodes.length === 1) {\n        return nodes[0];\n      }\n\n      if (!nodes.length) {\n        return false;\n      }\n\n      return {\n        type: SEQUENCE,\n        expressions: nodes\n      };\n    }\n\n    throw new Error('Unclosed (');\n  };\n\n  const gobbleSpaces = () => {\n    while (SPACE_CODES.indexOf(expression.charCodeAt(index)) >= 0) {\n      index++;\n    }\n  };\n\n  const gobbleStringLiteral = () => {\n    let string = ''; // const startIndex = index\n\n    const quote = expression.charAt(index++);\n    let closed = false;\n\n    while (index < expression.length) {\n      let character = expression.charAt(index++);\n\n      if (character === quote) {\n        closed = true;\n        break;\n      }\n\n      if (character === '\\\\') {\n        character = expression.charAt(index++);\n\n        switch (character) {\n          case 'n':\n            string += '\\n';\n            break;\n\n          case 'r':\n            string += '\\r';\n            break;\n\n          case 't':\n            string += '\\t';\n            break;\n\n          case 'b':\n            string += '\\b';\n            break;\n\n          case 'f':\n            string += '\\f';\n            break;\n\n          case 'v':\n            string += '\\x0B';\n            break;\n\n          default:\n            string += character;\n        }\n      } else {\n        string += character;\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Unclosed quote after \"' + string + '\"');\n    }\n\n    return {\n      type: LITERAL,\n      value: string // raw: expression.substring(startIndex, index),\n\n    };\n  };\n\n  const gobbleTernary = node => {\n    if (!node || expression.charCodeAt(index) !== QUESTION_MARK_CODE) {\n      return node;\n    }\n\n    index++;\n    const consequent = gobbleExpression();\n\n    if (!consequent) {\n      throw new Error('Expected expression');\n    }\n\n    gobbleSpaces();\n\n    if (!expression.charCodeAt(index) === COLON_CODE) {\n      throw new Error('Expected :');\n    }\n\n    index++;\n    const alternate = gobbleExpression();\n\n    if (!alternate) {\n      throw new Error('Expected expression');\n    }\n\n    let conditional = {\n      type: CONDITION,\n      condition: node,\n      consequent: consequent,\n      alternate: alternate\n    };\n\n    if (node.operator && BINARY_OPERATORS[node.operator] <= 1) {\n      let newCondition = node;\n\n      while (newCondition.right.operator && BINARY_OPERATORS[newCondition.right.operator] <= 1) {\n        newCondition = newCondition.right;\n      }\n\n      conditional.condition = newCondition.right;\n      newCondition.right = conditional;\n      conditional = node;\n    }\n\n    return conditional;\n  };\n\n  const gobbleToken = () => {\n    let node = gobbleObjectExpression() || gobbleUpdatePrefixExpression();\n\n    if (node) {\n      return gobbleUpdateSuffixExpression(node);\n    }\n\n    gobbleSpaces();\n    const character = expression.charCodeAt(index);\n\n    if (isDecimalDigit(character) || character === PERIOD_CODE) {\n      return gobbleNumericLiteral();\n    }\n\n    if (character === 34 || character === 39) {\n      // Double quote (\") or single quote (')\n      node = gobbleStringLiteral();\n    } else if (character === OPENING_BRACKET_CODE) {\n      node = gobbleArray();\n    } else {\n      let toCheck = expression.substring(index, index + 1); // 1 = Maximum unary operator length.\n\n      let toCheckLength = toCheck.length;\n\n      while (toCheckLength > 0) {\n        if (UNARY_OPERATORS.indexOf(toCheck) >= 0 && (!isIdentifierStart(expression.charCodeAt(index)) || index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))) {\n          index += toCheckLength;\n          const parameter = gobbleToken();\n\n          if (!parameter) {\n            throw new Error('Missing unary operation parameter');\n          }\n\n          return gobbleUpdateSuffixExpression({\n            type: UNARY,\n            operator: toCheck,\n            parameter: parameter\n          });\n        }\n\n        toCheck = toCheck.substr(0, --toCheckLength);\n      }\n\n      if (isIdentifierStart(character)) {\n        node = gobbleIdentifier();\n\n        if (LITERALS.hasOwnProperty(node.name)) {\n          node = {\n            type: LITERAL,\n            value: LITERALS[node.name] // raw: node.name,\n\n          };\n        }\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = gobbleSequence();\n      }\n    }\n\n    return gobbleUpdateSuffixExpression(gobbleTokenProperty(node));\n  };\n\n  const gobbleTokenProperty = node => {\n    gobbleSpaces();\n    let character = expression.charCodeAt(index);\n\n    while (character === PERIOD_CODE || character === OPENING_BRACKET_CODE || character === OPENING_PARENTHESIS_CODE || character === QUESTION_MARK_CODE) {\n      let optional;\n\n      if (character === QUESTION_MARK_CODE) {\n        if (expression.charCodeAt(index + 1) !== PERIOD_CODE) {\n          break;\n        }\n\n        optional = true;\n        index += 2;\n        gobbleSpaces();\n        character = expression.charCodeAt(index);\n      }\n\n      index++;\n\n      if (character === OPENING_BRACKET_CODE) {\n        node = {\n          type: MEMBER,\n          computed: true,\n          object: node,\n          property: gobbleExpression()\n        };\n        gobbleSpaces();\n        character = expression.charCodeAt(index);\n\n        if (character !== CLOSING_BRACKET_CODE) {\n          throw new Error('Unclosed [');\n        }\n\n        index++;\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = {\n          type: CALL,\n          parameters: gobbleParameters(CLOSING_PARENTHESIS_CODE),\n          callee: node\n        };\n      } else if (character === PERIOD_CODE || optional) {\n        if (optional) {\n          index--;\n        }\n\n        gobbleSpaces();\n        node = {\n          type: MEMBER,\n          computed: false,\n          object: node,\n          property: gobbleIdentifier()\n        };\n      }\n\n      if (optional) {\n        node.optional = true;\n      }\n\n      gobbleSpaces();\n      character = expression.charCodeAt(index);\n    }\n\n    return node;\n  };\n\n  const gobbleUpdatePrefixExpression = () => {\n    if (index + 1 >= expression.length) {\n      return;\n    }\n\n    const characters = expression.substring(index, index + 2); // 2 = Maximum update expression length\n\n    let operator = null;\n\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT;\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT;\n    } else {\n      return;\n    }\n\n    index += 2;\n    let node = {\n      type: UPDATE,\n      operator: operator,\n      parameter: gobbleTokenProperty(gobbleIdentifier()),\n      prefix: true\n    };\n\n    if (!node.parameter || node.parameter.type !== IDENTIFIER && node.parameter.type !== MEMBER) {\n      throw new Error(`Unexpected ${env.node.operator}`);\n    }\n\n    return node;\n  };\n\n  const gobbleUpdateSuffixExpression = node => {\n    if (!node || index + 1 >= expression.length) {\n      return node;\n    }\n\n    const characters = expression.substring(index, index + 2);\n    let operator = null;\n\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT;\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT;\n    } else {\n      return node;\n    }\n\n    index += 2;\n    node = {\n      type: UPDATE,\n      operator: operator,\n      parameter: node,\n      prefix: false\n    };\n    return node;\n  };\n\n  const nodes = gobbleExpressions();\n  return nodes.length === 0 ? undefined : nodes;\n});", "import { ARRAY, ASSIGN, BINARY, CALL, CONDITION, IDENTIFIER, LITERAL, MEMBER, OBJECT, SEQUENCE, UNARY, UPDATE } from './types.js';\n\nconst setToContext = (node, value, context = {}) => {\n  switch (node.type) {\n    case IDENTIFIER:\n      // Assign to\n      return context[node.name] = value;\n\n    case MEMBER:\n      const memberObject = run(node.object, context);\n      const memberProperty = node.computed || node.property.type !== IDENTIFIER ? run(node.property, context) : node.property.name;\n\n      if (typeof value === 'function') {\n        return value.bind(memberObject);\n      }\n\n      return memberObject[memberProperty] = value;\n  }\n\n  throw new Error('Unsupported assignment method.');\n};\n\nconst run = (node, context = {}) => {\n  if (!node) {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(node => run(node, context));\n  }\n\n  switch (node.type) {\n    case IDENTIFIER:\n      return context[node.name];\n\n    case LITERAL:\n      return node.value;\n\n    case ARRAY:\n      const arrayResults = [];\n\n      for (const arrayElement of node.elements) {\n        arrayResults.push(run(arrayElement, context));\n      }\n\n      return arrayResults;\n\n    case ASSIGN:\n      let assignmentValue = run(node.right, context); // Modify value if not a direct assignment.\n\n      if (node.operator !== '=') {\n        const assignmentLeft = run(node.left, context);\n\n        switch (node.operator) {\n          case '||=':\n            if (assignmentLeft) {\n              return assignmentLeft;\n            }\n\n            break;\n\n          case '&&=':\n            if (!assignmentLeft) {\n              return assignmentLeft;\n            }\n\n            break;\n\n          case '??=':\n            if (assignmentLeft !== null && assignmentLeft !== undefined) {\n              return assignmentLeft;\n            }\n\n            break;\n\n          case '*=':\n            assignmentValue = assignmentLeft * assignmentValue;\n            break;\n\n          case '**=':\n            assignmentValue = assignmentLeft ** assignmentValue;\n            break;\n\n          case '/=':\n            assignmentValue = assignmentLeft / assignmentValue;\n            break;\n\n          case '%=':\n            assignmentValue = assignmentLeft % assignmentValue;\n            break;\n\n          case '+=':\n            assignmentValue = assignmentLeft + assignmentValue;\n            break;\n\n          case '-=':\n            assignmentValue = assignmentLeft - assignmentValue;\n            break;\n        }\n      }\n\n      return setToContext(node.left, assignmentValue, context);\n\n    case BINARY:\n      const binaryLeft = run(node.left, context);\n      const binaryRight = run(node.right, context);\n\n      switch (node.operator) {\n        case '||':\n          return binaryLeft || binaryRight;\n\n        case '&&':\n          return binaryLeft && binaryRight;\n\n        case '??':\n          return binaryLeft ?? binaryRight;\n\n        case '==':\n          return binaryLeft == binaryRight;\n\n        case '!=':\n          return binaryLeft != binaryRight;\n\n        case '===':\n          return binaryLeft === binaryRight;\n\n        case '!==':\n          return binaryLeft !== binaryRight;\n\n        case '<':\n          return binaryLeft < binaryRight;\n\n        case '>':\n          return binaryLeft > binaryRight;\n\n        case '<=':\n          return binaryLeft <= binaryRight;\n\n        case '>=':\n          return binaryLeft >= binaryRight;\n\n        case '-':\n          return binaryLeft - binaryRight;\n\n        case '+':\n          return binaryLeft + binaryRight;\n\n        case '*':\n          return binaryLeft * binaryRight;\n\n        case '/':\n          return binaryLeft / binaryRight;\n\n        case '%':\n          return binaryLeft % binaryRight;\n      }\n\n      throw new Error('Unsupported operator: ' + node.operator);\n\n    case CALL:\n      const parameters = [];\n\n      for (const parameter of node.parameters) {\n        parameters.push(run(parameter, context));\n      }\n\n      return run(node.callee, context)(...parameters);\n\n    case CONDITION:\n      return run(node.condition, context) ? run(node.consequent, context) : run(node.alternate, context);\n\n    case MEMBER:\n      const memberObject = run(node.object, context);\n      const memberProperty = node.computed || node.property.type !== IDENTIFIER ? run(node.property, context) : node.property.name;\n\n      if (typeof memberObject[memberProperty] === 'function') {\n        return memberObject[memberProperty].bind(memberObject);\n      }\n\n      return memberObject[memberProperty];\n\n    case OBJECT:\n      const objectResult = {};\n\n      for (const objectProperty of node.properties) {\n        // Expects each property to be of type PROPERTY.\n        objectResult[objectProperty.computed || objectProperty.key.type !== IDENTIFIER ? run(objectProperty.key, context) : objectProperty.key.name] = run(objectProperty.value, context);\n      }\n\n      return objectResult;\n\n    case SEQUENCE:\n      return node.expressions.map(node => run(node, context));\n\n    case UNARY:\n      const unaryParameter = run(node.parameter, context);\n\n      switch (node.operator) {\n        case '!':\n          return !unaryParameter;\n\n        case '-':\n          return -unaryParameter;\n\n        case '+':\n          return +unaryParameter;\n      }\n\n      throw new Error('Unsupported operator: ' + node.operator);\n\n    case UPDATE:\n      const updateResult = run(node.parameter, context);\n      const updateValue = node.operator === '--' ? -1 : 1;\n      setToContext(node.parameter, updateResult + updateValue, context);\n      return node.prefix ? updateResult + updateValue : updateResult;\n  }\n\n  throw new Error('Unexpected node type \"' + node.type + '\".');\n};\n\nexport default run;", "import _parse from './parse.js';\nimport _run from './run.js';\nimport { ARRAY as _ARRAY, ASSIGN as _ASSIGN, BINARY as _BINARY, CALL as _CALL, CONDITION as _CONDITION, IDENTIFIER as _IDENTIFIER, LITERAL as _LITERAL, MEMBER as _MEMBER, OBJECT as _OBJECT, PROPERTY as _PROPERTY, SEQUENCE as _SEQUENCE, UNARY as _UNARY, UPDATE as _UPDATE } from './types.js';\nexport const interpret = (expression, context) => {\n  return _run(_parse(expression), context);\n};\nexport const parse = _parse;\nexport const run = _run;\nexport const ARRAY = _ARRAY;\nexport const ASSIGN = _ASSIGN;\nexport const BINARY = _BINARY;\nexport const CALL = _CALL;\nexport const CONDITION = _CONDITION;\nexport const IDENTIFIER = _IDENTIFIER;\nexport const LITERAL = _LITERAL;\nexport const MEMBER = _MEMBER;\nexport const OBJECT = _OBJECT;\nexport const PROPERTY = _PROPERTY;\nexport const SEQUENCE = _SEQUENCE;\nexport const UNARY = _UNARY;\nexport const UPDATE = _UPDATE;\nexport default {\n  interpret: interpret,\n  parse: _parse,\n  run: _run,\n  ARRAY: _ARRAY,\n  ASSIGN: _ASSIGN,\n  BINARY: _BINARY,\n  CALL: _CALL,\n  CONDITION: _CONDITION,\n  IDENTIFIER: _IDENTIFIER,\n  LITERAL: _LITERAL,\n  MEMBER: _MEMBER,\n  OBJECT: _OBJECT,\n  PROPERTY: _PROPERTY,\n  SEQUENCE: _SEQUENCE,\n  UNARY: _UNARY,\n  UPDATE: _UPDATE\n};", "import { createAutoContexts } from './Context.js';\nimport { parse, run } from '@doars/interpret';\nexport const interpret = (component, attribute, expression, extra = null, options = null) => {\n  // Override default with given options.\n  options = Object.assign({\n    return: true\n  }, options); // Create contexts.\n\n  const [contexts, destroyContexts] = createAutoContexts(component, attribute, update, extra); // Try to execute code.\n\n  let result;\n\n  try {\n    const expressionParsed = parse(expression);\n\n    if (options.return && expressionParsed && expressionParsed.length > 1) {\n      throw new Error('Unable to return a single value from a compound expression of: \"' + expression + '\".');\n    }\n\n    result = run(expressionParsed, contexts);\n  } catch (error) {\n    console.error(error, 'Error encountered when executing the following expression: ', expression);\n    result = null;\n  } // Cleanup contexts.\n\n\n  destroyContexts(); // Unwrap results.\n\n  if (options.return && result) {\n    result = result[0];\n    return result;\n  }\n};\nexport default {\n  interpret: interpret\n};", "import Doars from './Doars.js';\nimport { interpret } from './utils/Interpret.js';\nDoars.interpretExpression = interpret;\nexport default Doars;"],
  "mappings": "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",
  "names": []
}
