{
  "version": 3,
  "sources": ["../src/symbols.js", "../src/factories/directives/view.js", "../src/ViewObserver.js", "../src/DoarsView.js"],
  "sourcesContent": ["export const VIEW = Symbol('VIEW');", "// Import symbols.\nimport { VIEW } from '../../symbols.js'; // Declare constants.\n\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 3\n};\nexport default (observer => {\n  return {\n    name: 'view',\n    update: (component, attribute, {\n      processExpression\n    }) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement();\n      const key = attribute.getKey();\n      const value = attribute.getValue(); // Check if existing handler exists.\n\n      if (attribute[VIEW]) {\n        // Exit early if value has not changed.\n        if (attribute[VIEW].value === value) {\n          return;\n        } // Stop observing the element.\n\n\n        observer.remove(element, attribute[VIEW].handler); // Clear any ongoing timeouts.\n\n        if (attribute[VIEW].timeout) {\n          clearTimeout(attribute[VIEW].timeout);\n        } // Delete directive data.\n\n\n        delete attribute[VIEW];\n      } // Deconstruct attribute.\n\n\n      const modifiers = attribute.getModifiers(); // Process execution modifiers.\n\n      let executionModifier = EXECUTION_MODIFIERS.NONE;\n\n      if (modifiers.buffer) {\n        executionModifier = EXECUTION_MODIFIERS.BUFFER;\n\n        if (modifiers.buffer === true) {\n          modifiers.buffer = 5;\n        }\n      } else if (modifiers.debounce) {\n        executionModifier = EXECUTION_MODIFIERS.DEBOUNCE;\n\n        if (modifiers.debounce === true) {\n          modifiers.debounce = 500;\n        }\n      } else if (modifiers.throttle) {\n        executionModifier = EXECUTION_MODIFIERS.THROTTLE;\n\n        if (modifiers.throttle === true) {\n          modifiers.throttle = 500;\n        }\n      } // Create intersection handler.\n\n\n      const handler = event => {\n        // Check if intersection has changed.\n        const isChanged = attribute[VIEW].isIntersecting !== event.isIntersecting;\n\n        if (!isChanged) {\n          return;\n        } // Update state in attribute data.\n\n\n        attribute[VIEW].isIntersecting = event.isIntersecting; // Exit early if expression should not be executed.\n\n        if (key === 'enter' && !event.isIntersecting || key === 'leave' && event.isIntersecting) {\n          // Clear existing timeout.\n          if (attribute[VIEW].timeout) {\n            clearTimeout(attribute[VIEW].timeout);\n            attribute[VIEW].timeout = null;\n          }\n\n          return;\n        }\n\n        const execute = () => {\n          // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n          processExpression(component, attribute.clone(), value, {\n            $event: event\n          }, {\n            return: false\n          }); // Reset the buffer.\n\n          attribute[VIEW].buffer = [];\n        }; // Store event in buffer.\n\n\n        attribute[VIEW].buffer.push(event); // Check if we need to apply an execution modifier.\n\n        if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n          // Exit early if buffer is not full.\n          if (attribute[VIEW].buffer.length < modifiers.buffer) {\n            return;\n          }\n\n          execute();\n        } else if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n          // Clear existing timeout.\n          if (attribute[VIEW].timeout) {\n            clearTimeout(attribute[VIEW].timeout);\n            attribute[VIEW].timeout = null;\n          } // Setup timeout and execute expression when it finishes.\n\n\n          attribute[VIEW].timeout = setTimeout(execute, modifiers.debounce);\n        } else if (executionModifier === EXECUTION_MODIFIERS.THROTTLE) {\n          // Get current time in milliseconds.\n          const now = window.performance.now(); // Exit early if throttle time has not passed.\n\n          if (attribute[VIEW].lastExecution && now - attribute[VIEW].lastExecution < modifiers.throttle) {\n            return;\n          }\n\n          execute(); // Store new latest execution time.\n\n          attribute[VIEW].lastExecution = now;\n        } else {\n          // Execute expression.\n          execute();\n        }\n      }; // Start observing the element.\n\n\n      observer.add(element, handler); // Store handler.\n\n      attribute[VIEW] = {\n        buffer: [],\n        handler: handler,\n        isIntersecting: false,\n        timeout: attribute[VIEW] ? attribute[VIEW].timeout : null,\n        value: value\n      };\n    },\n    destroy: (component, attribute) => {\n      // Check if a handler exists.\n      if (!attribute[VIEW]) {\n        return;\n      } // Deconstruct attribute.\n\n\n      const element = attribute.getElement(); // Stop observing the element.\n\n      observer.remove(element, attribute[VIEW].handler); // Clear any ongoing timeouts.\n\n      if (attribute[VIEW].timeout) {\n        clearTimeout(attribute[VIEW].timeout);\n      } // Delete directive data.\n\n\n      delete attribute[VIEW];\n    }\n  };\n});", "export default class ViewObserver {\n  /**\n   * Create observer instance.\n   * @param {Object} options Intersection observer options.\n   */\n  constructor(options = null) {\n    // Overwrite default options.\n    options = Object.assign({\n      root: null,\n      rootMargin: '0px',\n      threshold: 0\n    }, options); // Store data per element.\n\n    const items = new WeakMap();\n    /**\n     * Intersection observer handler.\n     * @param {Array<IntersectionObserverEntry>} entries Intersection observer entries.\n     */\n\n    const intersect = entries => {\n      // Invoke callbacks of each entry.\n      for (const entry of entries) {\n        for (const callback of items.get(entry.target)) {\n          callback(entry);\n        }\n      }\n    }; // Create intersection observer.\n\n\n    const intersectionObserver = new IntersectionObserver(intersect, options);\n    /**\n     * Add element to observe.\n     * @param {HTMLElement} element Element to observer.\n     * @param {Function} callback Callback to call on intersection change.\n     */\n\n    this.add = (element, callback) => {\n      // Add callback to list.\n      if (!items.has(element)) {\n        items.set(element, []);\n      }\n\n      items.get(element).push(callback); // Start observing element.\n\n      intersectionObserver.observe(element);\n    };\n    /**\n     * Remove element from observing.\n     * @param {HTMLElement} element Element that is observed.\n     * @param {Function} callback Callback that is called on intersection change.\n     */\n\n\n    this.remove = (element, callback) => {\n      // Remove callback from list.\n      if (!items.has(element)) {\n        return;\n      }\n\n      const list = items.get(element);\n      const index = list.indexOf(callback);\n\n      if (index >= 0) {\n        list.splice(index, 1);\n      } // Check if there are no more callbacks.\n\n\n      if (list.length === 0) {\n        // Remove element from callbacks list.\n        items.delete(element); // Stop observing element.\n\n        intersectionObserver.unobserve(element);\n      }\n    };\n  }\n\n}", "// Import directives.\nimport createDirectiveView from './factories/directives/view.js'; // Import observer.\n\nimport ViewObserver from './ViewObserver.js';\nexport default class DoarsView {\n  /**\n   * Create plugin instance.\n   * @param {Doars} library Doars instance to add onto.\n   * @param {Object} options The plugin options.\n   */\n  constructor(library, options = null) {\n    // Store options.\n    options = Object.assign({}, options); // Set private variables.\n\n    let directiveView, observer; // Enable plugin when library is enabling.\n\n    library.addEventListener('enabling', () => {\n      // Overwrite default options.\n      const _options = Object.assign({}, options);\n\n      if (!_options.root) {\n        _options.root = library.getOptions().root;\n      } // Setup observer.\n\n\n      observer = new ViewObserver(options); // Create and add directive.\n\n      directiveView = createDirectiveView(observer);\n      library.addDirectives(-1, directiveView);\n    }); // Disable plugin when library is disabling.\n\n    library.addEventListener('disabling', () => {\n      // Remove directive.\n      library.removeDirectives(directiveView);\n      directiveView = null; // Remove observer.\n\n      observer = null;\n    });\n  }\n\n}"],
  "mappings": "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",
  "names": []
}
