{
  "version": 3,
  "sources": ["../src/types.js", "../src/parse.js", "../src/run.js", "../src/index.js", "../src/iife.js"],
  "sourcesContent": ["export const ARRAY = 5\nexport const ASSIGN = 6\nexport const BINARY = 7\nexport const CALL = 8\nexport const CONDITION = 9\nexport const IDENTIFIER = 2\nexport const LITERAL = 3\nexport const MEMBER = 10\nexport const OBJECT = 11\nexport const PROPERTY = 4\nexport const SEQUENCE = 12\nexport const UNARY = 13\nexport const UPDATE = 14\n\nexport default {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n}\n", "// Based on jsep, v1.3.6, https://github.com/EricSmekens/jsep#readme).\n\nimport {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n} from './types.js'\n\n// Character codes.\nconst SPACE_CODES = [\n  9, // Tab\n  10, // LF\n  13, // CR\n  32, // Space\n]\nconst OPENING_PARENTHESIS_CODE = 40 // (\nconst CLOSING_PARENTHESIS_CODE = 41 // )\nconst COMMA_CODE = 44 // ,\nconst PERIOD_CODE = 46 // .\nconst COLON_CODE = 58 // :\nconst QUESTION_MARK_CODE = 63 // ?\nconst OPENING_BRACKET_CODE = 91 // [\nconst CLOSING_BRACKET_CODE = 93 // ]\nconst CLOSING_BRACES_CODE = 125 // }\n\n// Operators.\nconst ASSIGNMENT_OPERATORS = [\n  '=',\n  '||=',\n  '&&=',\n  '??=',\n  '*=',\n  '**=',\n  '/=',\n  '%=',\n  '+=',\n  '-=',\n  // '<<=',\n  // '>>=',\n  // '>>>=',\n  // '&=',\n  // '^=',\n  // '|=',\n]\nconst BINARY_OPERATORS = {\n  '=': 1,\n  '||=': 1,\n  '&&=': 1,\n  '??=': 1,\n  '*=': 1,\n  '**=': 1,\n  '/=': 1,\n  '%=': 1,\n  '+=': 1,\n  '-=': 1,\n  // '<<=': 1,\n  // '>>=': 1,\n  // '>>>=': 1,\n  // '&=': 1,\n  // '^=': 1,\n  // '|=': 1,\n  '||': 2,\n  '&&': 3,\n  '??': 4,\n  // '|': 5,\n  // '^': 6,\n  // '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  // '<<': 10,\n  // '>>': 10,\n  // '>>>': 10,\n  '*': 11,\n  '/': 11,\n  '%': 11,\n  '+': 11,\n  '-': 11,\n}\nconst UNARY_OPERATORS = [\n  '-',\n  '!',\n  // '~',\n  '+',\n]\nconst UPDATE_OPERATOR_DECREMENT = '--'\nconst UPDATE_OPERATOR_INCREMENT = '++'\n\n// Literal lookup.\nconst LITERALS = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n}\n\nconst isDecimalDigit = (\n  character,\n) => (character >= 48 && character <= 57) // Between 0 and 9\n\nconst isIdentifierPart = (\n  character,\n) => isIdentifierStart(character) || isDecimalDigit(character)\n\nconst isIdentifierStart = (\n  character,\n) =>\n  character === 36 || // Dollar ($)\n  (character >= 48 && character <= 57) || // Between 0 and 9\n  character === 95 || // Underscore\n  (character >= 65 && character <= 90) || // Between A and Z\n  (character >= 97 && character <= 122) // Between a and z\n\nexport default (\n  expression,\n) => {\n  let index = 0\n\n  const gobbleArray = (\n  ) => {\n    index++\n\n    return {\n      type: ARRAY,\n      elements: gobbleParameters(CLOSING_BRACKET_CODE),\n    }\n  }\n\n  const gobbleParameters = (\n    termination,\n  ) => {\n    const parameters = []\n    let closed = false\n\n    let separatorCount = 0\n    while (index < expression.length) {\n      gobbleSpaces()\n      const characterIndex = expression.charCodeAt(index)\n\n      if (characterIndex === termination) {\n        closed = true\n        index++\n\n        if (termination === CLOSING_PARENTHESIS_CODE && separatorCount && separatorCount >= parameters.length) {\n          throw new Error('Unexpected token ' + String.fromCharCode(termination))\n        }\n        break\n      } else if (characterIndex === COMMA_CODE) {\n        index++\n        separatorCount++\n\n        if (separatorCount !== parameters.length) {\n          if (termination === CLOSING_PARENTHESIS_CODE) {\n            throw new Error('Unexpected token ,')\n          } else if (termination === CLOSING_BRACKET_CODE) {\n            for (let i = parameters.length; i < separatorCount; i++) {\n              parameters.push(null)\n            }\n          }\n        }\n      } else if (parameters.length !== separatorCount && separatorCount !== 0) {\n        throw new Error('Expected comma')\n      } else {\n        const node = gobbleExpression()\n\n        if (!node) {\n          throw new Error('Expected comma')\n        }\n\n        parameters.push(node)\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Expected ' + String.fromCharCode(termination))\n    }\n\n    return parameters\n  }\n\n  const gobbleBinaryExpression = (\n  ) => {\n    let left = gobbleToken()\n    if (!left) {\n      return left\n    }\n\n    let operator = gobbleBinaryOperation()\n    if (!operator) {\n      return left\n    }\n\n    let binaryOperationInfo = {\n      value: operator,\n      precedence: BINARY_OPERATORS[operator] || 0,\n    }\n\n    let right = gobbleToken()\n    if (!right) {\n      throw new Error('Expected expression after ' + operator)\n    }\n\n    const stack = [\n      left,\n      binaryOperationInfo,\n      right,\n    ]\n\n    let node\n    while ((operator = gobbleBinaryOperation())) {\n      const precedence = BINARY_OPERATORS[operator] || 0\n\n      if (precedence === 0) {\n        index -= operator.length\n        break\n      }\n\n      binaryOperationInfo = {\n        value: operator,\n        precedence,\n      }\n\n      const currentBinaryOperation = operator\n      while (stack.length > 2 && stack[stack.length - 2] > precedence) {\n        right = stack.pop()\n        operator = stack.pop().value\n        left = stack.pop()\n        node = {\n          type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n            ? ASSIGN\n            : BINARY,\n          operator,\n          left,\n          right,\n        }\n        stack.push(node)\n      }\n\n      node = gobbleToken()\n\n      if (!node) {\n        throw new Error('Expected expression after ' + currentBinaryOperation)\n      }\n\n      stack.push(binaryOperationInfo, node)\n    }\n\n    let i = stack.length - 1\n    node = stack[i]\n\n    while (i > 1) {\n      operator = stack[i - 1].value\n      node = {\n        type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n          ? ASSIGN\n          : BINARY,\n        operator,\n        left: stack[i - 2],\n        right: node,\n      }\n      i -= 2\n    }\n\n    return node\n  }\n\n  const gobbleBinaryOperation = (\n  ) => {\n    gobbleSpaces()\n    let toCheck = expression.substring(index, index + 3) // 3 = Maximum binary operator length.\n    let toCheckLength = toCheck.length\n\n    while (toCheckLength > 0) {\n      if (Object.prototype.hasOwnProperty.call(BINARY_OPERATORS, toCheck) && (\n        !isIdentifierStart(expression.charCodeAt(index)) ||\n        (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n      )) {\n        index += toCheckLength\n        return toCheck\n      }\n      toCheck = toCheck.substring(0, --toCheckLength)\n    }\n    return false\n  }\n\n  const gobbleExpression = (\n  ) => {\n    let node = gobbleBinaryExpression()\n    gobbleSpaces()\n    node = gobbleTernary(node)\n    return node\n  }\n\n  const gobbleExpressions = (\n    untilCharacterCode,\n  ) => {\n    const nodes = []\n    while (index < expression.length) {\n      const characterIndex = expression.charCodeAt(index)\n      if (\n        characterIndex === 59 || // Semicolon (;)\n        characterIndex === COMMA_CODE\n      ) {\n        index++\n      } else {\n        const node = gobbleExpression()\n        if (node) {\n          nodes.push(node)\n        } else if (index < expression.length) {\n          if (characterIndex === untilCharacterCode) {\n            break\n          }\n          throw new Error('Unexpected \"' + expression.charAt(index) + '\"')\n        }\n      }\n    }\n    return nodes\n  }\n\n  const gobbleIdentifier = (\n  ) => {\n    let character = expression.charCodeAt(index)\n    const start = index\n\n    if (isIdentifierStart(character)) {\n      index++\n    } else {\n      throw new Error('Unexpected ' + expression.charAt(index))\n    }\n\n    while (index < expression.length) {\n      character = expression.charCodeAt(index)\n\n      if (isIdentifierPart(character)) {\n        index++\n      } else {\n        break\n      }\n    }\n    return {\n      type: IDENTIFIER,\n      name: expression.slice(start, index),\n    }\n  }\n\n  const gobbleNumericLiteral = (\n  ) => {\n    let number = ''\n    while (isDecimalDigit(expression.charCodeAt(index))) {\n      number += expression.charAt(index++)\n    }\n    if (expression.charCodeAt(index) === PERIOD_CODE) {\n      number += expression.charAt(index++)\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n    }\n\n    let character = expression.charAt(index)\n    if (character === 'e' || character === 'E') {\n      number += expression.charAt(index++)\n      character = expression.charAt(index)\n\n      if (character === '+' || character === '-') {\n        number += expression.charAt(index++)\n      }\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n\n      if (!isDecimalDigit(expression.charCodeAt(index - 1))) {\n        throw new Error('Expected exponent (' + number + expression.charAt(index) + ')')\n      }\n    }\n\n    const characterCode = expression.charCodeAt(index)\n    if (isIdentifierStart(characterCode)) {\n      throw new Error('Variable names cannot start with a number (' + number + expression.charAt(index) + ')')\n    } else if (\n      characterCode === PERIOD_CODE ||\n      (\n        number.length === 1 &&\n        number.charCodeAt(0) === PERIOD_CODE\n      )\n    ) {\n      throw new Error('Unexpected period')\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(number),\n      // raw: number,\n    }\n  }\n\n  const gobbleObjectExpression = (\n  ) => {\n    // Check if opening brace \"{\"\n    if (expression.charCodeAt(index) !== 123) {\n      return\n    }\n    index++\n\n    const properties = []\n    while (!isNaN(expression.charCodeAt(index))) {\n      gobbleSpaces()\n      if (expression.charCodeAt(index) === CLOSING_BRACES_CODE) {\n        index++\n        return gobbleTokenProperty({\n          type: OBJECT,\n          properties,\n        })\n      }\n\n      const key = gobbleToken()\n      if (!key) {\n        throw new Error('Missing }')\n      }\n      gobbleSpaces()\n\n      if (\n        key.type === IDENTIFIER &&\n        (\n          expression.charCodeAt(index) === COMMA_CODE ||\n          expression.charCodeAt(index) === CLOSING_BRACES_CODE\n        )\n      ) {\n        properties.push({\n          type: PROPERTY,\n          computed: false,\n          key,\n          value: key,\n          shorthand: true,\n        })\n      } else if (expression.charCodeAt(index) === COLON_CODE) {\n        index++\n        gobbleSpaces()\n        const value = gobbleExpression()\n        if (!value) {\n          throw new Error('Unexpected object property')\n        }\n\n        const computed = key.type === ARRAY\n        properties.push({\n          computed,\n          key: computed\n            ? key.elements[0]\n            : key,\n          shorthand: false,\n          type: PROPERTY,\n          value,\n        })\n        gobbleSpaces()\n      } else if (key) {\n        properties.push(key)\n      }\n\n      if (expression.charCodeAt(index) === COMMA_CODE) {\n        index++\n      }\n    }\n    throw new Error('Missing }')\n  }\n\n  const gobbleSequence = (\n  ) => {\n    index++\n\n    const nodes = gobbleExpressions(CLOSING_PARENTHESIS_CODE)\n    if (expression.charCodeAt(index) === CLOSING_PARENTHESIS_CODE) {\n      index++\n\n      if (nodes.length === 1) {\n        return nodes[0]\n      }\n      if (!nodes.length) {\n        return false\n      }\n\n      return {\n        type: SEQUENCE,\n        expressions: nodes,\n      }\n    }\n\n    throw new Error('Unclosed (')\n  }\n\n  const gobbleSpaces = (\n  ) => {\n    while (SPACE_CODES.indexOf(expression.charCodeAt(index)) >= 0) {\n      index++\n    }\n  }\n\n  const gobbleStringLiteral = (\n  ) => {\n    let string = ''\n    // const startIndex = index\n    const quote = expression.charAt(index++)\n    let closed = false\n\n    while (index < expression.length) {\n      let character = expression.charAt(index++)\n\n      if (character === quote) {\n        closed = true\n        break\n      }\n      if (character === '\\\\') {\n        character = expression.charAt(index++)\n\n        switch (character) {\n          case 'n':\n            string += '\\n'\n            break\n\n          case 'r':\n            string += '\\r'\n            break\n\n          case 't':\n            string += '\\t'\n            break\n\n          case 'b':\n            string += '\\b'\n            break\n\n          case 'f':\n            string += '\\f'\n            break\n\n          case 'v':\n            string += '\\x0B'\n            break\n\n          default:\n            string += character\n        }\n      } else {\n        string += character\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Unclosed quote after \"' + string + '\"')\n    }\n\n    return {\n      type: LITERAL,\n      value: string,\n      // raw: expression.substring(startIndex, index),\n    }\n  }\n\n  const gobbleTernary = (\n    node,\n  ) => {\n    if (!node || expression.charCodeAt(index) !== QUESTION_MARK_CODE) {\n      return node\n    }\n    index++\n\n    const consequent = gobbleExpression()\n    if (!consequent) {\n      throw new Error('Expected expression')\n    }\n\n    gobbleSpaces()\n\n    if (!expression.charCodeAt(index) === COLON_CODE) {\n      throw new Error('Expected :')\n    }\n    index++\n\n    const alternate = gobbleExpression()\n    if (!alternate) {\n      throw new Error('Expected expression')\n    }\n\n    let conditional = {\n      type: CONDITION,\n      condition: node,\n      consequent,\n      alternate,\n    }\n\n    if (node.operator && BINARY_OPERATORS[node.operator] <= 1) {\n      let newCondition = node\n      while (newCondition.right.operator && BINARY_OPERATORS[newCondition.right.operator] <= 1) {\n        newCondition = newCondition.right\n      }\n      conditional.condition = newCondition.right\n      newCondition.right = conditional\n      conditional = node\n    }\n\n    return conditional\n  }\n\n  const gobbleToken = (\n  ) => {\n    let node = gobbleObjectExpression() || gobbleUpdatePrefixExpression()\n    if (node) {\n      return gobbleUpdateSuffixExpression(node)\n    }\n    gobbleSpaces()\n\n    const character = expression.charCodeAt(index)\n    if (isDecimalDigit(character) || character === PERIOD_CODE) {\n      return gobbleNumericLiteral()\n    }\n\n    if (character === 34 || character === 39) { // Double quote (\") or single quote (')\n      node = gobbleStringLiteral()\n    } else if (character === OPENING_BRACKET_CODE) {\n      node = gobbleArray()\n    } else {\n      let toCheck = expression.substring(index, index + 1) // 1 = Maximum unary operator length.\n      let toCheckLength = toCheck.length\n\n      while (toCheckLength > 0) {\n        if (UNARY_OPERATORS.indexOf(toCheck) >= 0 && (\n          !isIdentifierStart(expression.charCodeAt(index)) ||\n          (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n        )) {\n          index += toCheckLength\n          const parameter = gobbleToken()\n          if (!parameter) {\n            throw new Error('Missing unary operation parameter')\n          }\n          return gobbleUpdateSuffixExpression({\n            type: UNARY,\n            operator: toCheck,\n            parameter,\n          })\n        }\n\n        toCheck = toCheck.substr(0, --toCheckLength)\n      }\n\n      if (isIdentifierStart(character)) {\n        node = gobbleIdentifier()\n        if (Object.prototype.hasOwnProperty.call(LITERALS, node.name)) {\n          node = {\n            type: LITERAL,\n            value: LITERALS[node.name],\n            // raw: node.name,\n          }\n        }\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = gobbleSequence()\n      }\n    }\n\n    return gobbleUpdateSuffixExpression(\n      gobbleTokenProperty(node),\n    )\n  }\n\n  const gobbleTokenProperty = (\n    node,\n  ) => {\n    gobbleSpaces()\n\n    let character = expression.charCodeAt(index)\n    while (\n      character === PERIOD_CODE ||\n      character === OPENING_BRACKET_CODE ||\n      character === OPENING_PARENTHESIS_CODE ||\n      character === QUESTION_MARK_CODE\n    ) {\n      let optional\n      if (character === QUESTION_MARK_CODE) {\n        if (expression.charCodeAt(index + 1) !== PERIOD_CODE) {\n          break\n        }\n        optional = true\n        index += 2\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n      }\n      index++\n\n      if (character === OPENING_BRACKET_CODE) {\n        node = {\n          type: MEMBER,\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n        }\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n        if (character !== CLOSING_BRACKET_CODE) {\n          throw new Error('Unclosed [')\n        }\n        index++\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = {\n          type: CALL,\n          parameters: gobbleParameters(CLOSING_PARENTHESIS_CODE),\n          callee: node,\n        }\n      } else if (character === PERIOD_CODE || optional) {\n        if (optional) {\n          index--\n        }\n        gobbleSpaces()\n        node = {\n          type: MEMBER,\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n        }\n      }\n\n      if (optional) {\n        node.optional = true\n      }\n\n      gobbleSpaces()\n      character = expression.charCodeAt(index)\n    }\n\n    return node\n  }\n\n  const gobbleUpdatePrefixExpression = (\n  ) => {\n    if (index + 1 >= expression.length) {\n      return\n    }\n\n    const characters = expression.substring(index, index + 2) // 2 = Maximum update expression length\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return\n    }\n\n    index += 2\n    const node = {\n      type: UPDATE,\n      operator,\n      parameter: gobbleTokenProperty(gobbleIdentifier()),\n      prefix: true,\n    }\n    if (!node.parameter || (node.parameter.type !== IDENTIFIER && node.parameter.type !== MEMBER)) {\n      throw new Error('Unexpected ' + node.operator)\n    }\n    return node\n  }\n\n  const gobbleUpdateSuffixExpression = (\n    node,\n  ) => {\n    if (!node || index + 1 >= expression.length) {\n      return node\n    }\n\n    const characters = expression.substring(index, index + 2)\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return node\n    }\n\n    index += 2\n    node = {\n      type: UPDATE,\n      operator,\n      parameter: node,\n      prefix: false,\n    }\n    return node\n  }\n\n  const nodes = gobbleExpressions()\n  return nodes.length === 0 ? undefined : nodes\n}\n", "import {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n} from './types.js'\n\nconst setToContext = (\n  node,\n  value,\n  context = {},\n) => {\n  switch (node.type) {\n    case IDENTIFIER:\n      // Assign to\n      context[node.name] = value\n      return value\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (value) === 'function') {\n        return value.bind(memberObject)\n      }\n      memberObject[memberProperty] = value\n      return value\n  }\n\n  throw new Error('Unsupported assignment method.')\n}\n\nconst run = (\n  node,\n  context = {},\n) => {\n  if (!node) {\n    return\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(node => run(node, context))\n  }\n\n  switch (node.type) {\n    case IDENTIFIER:\n      return context[node.name]\n\n    case LITERAL:\n      return node.value\n\n    case ARRAY:\n      const arrayResults = []\n      for (const arrayElement of node.elements) {\n        arrayResults.push(run(arrayElement, context))\n      }\n      return arrayResults\n\n    case ASSIGN:\n      let assignmentValue = run(node.right, context)\n      // Modify value if not a direct assignment.\n      if (node.operator !== '=') {\n        const assignmentLeft = run(node.left, context)\n        switch (node.operator) {\n          case '||=':\n            if (assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '&&=':\n            if (!assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '??=':\n            if (assignmentLeft !== null && assignmentLeft !== undefined) {\n              return assignmentLeft\n            }\n            break\n          case '*=':\n            assignmentValue = assignmentLeft * assignmentValue\n            break\n          case '**=':\n            assignmentValue = assignmentLeft ** assignmentValue\n            break\n          case '/=':\n            assignmentValue = assignmentLeft / assignmentValue\n            break\n          case '%=':\n            assignmentValue = assignmentLeft % assignmentValue\n            break\n          case '+=':\n            assignmentValue = assignmentLeft + assignmentValue\n            break\n          case '-=':\n            assignmentValue = assignmentLeft - assignmentValue\n            break\n        }\n      }\n      return setToContext(node.left, assignmentValue, context)\n\n    case BINARY:\n      const binaryLeft = run(node.left, context)\n      const binaryRight = run(node.right, context)\n      switch (node.operator) {\n        case '||':\n          return binaryLeft || binaryRight\n        case '&&':\n          return binaryLeft && binaryRight\n        case '??':\n          return binaryLeft ?? binaryRight\n        case '==':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft == binaryRight\n        case '!=':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft != binaryRight\n        case '===':\n          return binaryLeft === binaryRight\n        case '!==':\n          return binaryLeft !== binaryRight\n        case '<':\n          return binaryLeft < binaryRight\n        case '>':\n          return binaryLeft > binaryRight\n        case '<=':\n          return binaryLeft <= binaryRight\n        case '>=':\n          return binaryLeft >= binaryRight\n        case '-':\n          return binaryLeft - binaryRight\n        case '+':\n          return binaryLeft + binaryRight\n        case '*':\n          return binaryLeft * binaryRight\n        case '/':\n          return binaryLeft / binaryRight\n        case '%':\n          return binaryLeft % binaryRight\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case CALL:\n      const parameters = []\n      for (const parameter of node.parameters) {\n        parameters.push(run(parameter, context))\n      }\n      return run(node.callee, context)(...parameters)\n\n    case CONDITION:\n      return run(node.condition, context)\n        ? run(node.consequent, context)\n        : run(node.alternate, context)\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (memberObject[memberProperty]) === 'function') {\n        return memberObject[memberProperty].bind(memberObject)\n      }\n      return memberObject[memberProperty]\n\n    case OBJECT:\n      const objectResult = {}\n      for (const objectProperty of node.properties) {\n        // Expects each property to be of type PROPERTY.\n        objectResult[\n          (objectProperty.computed || objectProperty.key.type !== IDENTIFIER) ? run(objectProperty.key, context) : objectProperty.key.name\n        ] = run(objectProperty.value, context)\n      }\n      return objectResult\n\n    case SEQUENCE:\n      return node.expressions.map(node => run(node, context))\n\n    case UNARY:\n      const unaryParameter = run(node.parameter, context)\n      switch (node.operator) {\n        case '!':\n          return !unaryParameter\n        case '-':\n          return -unaryParameter\n        case '+':\n          return +unaryParameter\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case UPDATE:\n      const updateResult = run(node.parameter, context)\n      const updateValue = node.operator === '--' ? -1 : 1\n      setToContext(node.parameter, updateResult + updateValue, context)\n      return node.prefix ? updateResult + updateValue : updateResult\n  }\n\n  throw new Error('Unexpected node type \"' + node.type + '\".')\n}\n\nexport default run\n", "import _parse from './parse.js'\nimport _run from './run.js'\nimport {\n  ARRAY as _ARRAY,\n  ASSIGN as _ASSIGN,\n  BINARY as _BINARY,\n  CALL as _CALL,\n  CONDITION as _CONDITION,\n  IDENTIFIER as _IDENTIFIER,\n  LITERAL as _LITERAL,\n  MEMBER as _MEMBER,\n  OBJECT as _OBJECT,\n  PROPERTY as _PROPERTY,\n  SEQUENCE as _SEQUENCE,\n  UNARY as _UNARY,\n  UPDATE as _UPDATE,\n} from './types.js'\n\nexport const interpret = (\n  expression,\n  context,\n) => _run(_parse(expression), context)\nexport const parse = _parse\nexport const run = _run\n\nexport const ARRAY = _ARRAY\nexport const ASSIGN = _ASSIGN\nexport const BINARY = _BINARY\nexport const CALL = _CALL\nexport const CONDITION = _CONDITION\nexport const IDENTIFIER = _IDENTIFIER\nexport const LITERAL = _LITERAL\nexport const MEMBER = _MEMBER\nexport const OBJECT = _OBJECT\nexport const PROPERTY = _PROPERTY\nexport const SEQUENCE = _SEQUENCE\nexport const UNARY = _UNARY\nexport const UPDATE = _UPDATE\n\nexport default {\n  interpret,\n  parse: _parse,\n  run: _run,\n\n  ARRAY: _ARRAY,\n  ASSIGN: _ASSIGN,\n  BINARY: _BINARY,\n  CALL: _CALL,\n  CONDITION: _CONDITION,\n  IDENTIFIER: _IDENTIFIER,\n  LITERAL: _LITERAL,\n  MEMBER: _MEMBER,\n  OBJECT: _OBJECT,\n  PROPERTY: _PROPERTY,\n  SEQUENCE: _SEQUENCE,\n  UNARY: _UNARY,\n  UPDATE: _UPDATE,\n}\n", "import {\n  interpret,\n  parse,\n  run,\n} from './index.js'\n\nwindow.interpret = {\n  interpret,\n  parse,\n  run,\n}\n"],
  "mappings": ";;;;AAAO,MAAM,QAAQ;AACd,MAAM,SAAS;AACf,MAAM,SAAS;AACf,MAAM,OAAO;AACb,MAAM,YAAY;AAClB,MAAM,aAAa;AACnB,MAAM,UAAU;AAChB,MAAM,SAAS;AACf,MAAM,SAAS;AACf,MAAM,WAAW;AACjB,MAAM,WAAW;AACjB,MAAM,QAAQ;AACd,MAAM,SAAS;;;ACOtB,MAAM,cAAc;AAAA,IAClB;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,IACA;AAAA;AAAA,EACF;AACA,MAAM,2BAA2B;AACjC,MAAM,2BAA2B;AACjC,MAAM,aAAa;AACnB,MAAM,cAAc;AACpB,MAAM,aAAa;AACnB,MAAM,qBAAqB;AAC3B,MAAM,uBAAuB;AAC7B,MAAM,uBAAuB;AAC7B,MAAM,sBAAsB;AAG5B,MAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOF;AACA,MAAM,mBAAmB;AAAA,IACvB,KAAK;AAAA,IACL,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAON,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA;AAAA;AAAA;AAAA,IAIN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,EACP;AACA,MAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA;AAAA,IAEA;AAAA,EACF;AACA,MAAM,4BAA4B;AAClC,MAAM,4BAA4B;AAGlC,MAAM,WAAW;AAAA,IACf,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN;AAAA,EACF;AAEA,MAAM,iBAAiB,CACrB,cACI,aAAa,MAAM,aAAa;AAEtC,MAAM,mBAAmB,CACvB,cACG,kBAAkB,SAAS,KAAK,eAAe,SAAS;AAE7D,MAAM,oBAAoB,CACxB,cAEA,cAAc;AAAA,EACb,aAAa,MAAM,aAAa;AAAA,EACjC,cAAc;AAAA,EACb,aAAa,MAAM,aAAa;AAAA,EAChC,aAAa,MAAM,aAAa;AAEnC,MAAO,gBAAQ,CACb,eACG;AACH,QAAI,QAAQ;AAEZ,UAAM,cAAc,MACf;AACH;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU,iBAAiB,oBAAoB;AAAA,MACjD;AAAA,IACF;AAEA,UAAM,mBAAmB,CACvB,gBACG;AACH,YAAM,aAAa,CAAC;AACpB,UAAI,SAAS;AAEb,UAAI,iBAAiB;AACrB,aAAO,QAAQ,WAAW,QAAQ;AAChC,qBAAa;AACb,cAAM,iBAAiB,WAAW,WAAW,KAAK;AAElD,YAAI,mBAAmB,aAAa;AAClC,mBAAS;AACT;AAEA,cAAI,gBAAgB,4BAA4B,kBAAkB,kBAAkB,WAAW,QAAQ;AACrG,kBAAM,IAAI,MAAM,sBAAsB,OAAO,aAAa,WAAW,CAAC;AAAA,UACxE;AACA;AAAA,QACF,WAAW,mBAAmB,YAAY;AACxC;AACA;AAEA,cAAI,mBAAmB,WAAW,QAAQ;AACxC,gBAAI,gBAAgB,0BAA0B;AAC5C,oBAAM,IAAI,MAAM,oBAAoB;AAAA,YACtC,WAAW,gBAAgB,sBAAsB;AAC/C,uBAAS,IAAI,WAAW,QAAQ,IAAI,gBAAgB,KAAK;AACvD,2BAAW,KAAK,IAAI;AAAA,cACtB;AAAA,YACF;AAAA,UACF;AAAA,QACF,WAAW,WAAW,WAAW,kBAAkB,mBAAmB,GAAG;AACvE,gBAAM,IAAI,MAAM,gBAAgB;AAAA,QAClC,OAAO;AACL,gBAAM,OAAO,iBAAiB;AAE9B,cAAI,CAAC,MAAM;AACT,kBAAM,IAAI,MAAM,gBAAgB;AAAA,UAClC;AAEA,qBAAW,KAAK,IAAI;AAAA,QACtB;AAAA,MACF;AAEA,UAAI,CAAC,QAAQ;AACX,cAAM,IAAI,MAAM,cAAc,OAAO,aAAa,WAAW,CAAC;AAAA,MAChE;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,yBAAyB,MAC1B;AACH,UAAI,OAAO,YAAY;AACvB,UAAI,CAAC,MAAM;AACT,eAAO;AAAA,MACT;AAEA,UAAI,WAAW,sBAAsB;AACrC,UAAI,CAAC,UAAU;AACb,eAAO;AAAA,MACT;AAEA,UAAI,sBAAsB;AAAA,QACxB,OAAO;AAAA,QACP,YAAY,iBAAiB,QAAQ,KAAK;AAAA,MAC5C;AAEA,UAAI,QAAQ,YAAY;AACxB,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,+BAA+B,QAAQ;AAAA,MACzD;AAEA,YAAM,QAAQ;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI;AACJ,aAAQ,WAAW,sBAAsB,GAAI;AAC3C,cAAM,aAAa,iBAAiB,QAAQ,KAAK;AAEjD,YAAI,eAAe,GAAG;AACpB,mBAAS,SAAS;AAClB;AAAA,QACF;AAEA,8BAAsB;AAAA,UACpB,OAAO;AAAA,UACP;AAAA,QACF;AAEA,cAAM,yBAAyB;AAC/B,eAAO,MAAM,SAAS,KAAK,MAAM,MAAM,SAAS,CAAC,IAAI,YAAY;AAC/D,kBAAQ,MAAM,IAAI;AAClB,qBAAW,MAAM,IAAI,EAAE;AACvB,iBAAO,MAAM,IAAI;AACjB,iBAAO;AAAA,YACL,MAAM,qBAAqB,QAAQ,QAAQ,KAAK,IAC5C,SACA;AAAA,YACJ;AAAA,YACA;AAAA,YACA;AAAA,UACF;AACA,gBAAM,KAAK,IAAI;AAAA,QACjB;AAEA,eAAO,YAAY;AAEnB,YAAI,CAAC,MAAM;AACT,gBAAM,IAAI,MAAM,+BAA+B,sBAAsB;AAAA,QACvE;AAEA,cAAM,KAAK,qBAAqB,IAAI;AAAA,MACtC;AAEA,UAAI,IAAI,MAAM,SAAS;AACvB,aAAO,MAAM,CAAC;AAEd,aAAO,IAAI,GAAG;AACZ,mBAAW,MAAM,IAAI,CAAC,EAAE;AACxB,eAAO;AAAA,UACL,MAAM,qBAAqB,QAAQ,QAAQ,KAAK,IAC5C,SACA;AAAA,UACJ;AAAA,UACA,MAAM,MAAM,IAAI,CAAC;AAAA,UACjB,OAAO;AAAA,QACT;AACA,aAAK;AAAA,MACP;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,wBAAwB,MACzB;AACH,mBAAa;AACb,UAAI,UAAU,WAAW,UAAU,OAAO,QAAQ,CAAC;AACnD,UAAI,gBAAgB,QAAQ;AAE5B,aAAO,gBAAgB,GAAG;AACxB,YAAI,OAAO,UAAU,eAAe,KAAK,kBAAkB,OAAO,MAChE,CAAC,kBAAkB,WAAW,WAAW,KAAK,CAAC,KAC9C,QAAQ,QAAQ,SAAS,WAAW,UAAU,CAAC,iBAAiB,WAAW,WAAW,QAAQ,QAAQ,MAAM,CAAC,IAC7G;AACD,mBAAS;AACT,iBAAO;AAAA,QACT;AACA,kBAAU,QAAQ,UAAU,GAAG,EAAE,aAAa;AAAA,MAChD;AACA,aAAO;AAAA,IACT;AAEA,UAAM,mBAAmB,MACpB;AACH,UAAI,OAAO,uBAAuB;AAClC,mBAAa;AACb,aAAO,cAAc,IAAI;AACzB,aAAO;AAAA,IACT;AAEA,UAAM,oBAAoB,CACxB,uBACG;AACH,YAAMA,SAAQ,CAAC;AACf,aAAO,QAAQ,WAAW,QAAQ;AAChC,cAAM,iBAAiB,WAAW,WAAW,KAAK;AAClD,YACE,mBAAmB;AAAA,QACnB,mBAAmB,YACnB;AACA;AAAA,QACF,OAAO;AACL,gBAAM,OAAO,iBAAiB;AAC9B,cAAI,MAAM;AACR,YAAAA,OAAM,KAAK,IAAI;AAAA,UACjB,WAAW,QAAQ,WAAW,QAAQ;AACpC,gBAAI,mBAAmB,oBAAoB;AACzC;AAAA,YACF;AACA,kBAAM,IAAI,MAAM,iBAAiB,WAAW,OAAO,KAAK,IAAI,GAAG;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AACA,aAAOA;AAAA,IACT;AAEA,UAAM,mBAAmB,MACpB;AACH,UAAI,YAAY,WAAW,WAAW,KAAK;AAC3C,YAAM,QAAQ;AAEd,UAAI,kBAAkB,SAAS,GAAG;AAChC;AAAA,MACF,OAAO;AACL,cAAM,IAAI,MAAM,gBAAgB,WAAW,OAAO,KAAK,CAAC;AAAA,MAC1D;AAEA,aAAO,QAAQ,WAAW,QAAQ;AAChC,oBAAY,WAAW,WAAW,KAAK;AAEvC,YAAI,iBAAiB,SAAS,GAAG;AAC/B;AAAA,QACF,OAAO;AACL;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,MAAM,WAAW,MAAM,OAAO,KAAK;AAAA,MACrC;AAAA,IACF;AAEA,UAAM,uBAAuB,MACxB;AACH,UAAI,SAAS;AACb,aAAO,eAAe,WAAW,WAAW,KAAK,CAAC,GAAG;AACnD,kBAAU,WAAW,OAAO,OAAO;AAAA,MACrC;AACA,UAAI,WAAW,WAAW,KAAK,MAAM,aAAa;AAChD,kBAAU,WAAW,OAAO,OAAO;AACnC,eAAO,eAAe,WAAW,WAAW,KAAK,CAAC,GAAG;AACnD,oBAAU,WAAW,OAAO,OAAO;AAAA,QACrC;AAAA,MACF;AAEA,UAAI,YAAY,WAAW,OAAO,KAAK;AACvC,UAAI,cAAc,OAAO,cAAc,KAAK;AAC1C,kBAAU,WAAW,OAAO,OAAO;AACnC,oBAAY,WAAW,OAAO,KAAK;AAEnC,YAAI,cAAc,OAAO,cAAc,KAAK;AAC1C,oBAAU,WAAW,OAAO,OAAO;AAAA,QACrC;AAEA,eAAO,eAAe,WAAW,WAAW,KAAK,CAAC,GAAG;AACnD,oBAAU,WAAW,OAAO,OAAO;AAAA,QACrC;AAEA,YAAI,CAAC,eAAe,WAAW,WAAW,QAAQ,CAAC,CAAC,GAAG;AACrD,gBAAM,IAAI,MAAM,wBAAwB,SAAS,WAAW,OAAO,KAAK,IAAI,GAAG;AAAA,QACjF;AAAA,MACF;AAEA,YAAM,gBAAgB,WAAW,WAAW,KAAK;AACjD,UAAI,kBAAkB,aAAa,GAAG;AACpC,cAAM,IAAI,MAAM,gDAAgD,SAAS,WAAW,OAAO,KAAK,IAAI,GAAG;AAAA,MACzG,WACE,kBAAkB,eAEhB,OAAO,WAAW,KAClB,OAAO,WAAW,CAAC,MAAM,aAE3B;AACA,cAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,WAAW,MAAM;AAAA;AAAA,MAE1B;AAAA,IACF;AAEA,UAAM,yBAAyB,MAC1B;AAEH,UAAI,WAAW,WAAW,KAAK,MAAM,KAAK;AACxC;AAAA,MACF;AACA;AAEA,YAAM,aAAa,CAAC;AACpB,aAAO,CAAC,MAAM,WAAW,WAAW,KAAK,CAAC,GAAG;AAC3C,qBAAa;AACb,YAAI,WAAW,WAAW,KAAK,MAAM,qBAAqB;AACxD;AACA,iBAAO,oBAAoB;AAAA,YACzB,MAAM;AAAA,YACN;AAAA,UACF,CAAC;AAAA,QACH;AAEA,cAAM,MAAM,YAAY;AACxB,YAAI,CAAC,KAAK;AACR,gBAAM,IAAI,MAAM,WAAW;AAAA,QAC7B;AACA,qBAAa;AAEb,YACE,IAAI,SAAS,eAEX,WAAW,WAAW,KAAK,MAAM,cACjC,WAAW,WAAW,KAAK,MAAM,sBAEnC;AACA,qBAAW,KAAK;AAAA,YACd,MAAM;AAAA,YACN,UAAU;AAAA,YACV;AAAA,YACA,OAAO;AAAA,YACP,WAAW;AAAA,UACb,CAAC;AAAA,QACH,WAAW,WAAW,WAAW,KAAK,MAAM,YAAY;AACtD;AACA,uBAAa;AACb,gBAAM,QAAQ,iBAAiB;AAC/B,cAAI,CAAC,OAAO;AACV,kBAAM,IAAI,MAAM,4BAA4B;AAAA,UAC9C;AAEA,gBAAM,WAAW,IAAI,SAAS;AAC9B,qBAAW,KAAK;AAAA,YACd;AAAA,YACA,KAAK,WACD,IAAI,SAAS,CAAC,IACd;AAAA,YACJ,WAAW;AAAA,YACX,MAAM;AAAA,YACN;AAAA,UACF,CAAC;AACD,uBAAa;AAAA,QACf,WAAW,KAAK;AACd,qBAAW,KAAK,GAAG;AAAA,QACrB;AAEA,YAAI,WAAW,WAAW,KAAK,MAAM,YAAY;AAC/C;AAAA,QACF;AAAA,MACF;AACA,YAAM,IAAI,MAAM,WAAW;AAAA,IAC7B;AAEA,UAAM,iBAAiB,MAClB;AACH;AAEA,YAAMA,SAAQ,kBAAkB,wBAAwB;AACxD,UAAI,WAAW,WAAW,KAAK,MAAM,0BAA0B;AAC7D;AAEA,YAAIA,OAAM,WAAW,GAAG;AACtB,iBAAOA,OAAM,CAAC;AAAA,QAChB;AACA,YAAI,CAACA,OAAM,QAAQ;AACjB,iBAAO;AAAA,QACT;AAEA,eAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAaA;AAAA,QACf;AAAA,MACF;AAEA,YAAM,IAAI,MAAM,YAAY;AAAA,IAC9B;AAEA,UAAM,eAAe,MAChB;AACH,aAAO,YAAY,QAAQ,WAAW,WAAW,KAAK,CAAC,KAAK,GAAG;AAC7D;AAAA,MACF;AAAA,IACF;AAEA,UAAM,sBAAsB,MACvB;AACH,UAAI,SAAS;AAEb,YAAM,QAAQ,WAAW,OAAO,OAAO;AACvC,UAAI,SAAS;AAEb,aAAO,QAAQ,WAAW,QAAQ;AAChC,YAAI,YAAY,WAAW,OAAO,OAAO;AAEzC,YAAI,cAAc,OAAO;AACvB,mBAAS;AACT;AAAA,QACF;AACA,YAAI,cAAc,MAAM;AACtB,sBAAY,WAAW,OAAO,OAAO;AAErC,kBAAQ,WAAW;AAAA,YACjB,KAAK;AACH,wBAAU;AACV;AAAA,YAEF,KAAK;AACH,wBAAU;AACV;AAAA,YAEF,KAAK;AACH,wBAAU;AACV;AAAA,YAEF,KAAK;AACH,wBAAU;AACV;AAAA,YAEF,KAAK;AACH,wBAAU;AACV;AAAA,YAEF,KAAK;AACH,wBAAU;AACV;AAAA,YAEF;AACE,wBAAU;AAAA,UACd;AAAA,QACF,OAAO;AACL,oBAAU;AAAA,QACZ;AAAA,MACF;AAEA,UAAI,CAAC,QAAQ;AACX,cAAM,IAAI,MAAM,2BAA2B,SAAS,GAAG;AAAA,MACzD;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO;AAAA;AAAA,MAET;AAAA,IACF;AAEA,UAAM,gBAAgB,CACpB,SACG;AACH,UAAI,CAAC,QAAQ,WAAW,WAAW,KAAK,MAAM,oBAAoB;AAChE,eAAO;AAAA,MACT;AACA;AAEA,YAAM,aAAa,iBAAiB;AACpC,UAAI,CAAC,YAAY;AACf,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAEA,mBAAa;AAEb,UAAI,CAAC,WAAW,WAAW,KAAK,MAAM,YAAY;AAChD,cAAM,IAAI,MAAM,YAAY;AAAA,MAC9B;AACA;AAEA,YAAM,YAAY,iBAAiB;AACnC,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAEA,UAAI,cAAc;AAAA,QAChB,MAAM;AAAA,QACN,WAAW;AAAA,QACX;AAAA,QACA;AAAA,MACF;AAEA,UAAI,KAAK,YAAY,iBAAiB,KAAK,QAAQ,KAAK,GAAG;AACzD,YAAI,eAAe;AACnB,eAAO,aAAa,MAAM,YAAY,iBAAiB,aAAa,MAAM,QAAQ,KAAK,GAAG;AACxF,yBAAe,aAAa;AAAA,QAC9B;AACA,oBAAY,YAAY,aAAa;AACrC,qBAAa,QAAQ;AACrB,sBAAc;AAAA,MAChB;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,cAAc,MACf;AACH,UAAI,OAAO,uBAAuB,KAAK,6BAA6B;AACpE,UAAI,MAAM;AACR,eAAO,6BAA6B,IAAI;AAAA,MAC1C;AACA,mBAAa;AAEb,YAAM,YAAY,WAAW,WAAW,KAAK;AAC7C,UAAI,eAAe,SAAS,KAAK,cAAc,aAAa;AAC1D,eAAO,qBAAqB;AAAA,MAC9B;AAEA,UAAI,cAAc,MAAM,cAAc,IAAI;AACxC,eAAO,oBAAoB;AAAA,MAC7B,WAAW,cAAc,sBAAsB;AAC7C,eAAO,YAAY;AAAA,MACrB,OAAO;AACL,YAAI,UAAU,WAAW,UAAU,OAAO,QAAQ,CAAC;AACnD,YAAI,gBAAgB,QAAQ;AAE5B,eAAO,gBAAgB,GAAG;AACxB,cAAI,gBAAgB,QAAQ,OAAO,KAAK,MACtC,CAAC,kBAAkB,WAAW,WAAW,KAAK,CAAC,KAC9C,QAAQ,QAAQ,SAAS,WAAW,UAAU,CAAC,iBAAiB,WAAW,WAAW,QAAQ,QAAQ,MAAM,CAAC,IAC7G;AACD,qBAAS;AACT,kBAAM,YAAY,YAAY;AAC9B,gBAAI,CAAC,WAAW;AACd,oBAAM,IAAI,MAAM,mCAAmC;AAAA,YACrD;AACA,mBAAO,6BAA6B;AAAA,cAClC,MAAM;AAAA,cACN,UAAU;AAAA,cACV;AAAA,YACF,CAAC;AAAA,UACH;AAEA,oBAAU,QAAQ,OAAO,GAAG,EAAE,aAAa;AAAA,QAC7C;AAEA,YAAI,kBAAkB,SAAS,GAAG;AAChC,iBAAO,iBAAiB;AACxB,cAAI,OAAO,UAAU,eAAe,KAAK,UAAU,KAAK,IAAI,GAAG;AAC7D,mBAAO;AAAA,cACL,MAAM;AAAA,cACN,OAAO,SAAS,KAAK,IAAI;AAAA;AAAA,YAE3B;AAAA,UACF;AAAA,QACF,WAAW,cAAc,0BAA0B;AACjD,iBAAO,eAAe;AAAA,QACxB;AAAA,MACF;AAEA,aAAO;AAAA,QACL,oBAAoB,IAAI;AAAA,MAC1B;AAAA,IACF;AAEA,UAAM,sBAAsB,CAC1B,SACG;AACH,mBAAa;AAEb,UAAI,YAAY,WAAW,WAAW,KAAK;AAC3C,aACE,cAAc,eACd,cAAc,wBACd,cAAc,4BACd,cAAc,oBACd;AACA,YAAI;AACJ,YAAI,cAAc,oBAAoB;AACpC,cAAI,WAAW,WAAW,QAAQ,CAAC,MAAM,aAAa;AACpD;AAAA,UACF;AACA,qBAAW;AACX,mBAAS;AACT,uBAAa;AACb,sBAAY,WAAW,WAAW,KAAK;AAAA,QACzC;AACA;AAEA,YAAI,cAAc,sBAAsB;AACtC,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,UAAU;AAAA,YACV,QAAQ;AAAA,YACR,UAAU,iBAAiB;AAAA,UAC7B;AACA,uBAAa;AACb,sBAAY,WAAW,WAAW,KAAK;AACvC,cAAI,cAAc,sBAAsB;AACtC,kBAAM,IAAI,MAAM,YAAY;AAAA,UAC9B;AACA;AAAA,QACF,WAAW,cAAc,0BAA0B;AACjD,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,YAAY,iBAAiB,wBAAwB;AAAA,YACrD,QAAQ;AAAA,UACV;AAAA,QACF,WAAW,cAAc,eAAe,UAAU;AAChD,cAAI,UAAU;AACZ;AAAA,UACF;AACA,uBAAa;AACb,iBAAO;AAAA,YACL,MAAM;AAAA,YACN,UAAU;AAAA,YACV,QAAQ;AAAA,YACR,UAAU,iBAAiB;AAAA,UAC7B;AAAA,QACF;AAEA,YAAI,UAAU;AACZ,eAAK,WAAW;AAAA,QAClB;AAEA,qBAAa;AACb,oBAAY,WAAW,WAAW,KAAK;AAAA,MACzC;AAEA,aAAO;AAAA,IACT;AAEA,UAAM,+BAA+B,MAChC;AACH,UAAI,QAAQ,KAAK,WAAW,QAAQ;AAClC;AAAA,MACF;AAEA,YAAM,aAAa,WAAW,UAAU,OAAO,QAAQ,CAAC;AACxD,UAAI,WAAW;AACf,UAAI,eAAe,2BAA2B;AAC5C,mBAAW;AAAA,MACb,WAAW,eAAe,2BAA2B;AACnD,mBAAW;AAAA,MACb,OAAO;AACL;AAAA,MACF;AAEA,eAAS;AACT,YAAM,OAAO;AAAA,QACX,MAAM;AAAA,QACN;AAAA,QACA,WAAW,oBAAoB,iBAAiB,CAAC;AAAA,QACjD,QAAQ;AAAA,MACV;AACA,UAAI,CAAC,KAAK,aAAc,KAAK,UAAU,SAAS,cAAc,KAAK,UAAU,SAAS,QAAS;AAC7F,cAAM,IAAI,MAAM,gBAAgB,KAAK,QAAQ;AAAA,MAC/C;AACA,aAAO;AAAA,IACT;AAEA,UAAM,+BAA+B,CACnC,SACG;AACH,UAAI,CAAC,QAAQ,QAAQ,KAAK,WAAW,QAAQ;AAC3C,eAAO;AAAA,MACT;AAEA,YAAM,aAAa,WAAW,UAAU,OAAO,QAAQ,CAAC;AACxD,UAAI,WAAW;AACf,UAAI,eAAe,2BAA2B;AAC5C,mBAAW;AAAA,MACb,WAAW,eAAe,2BAA2B;AACnD,mBAAW;AAAA,MACb,OAAO;AACL,eAAO;AAAA,MACT;AAEA,eAAS;AACT,aAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA,WAAW;AAAA,QACX,QAAQ;AAAA,MACV;AACA,aAAO;AAAA,IACT;AAEA,UAAM,QAAQ,kBAAkB;AAChC,WAAO,MAAM,WAAW,IAAI,SAAY;AAAA,EAC1C;;;ACnxBA,MAAM,eAAe,CACnB,MACA,OACA,UAAU,CAAC,MACR;AACH,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AAEH,gBAAQ,KAAK,IAAI,IAAI;AACrB,eAAO;AAAA,MAET,KAAK;AACH,cAAM,eAAe,IAAI,KAAK,QAAQ,OAAO;AAC7C,cAAM,iBACJ,KAAK,YAAY,KAAK,SAAS,SAAS,aACpC,IAAI,KAAK,UAAU,OAAO,IAC1B,KAAK,SAAS;AACpB,YAAI,OAAQ,UAAW,YAAY;AACjC,iBAAO,MAAM,KAAK,YAAY;AAAA,QAChC;AACA,qBAAa,cAAc,IAAI;AAC/B,eAAO;AAAA,IACX;AAEA,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AAEA,MAAM,MAAM,CACV,MACA,UAAU,CAAC,MACR;AACH,QAAI,CAAC,MAAM;AACT;AAAA,IACF;AAEA,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,aAAO,KAAK,IAAI,CAAAC,UAAQ,IAAIA,OAAM,OAAO,CAAC;AAAA,IAC5C;AAEA,YAAQ,KAAK,MAAM;AAAA,MACjB,KAAK;AACH,eAAO,QAAQ,KAAK,IAAI;AAAA,MAE1B,KAAK;AACH,eAAO,KAAK;AAAA,MAEd,KAAK;AACH,cAAM,eAAe,CAAC;AACtB,mBAAW,gBAAgB,KAAK,UAAU;AACxC,uBAAa,KAAK,IAAI,cAAc,OAAO,CAAC;AAAA,QAC9C;AACA,eAAO;AAAA,MAET,KAAK;AACH,YAAI,kBAAkB,IAAI,KAAK,OAAO,OAAO;AAE7C,YAAI,KAAK,aAAa,KAAK;AACzB,gBAAM,iBAAiB,IAAI,KAAK,MAAM,OAAO;AAC7C,kBAAQ,KAAK,UAAU;AAAA,YACrB,KAAK;AACH,kBAAI,gBAAgB;AAClB,uBAAO;AAAA,cACT;AACA;AAAA,YACF,KAAK;AACH,kBAAI,CAAC,gBAAgB;AACnB,uBAAO;AAAA,cACT;AACA;AAAA,YACF,KAAK;AACH,kBAAI,mBAAmB,QAAQ,mBAAmB,QAAW;AAC3D,uBAAO;AAAA,cACT;AACA;AAAA,YACF,KAAK;AACH,gCAAkB,iBAAiB;AACnC;AAAA,YACF,KAAK;AACH,gCAAkB,sBAAkB;AACpC;AAAA,YACF,KAAK;AACH,gCAAkB,iBAAiB;AACnC;AAAA,YACF,KAAK;AACH,gCAAkB,iBAAiB;AACnC;AAAA,YACF,KAAK;AACH,gCAAkB,iBAAiB;AACnC;AAAA,YACF,KAAK;AACH,gCAAkB,iBAAiB;AACnC;AAAA,UACJ;AAAA,QACF;AACA,eAAO,aAAa,KAAK,MAAM,iBAAiB,OAAO;AAAA,MAEzD,KAAK;AACH,cAAM,aAAa,IAAI,KAAK,MAAM,OAAO;AACzC,cAAM,cAAc,IAAI,KAAK,OAAO,OAAO;AAC3C,gBAAQ,KAAK,UAAU;AAAA,UACrB,KAAK;AACH,mBAAO,cAAc;AAAA,UACvB,KAAK;AACH,mBAAO,cAAc;AAAA,UACvB,KAAK;AACH,mBAAO,kCAAc;AAAA,UACvB,KAAK;AAEH,mBAAO,cAAc;AAAA,UACvB,KAAK;AAEH,mBAAO,cAAc;AAAA,UACvB,KAAK;AACH,mBAAO,eAAe;AAAA,UACxB,KAAK;AACH,mBAAO,eAAe;AAAA,UACxB,KAAK;AACH,mBAAO,aAAa;AAAA,UACtB,KAAK;AACH,mBAAO,aAAa;AAAA,UACtB,KAAK;AACH,mBAAO,cAAc;AAAA,UACvB,KAAK;AACH,mBAAO,cAAc;AAAA,UACvB,KAAK;AACH,mBAAO,aAAa;AAAA,UACtB,KAAK;AACH,mBAAO,aAAa;AAAA,UACtB,KAAK;AACH,mBAAO,aAAa;AAAA,UACtB,KAAK;AACH,mBAAO,aAAa;AAAA,UACtB,KAAK;AACH,mBAAO,aAAa;AAAA,QACxB;AACA,cAAM,IAAI,MAAM,2BAA2B,KAAK,QAAQ;AAAA,MAE1D,KAAK;AACH,cAAM,aAAa,CAAC;AACpB,mBAAW,aAAa,KAAK,YAAY;AACvC,qBAAW,KAAK,IAAI,WAAW,OAAO,CAAC;AAAA,QACzC;AACA,eAAO,IAAI,KAAK,QAAQ,OAAO,EAAE,GAAG,UAAU;AAAA,MAEhD,KAAK;AACH,eAAO,IAAI,KAAK,WAAW,OAAO,IAC9B,IAAI,KAAK,YAAY,OAAO,IAC5B,IAAI,KAAK,WAAW,OAAO;AAAA,MAEjC,KAAK;AACH,cAAM,eAAe,IAAI,KAAK,QAAQ,OAAO;AAC7C,cAAM,iBACJ,KAAK,YAAY,KAAK,SAAS,SAAS,aACpC,IAAI,KAAK,UAAU,OAAO,IAC1B,KAAK,SAAS;AACpB,YAAI,OAAQ,aAAa,cAAc,MAAO,YAAY;AACxD,iBAAO,aAAa,cAAc,EAAE,KAAK,YAAY;AAAA,QACvD;AACA,eAAO,aAAa,cAAc;AAAA,MAEpC,KAAK;AACH,cAAM,eAAe,CAAC;AACtB,mBAAW,kBAAkB,KAAK,YAAY;AAE5C,uBACG,eAAe,YAAY,eAAe,IAAI,SAAS,aAAc,IAAI,eAAe,KAAK,OAAO,IAAI,eAAe,IAAI,IAC9H,IAAI,IAAI,eAAe,OAAO,OAAO;AAAA,QACvC;AACA,eAAO;AAAA,MAET,KAAK;AACH,eAAO,KAAK,YAAY,IAAI,CAAAA,UAAQ,IAAIA,OAAM,OAAO,CAAC;AAAA,MAExD,KAAK;AACH,cAAM,iBAAiB,IAAI,KAAK,WAAW,OAAO;AAClD,gBAAQ,KAAK,UAAU;AAAA,UACrB,KAAK;AACH,mBAAO,CAAC;AAAA,UACV,KAAK;AACH,mBAAO,CAAC;AAAA,UACV,KAAK;AACH,mBAAO,CAAC;AAAA,QACZ;AACA,cAAM,IAAI,MAAM,2BAA2B,KAAK,QAAQ;AAAA,MAE1D,KAAK;AACH,cAAM,eAAe,IAAI,KAAK,WAAW,OAAO;AAChD,cAAM,cAAc,KAAK,aAAa,OAAO,KAAK;AAClD,qBAAa,KAAK,WAAW,eAAe,aAAa,OAAO;AAChE,eAAO,KAAK,SAAS,eAAe,cAAc;AAAA,IACtD;AAEA,UAAM,IAAI,MAAM,2BAA2B,KAAK,OAAO,IAAI;AAAA,EAC7D;AAEA,MAAO,cAAQ;;;AChMR,MAAM,YAAY,CACvB,YACA,YACG,YAAK,cAAO,UAAU,GAAG,OAAO;AAC9B,MAAM,QAAQ;AACd,MAAMC,OAAM;;;ACjBnB,SAAO,YAAY;AAAA,IACjB;AAAA,IACA;AAAA,IACA,KAAAC;AAAA,EACF;",
  "names": ["nodes", "node", "run", "run"]
}
