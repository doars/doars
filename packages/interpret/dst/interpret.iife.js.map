{
  "version": 3,
  "sources": ["../src/types.js", "../src/parse.js", "../src/run.js", "../src/index.js", "../src/iife.js"],
  "sourcesContent": [
    "export const ARRAY = 5\nexport const ASSIGN = 6\nexport const BINARY = 7\nexport const CALL = 8\nexport const CONDITION = 9\nexport const IDENTIFIER = 2\nexport const LITERAL = 3\nexport const MEMBER = 10\nexport const OBJECT = 11\nexport const PROPERTY = 4\nexport const SEQUENCE = 12\nexport const UNARY = 13\nexport const UPDATE = 14\n\nexport default {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n}\n",
    "// Based on jsep, v1.3.6, https://github.com/EricSmekens/jsep#readme).\n\nimport {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n} from './types.js'\n\n// Character codes.\nconst SPACE_CODES = [\n  9, // Tab\n  10, // LF\n  13, // CR\n  32, // Space\n]\nconst OPENING_PARENTHESIS_CODE = 40 // (\nconst CLOSING_PARENTHESIS_CODE = 41 // )\nconst COMMA_CODE = 44 // ,\nconst PERIOD_CODE = 46 // .\nconst COLON_CODE = 58 // :\nconst QUESTION_MARK_CODE = 63 // ?\nconst OPENING_BRACKET_CODE = 91 // [\nconst CLOSING_BRACKET_CODE = 93 // ]\nconst CLOSING_BRACES_CODE = 125 // }\n\n// Operators.\nconst ASSIGNMENT_OPERATORS = [\n  '=',\n  '||=',\n  '&&=',\n  '??=',\n  '*=',\n  '**=',\n  '/=',\n  '%=',\n  '+=',\n  '-=',\n  // '<<=',\n  // '>>=',\n  // '>>>=',\n  // '&=',\n  // '^=',\n  // '|=',\n]\nconst BINARY_OPERATORS = {\n  '=': 1,\n  '||=': 1,\n  '&&=': 1,\n  '??=': 1,\n  '*=': 1,\n  '**=': 1,\n  '/=': 1,\n  '%=': 1,\n  '+=': 1,\n  '-=': 1,\n  // '<<=': 1,\n  // '>>=': 1,\n  // '>>>=': 1,\n  // '&=': 1,\n  // '^=': 1,\n  // '|=': 1,\n  '||': 2,\n  '&&': 3,\n  '??': 4,\n  // '|': 5,\n  // '^': 6,\n  // '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  // '<<': 10,\n  // '>>': 10,\n  // '>>>': 10,\n  '*': 11,\n  '/': 11,\n  '%': 11,\n  '+': 11,\n  '-': 11,\n}\nconst UNARY_OPERATORS = [\n  '-',\n  '!',\n  // '~',\n  '+',\n]\nconst UPDATE_OPERATOR_DECREMENT = '--'\nconst UPDATE_OPERATOR_INCREMENT = '++'\n\n// Literal lookup.\nconst LITERALS = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n}\n\nconst isDecimalDigit = (\n  character,\n) => (character >= 48 && character <= 57) // Between 0 and 9\n\nconst isIdentifierPart = (\n  character,\n) => isIdentifierStart(character) || isDecimalDigit(character)\n\nconst isIdentifierStart = (\n  character,\n) =>\n  character === 36 || // Dollar ($)\n  (character >= 48 && character <= 57) || // Between 0 and 9\n  character === 95 || // Underscore\n  (character >= 65 && character <= 90) || // Between A and Z\n  (character >= 97 && character <= 122) // Between a and z\n\nexport default (\n  expression,\n) => {\n  let index = 0\n\n  const gobbleArray = (\n  ) => {\n    index++\n\n    return {\n      type: ARRAY,\n      elements: gobbleParameters(CLOSING_BRACKET_CODE),\n    }\n  }\n\n  const gobbleParameters = (\n    termination,\n  ) => {\n    const parameters = []\n    let closed = false\n\n    let separatorCount = 0\n    while (index < expression.length) {\n      gobbleSpaces()\n      const characterIndex = expression.charCodeAt(index)\n\n      if (characterIndex === termination) {\n        closed = true\n        index++\n\n        if (termination === CLOSING_PARENTHESIS_CODE && separatorCount && separatorCount >= parameters.length) {\n          throw new Error('Unexpected token ' + String.fromCharCode(termination))\n        }\n        break\n      } else if (characterIndex === COMMA_CODE) {\n        index++\n        separatorCount++\n\n        if (separatorCount !== parameters.length) {\n          if (termination === CLOSING_PARENTHESIS_CODE) {\n            throw new Error('Unexpected token ,')\n          } else if (termination === CLOSING_BRACKET_CODE) {\n            for (let i = parameters.length; i < separatorCount; i++) {\n              parameters.push(null)\n            }\n          }\n        }\n      } else if (parameters.length !== separatorCount && separatorCount !== 0) {\n        throw new Error('Expected comma')\n      } else {\n        const node = gobbleExpression()\n\n        if (!node) {\n          throw new Error('Expected comma')\n        }\n\n        parameters.push(node)\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Expected ' + String.fromCharCode(termination))\n    }\n\n    return parameters\n  }\n\n  const gobbleBinaryExpression = (\n  ) => {\n    let left = gobbleToken()\n    if (!left) {\n      return left\n    }\n\n    let operator = gobbleBinaryOperation()\n    if (!operator) {\n      return left\n    }\n\n    let binaryOperationInfo = {\n      value: operator,\n      precedence: BINARY_OPERATORS[operator] || 0,\n    }\n\n    let right = gobbleToken()\n    if (!right) {\n      throw new Error('Expected expression after ' + operator)\n    }\n\n    const stack = [\n      left,\n      binaryOperationInfo,\n      right,\n    ]\n\n    let node\n    while ((operator = gobbleBinaryOperation())) {\n      const precedence = BINARY_OPERATORS[operator] || 0\n\n      if (precedence === 0) {\n        index -= operator.length\n        break\n      }\n\n      binaryOperationInfo = {\n        value: operator,\n        precedence,\n      }\n\n      const currentBinaryOperation = operator\n      while (stack.length > 2 && stack[stack.length - 2] > precedence) {\n        right = stack.pop()\n        operator = stack.pop().value\n        left = stack.pop()\n        node = {\n          type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n            ? ASSIGN\n            : BINARY,\n          operator,\n          left,\n          right,\n        }\n        stack.push(node)\n      }\n\n      node = gobbleToken()\n\n      if (!node) {\n        throw new Error('Expected expression after ' + currentBinaryOperation)\n      }\n\n      stack.push(binaryOperationInfo, node)\n    }\n\n    let i = stack.length - 1\n    node = stack[i]\n\n    while (i > 1) {\n      operator = stack[i - 1].value\n      node = {\n        type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n          ? ASSIGN\n          : BINARY,\n        operator,\n        left: stack[i - 2],\n        right: node,\n      }\n      i -= 2\n    }\n\n    return node\n  }\n\n  const gobbleBinaryOperation = (\n  ) => {\n    gobbleSpaces()\n    let toCheck = expression.substring(index, index + 3) // 3 = Maximum binary operator length.\n    let toCheckLength = toCheck.length\n\n    while (toCheckLength > 0) {\n      if (Object.prototype.hasOwnProperty.call(BINARY_OPERATORS, toCheck) && (\n        !isIdentifierStart(expression.charCodeAt(index)) ||\n        (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n      )) {\n        index += toCheckLength\n        return toCheck\n      }\n      toCheck = toCheck.substring(0, --toCheckLength)\n    }\n    return false\n  }\n\n  const gobbleExpression = (\n  ) => {\n    let node = gobbleBinaryExpression()\n    gobbleSpaces()\n    node = gobbleTernary(node)\n    return node\n  }\n\n  const gobbleExpressions = (\n    untilCharacterCode,\n  ) => {\n    const nodes = []\n    while (index < expression.length) {\n      const characterIndex = expression.charCodeAt(index)\n      if (\n        characterIndex === 59 || // Semicolon (;)\n        characterIndex === COMMA_CODE\n      ) {\n        index++\n      } else {\n        const node = gobbleExpression()\n        if (node) {\n          nodes.push(node)\n        } else if (index < expression.length) {\n          if (characterIndex === untilCharacterCode) {\n            break\n          }\n          throw new Error('Unexpected \"' + expression.charAt(index) + '\"')\n        }\n      }\n    }\n    return nodes\n  }\n\n  const gobbleIdentifier = (\n  ) => {\n    let character = expression.charCodeAt(index)\n    const start = index\n\n    if (isIdentifierStart(character)) {\n      index++\n    } else {\n      throw new Error('Unexpected ' + expression.charAt(index))\n    }\n\n    while (index < expression.length) {\n      character = expression.charCodeAt(index)\n\n      if (isIdentifierPart(character)) {\n        index++\n      } else {\n        break\n      }\n    }\n    return {\n      type: IDENTIFIER,\n      name: expression.slice(start, index),\n    }\n  }\n\n  const gobbleNumericLiteral = (\n  ) => {\n    let number = ''\n    while (isDecimalDigit(expression.charCodeAt(index))) {\n      number += expression.charAt(index++)\n    }\n    if (expression.charCodeAt(index) === PERIOD_CODE) {\n      number += expression.charAt(index++)\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n    }\n\n    let character = expression.charAt(index)\n    if (character === 'e' || character === 'E') {\n      number += expression.charAt(index++)\n      character = expression.charAt(index)\n\n      if (character === '+' || character === '-') {\n        number += expression.charAt(index++)\n      }\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n\n      if (!isDecimalDigit(expression.charCodeAt(index - 1))) {\n        throw new Error('Expected exponent (' + number + expression.charAt(index) + ')')\n      }\n    }\n\n    const characterCode = expression.charCodeAt(index)\n    if (isIdentifierStart(characterCode)) {\n      throw new Error('Variable names cannot start with a number (' + number + expression.charAt(index) + ')')\n    } else if (\n      characterCode === PERIOD_CODE ||\n      (\n        number.length === 1 &&\n        number.charCodeAt(0) === PERIOD_CODE\n      )\n    ) {\n      throw new Error('Unexpected period')\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(number),\n      // raw: number,\n    }\n  }\n\n  const gobbleObjectExpression = (\n  ) => {\n    // Check if opening brace \"{\"\n    if (expression.charCodeAt(index) !== 123) {\n      return\n    }\n    index++\n\n    const properties = []\n    while (!isNaN(expression.charCodeAt(index))) {\n      gobbleSpaces()\n      if (expression.charCodeAt(index) === CLOSING_BRACES_CODE) {\n        index++\n        return gobbleTokenProperty({\n          type: OBJECT,\n          properties,\n        })\n      }\n\n      const key = gobbleToken()\n      if (!key) {\n        throw new Error('Missing }')\n      }\n      gobbleSpaces()\n\n      if (\n        key.type === IDENTIFIER &&\n        (\n          expression.charCodeAt(index) === COMMA_CODE ||\n          expression.charCodeAt(index) === CLOSING_BRACES_CODE\n        )\n      ) {\n        properties.push({\n          type: PROPERTY,\n          computed: false,\n          key,\n          value: key,\n          shorthand: true,\n        })\n      } else if (expression.charCodeAt(index) === COLON_CODE) {\n        index++\n        gobbleSpaces()\n        const value = gobbleExpression()\n        if (!value) {\n          throw new Error('Unexpected object property')\n        }\n\n        const computed = key.type === ARRAY\n        properties.push({\n          computed,\n          key: computed\n            ? key.elements[0]\n            : key,\n          shorthand: false,\n          type: PROPERTY,\n          value,\n        })\n        gobbleSpaces()\n      } else if (key) {\n        properties.push(key)\n      }\n\n      if (expression.charCodeAt(index) === COMMA_CODE) {\n        index++\n      }\n    }\n    throw new Error('Missing }')\n  }\n\n  const gobbleSequence = (\n  ) => {\n    index++\n\n    const nodes = gobbleExpressions(CLOSING_PARENTHESIS_CODE)\n    if (expression.charCodeAt(index) === CLOSING_PARENTHESIS_CODE) {\n      index++\n\n      if (nodes.length === 1) {\n        return nodes[0]\n      }\n      if (!nodes.length) {\n        return false\n      }\n\n      return {\n        type: SEQUENCE,\n        expressions: nodes,\n      }\n    }\n\n    throw new Error('Unclosed (')\n  }\n\n  const gobbleSpaces = (\n  ) => {\n    while (SPACE_CODES.indexOf(expression.charCodeAt(index)) >= 0) {\n      index++\n    }\n  }\n\n  const gobbleStringLiteral = (\n  ) => {\n    let string = ''\n    // const startIndex = index\n    const quote = expression.charAt(index++)\n    let closed = false\n\n    while (index < expression.length) {\n      let character = expression.charAt(index++)\n\n      if (character === quote) {\n        closed = true\n        break\n      }\n      if (character === '\\\\') {\n        character = expression.charAt(index++)\n\n        switch (character) {\n          case 'n':\n            string += '\\n'\n            break\n\n          case 'r':\n            string += '\\r'\n            break\n\n          case 't':\n            string += '\\t'\n            break\n\n          case 'b':\n            string += '\\b'\n            break\n\n          case 'f':\n            string += '\\f'\n            break\n\n          case 'v':\n            string += '\\x0B'\n            break\n\n          default:\n            string += character\n        }\n      } else {\n        string += character\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Unclosed quote after \"' + string + '\"')\n    }\n\n    return {\n      type: LITERAL,\n      value: string,\n      // raw: expression.substring(startIndex, index),\n    }\n  }\n\n  const gobbleTernary = (\n    node,\n  ) => {\n    if (!node || expression.charCodeAt(index) !== QUESTION_MARK_CODE) {\n      return node\n    }\n    index++\n\n    const consequent = gobbleExpression()\n    if (!consequent) {\n      throw new Error('Expected expression')\n    }\n\n    gobbleSpaces()\n\n    if (!expression.charCodeAt(index) === COLON_CODE) {\n      throw new Error('Expected :')\n    }\n    index++\n\n    const alternate = gobbleExpression()\n    if (!alternate) {\n      throw new Error('Expected expression')\n    }\n\n    let conditional = {\n      type: CONDITION,\n      condition: node,\n      consequent,\n      alternate,\n    }\n\n    if (node.operator && BINARY_OPERATORS[node.operator] <= 1) {\n      let newCondition = node\n      while (newCondition.right.operator && BINARY_OPERATORS[newCondition.right.operator] <= 1) {\n        newCondition = newCondition.right\n      }\n      conditional.condition = newCondition.right\n      newCondition.right = conditional\n      conditional = node\n    }\n\n    return conditional\n  }\n\n  const gobbleToken = (\n  ) => {\n    let node = gobbleObjectExpression() || gobbleUpdatePrefixExpression()\n    if (node) {\n      return gobbleUpdateSuffixExpression(node)\n    }\n    gobbleSpaces()\n\n    const character = expression.charCodeAt(index)\n    if (isDecimalDigit(character) || character === PERIOD_CODE) {\n      return gobbleNumericLiteral()\n    }\n\n    if (character === 34 || character === 39) { // Double quote (\") or single quote (')\n      node = gobbleStringLiteral()\n    } else if (character === OPENING_BRACKET_CODE) {\n      node = gobbleArray()\n    } else {\n      let toCheck = expression.substring(index, index + 1) // 1 = Maximum unary operator length.\n      let toCheckLength = toCheck.length\n\n      while (toCheckLength > 0) {\n        if (UNARY_OPERATORS.indexOf(toCheck) >= 0 && (\n          !isIdentifierStart(expression.charCodeAt(index)) ||\n          (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n        )) {\n          index += toCheckLength\n          const parameter = gobbleToken()\n          if (!parameter) {\n            throw new Error('Missing unary operation parameter')\n          }\n          return gobbleUpdateSuffixExpression({\n            type: UNARY,\n            operator: toCheck,\n            parameter,\n          })\n        }\n\n        toCheck = toCheck.substr(0, --toCheckLength)\n      }\n\n      if (isIdentifierStart(character)) {\n        node = gobbleIdentifier()\n        if (Object.prototype.hasOwnProperty.call(LITERALS, node.name)) {\n          node = {\n            type: LITERAL,\n            value: LITERALS[node.name],\n            // raw: node.name,\n          }\n        }\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = gobbleSequence()\n      }\n    }\n\n    return gobbleUpdateSuffixExpression(\n      gobbleTokenProperty(node),\n    )\n  }\n\n  const gobbleTokenProperty = (\n    node,\n  ) => {\n    gobbleSpaces()\n\n    let character = expression.charCodeAt(index)\n    while (\n      character === PERIOD_CODE ||\n      character === OPENING_BRACKET_CODE ||\n      character === OPENING_PARENTHESIS_CODE ||\n      character === QUESTION_MARK_CODE\n    ) {\n      let optional\n      if (character === QUESTION_MARK_CODE) {\n        if (expression.charCodeAt(index + 1) !== PERIOD_CODE) {\n          break\n        }\n        optional = true\n        index += 2\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n      }\n      index++\n\n      if (character === OPENING_BRACKET_CODE) {\n        node = {\n          type: MEMBER,\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n        }\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n        if (character !== CLOSING_BRACKET_CODE) {\n          throw new Error('Unclosed [')\n        }\n        index++\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = {\n          type: CALL,\n          parameters: gobbleParameters(CLOSING_PARENTHESIS_CODE),\n          callee: node,\n        }\n      } else if (character === PERIOD_CODE || optional) {\n        if (optional) {\n          index--\n        }\n        gobbleSpaces()\n        node = {\n          type: MEMBER,\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n        }\n      }\n\n      if (optional) {\n        node.optional = true\n      }\n\n      gobbleSpaces()\n      character = expression.charCodeAt(index)\n    }\n\n    return node\n  }\n\n  const gobbleUpdatePrefixExpression = (\n  ) => {\n    if (index + 1 >= expression.length) {\n      return\n    }\n\n    const characters = expression.substring(index, index + 2) // 2 = Maximum update expression length\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return\n    }\n\n    index += 2\n    const node = {\n      type: UPDATE,\n      operator,\n      parameter: gobbleTokenProperty(gobbleIdentifier()),\n      prefix: true,\n    }\n    if (!node.parameter || (node.parameter.type !== IDENTIFIER && node.parameter.type !== MEMBER)) {\n      throw new Error('Unexpected ' + node.operator)\n    }\n    return node\n  }\n\n  const gobbleUpdateSuffixExpression = (\n    node,\n  ) => {\n    if (!node || index + 1 >= expression.length) {\n      return node\n    }\n\n    const characters = expression.substring(index, index + 2)\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return node\n    }\n\n    index += 2\n    node = {\n      type: UPDATE,\n      operator,\n      parameter: node,\n      prefix: false,\n    }\n    return node\n  }\n\n  const nodes = gobbleExpressions()\n  return nodes.length === 0 ? undefined : nodes\n}\n",
    "import {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n} from './types.js'\n\nconst setToContext = (\n  node,\n  value,\n  context = {},\n) => {\n  switch (node.type) {\n    case IDENTIFIER:\n      // Assign to\n      context[node.name] = value\n      return value\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (value) === 'function') {\n        return value.bind(memberObject)\n      }\n      memberObject[memberProperty] = value\n      return value\n  }\n\n  throw new Error('Unsupported assignment method.')\n}\n\nconst run = (\n  node,\n  context = {},\n) => {\n  if (!node) {\n    return\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(node => run(node, context))\n  }\n\n  switch (node.type) {\n    case IDENTIFIER:\n      return context[node.name]\n\n    case LITERAL:\n      return node.value\n\n    case ARRAY:\n      const arrayResults = []\n      for (const arrayElement of node.elements) {\n        arrayResults.push(run(arrayElement, context))\n      }\n      return arrayResults\n\n    case ASSIGN:\n      let assignmentValue = run(node.right, context)\n      // Modify value if not a direct assignment.\n      if (node.operator !== '=') {\n        const assignmentLeft = run(node.left, context)\n        switch (node.operator) {\n          case '||=':\n            if (assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '&&=':\n            if (!assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '??=':\n            if (assignmentLeft !== null && assignmentLeft !== undefined) {\n              return assignmentLeft\n            }\n            break\n          case '*=':\n            assignmentValue = assignmentLeft * assignmentValue\n            break\n          case '**=':\n            assignmentValue = assignmentLeft ** assignmentValue\n            break\n          case '/=':\n            assignmentValue = assignmentLeft / assignmentValue\n            break\n          case '%=':\n            assignmentValue = assignmentLeft % assignmentValue\n            break\n          case '+=':\n            assignmentValue = assignmentLeft + assignmentValue\n            break\n          case '-=':\n            assignmentValue = assignmentLeft - assignmentValue\n            break\n        }\n      }\n      return setToContext(node.left, assignmentValue, context)\n\n    case BINARY:\n      const binaryLeft = run(node.left, context)\n      const binaryRight = run(node.right, context)\n      switch (node.operator) {\n        case '||':\n          return binaryLeft || binaryRight\n        case '&&':\n          return binaryLeft && binaryRight\n        case '??':\n          return binaryLeft ?? binaryRight\n        case '==':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft == binaryRight\n        case '!=':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft != binaryRight\n        case '===':\n          return binaryLeft === binaryRight\n        case '!==':\n          return binaryLeft !== binaryRight\n        case '<':\n          return binaryLeft < binaryRight\n        case '>':\n          return binaryLeft > binaryRight\n        case '<=':\n          return binaryLeft <= binaryRight\n        case '>=':\n          return binaryLeft >= binaryRight\n        case '-':\n          return binaryLeft - binaryRight\n        case '+':\n          return binaryLeft + binaryRight\n        case '*':\n          return binaryLeft * binaryRight\n        case '/':\n          return binaryLeft / binaryRight\n        case '%':\n          return binaryLeft % binaryRight\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case CALL:\n      const parameters = []\n      for (const parameter of node.parameters) {\n        parameters.push(run(parameter, context))\n      }\n      return run(node.callee, context)(...parameters)\n\n    case CONDITION:\n      return run(node.condition, context)\n        ? run(node.consequent, context)\n        : run(node.alternate, context)\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (memberObject[memberProperty]) === 'function') {\n        return memberObject[memberProperty].bind(memberObject)\n      }\n      return memberObject[memberProperty]\n\n    case OBJECT:\n      const objectResult = {}\n      for (const objectProperty of node.properties) {\n        // Expects each property to be of type PROPERTY.\n        objectResult[\n          (objectProperty.computed || objectProperty.key.type !== IDENTIFIER) ? run(objectProperty.key, context) : objectProperty.key.name\n        ] = run(objectProperty.value, context)\n      }\n      return objectResult\n\n    case SEQUENCE:\n      return node.expressions.map(node => run(node, context))\n\n    case UNARY:\n      const unaryParameter = run(node.parameter, context)\n      switch (node.operator) {\n        case '!':\n          return !unaryParameter\n        case '-':\n          return -unaryParameter\n        case '+':\n          return +unaryParameter\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case UPDATE:\n      const updateResult = run(node.parameter, context)\n      const updateValue = node.operator === '--' ? -1 : 1\n      setToContext(node.parameter, updateResult + updateValue, context)\n      return node.prefix ? updateResult + updateValue : updateResult\n  }\n\n  throw new Error('Unexpected node type \"' + node.type + '\".')\n}\n\nexport default run\n",
    "import _parse from './parse.js'\nimport _run from './run.js'\nimport {\n  ARRAY as _ARRAY,\n  ASSIGN as _ASSIGN,\n  BINARY as _BINARY,\n  CALL as _CALL,\n  CONDITION as _CONDITION,\n  IDENTIFIER as _IDENTIFIER,\n  LITERAL as _LITERAL,\n  MEMBER as _MEMBER,\n  OBJECT as _OBJECT,\n  PROPERTY as _PROPERTY,\n  SEQUENCE as _SEQUENCE,\n  UNARY as _UNARY,\n  UPDATE as _UPDATE,\n} from './types.js'\n\nexport const interpret = (\n  expression,\n  context,\n) => _run(_parse(expression), context)\nexport const parse = _parse\nexport const run = _run\n\nexport const ARRAY = _ARRAY\nexport const ASSIGN = _ASSIGN\nexport const BINARY = _BINARY\nexport const CALL = _CALL\nexport const CONDITION = _CONDITION\nexport const IDENTIFIER = _IDENTIFIER\nexport const LITERAL = _LITERAL\nexport const MEMBER = _MEMBER\nexport const OBJECT = _OBJECT\nexport const PROPERTY = _PROPERTY\nexport const SEQUENCE = _SEQUENCE\nexport const UNARY = _UNARY\nexport const UPDATE = _UPDATE\n\nexport default {\n  interpret,\n  parse: _parse,\n  run: _run,\n\n  ARRAY: _ARRAY,\n  ASSIGN: _ASSIGN,\n  BINARY: _BINARY,\n  CALL: _CALL,\n  CONDITION: _CONDITION,\n  IDENTIFIER: _IDENTIFIER,\n  LITERAL: _LITERAL,\n  MEMBER: _MEMBER,\n  OBJECT: _OBJECT,\n  PROPERTY: _PROPERTY,\n  SEQUENCE: _SEQUENCE,\n  UNARY: _UNARY,\n  UPDATE: _UPDATE,\n}\n",
    "import {\n  interpret,\n  parse,\n  run,\n} from './index.js'\n\nwindow.interpret = {\n  interpret,\n  parse,\n  run,\n}\n"
  ],
  "mappings": ";;EAAO,IAAM,QAAQ;AAAA,EACd,IAAM,SAAS;AAAA,EACf,IAAM,SAAS;AAAA,EACf,IAAM,OAAO;AAAA,EACb,IAAM,YAAY;AAAA,EAClB,IAAM,aAAa;AAAA,EACnB,IAAM,UAAU;AAAA,EAChB,IAAM,SAAS;AAAA,EACf,IAAM,SAAS;AAAA,EACf,IAAM,WAAW;AAAA,EACjB,IAAM,WAAW;AAAA,EACjB,IAAM,QAAQ;AAAA,EACd,IAAM,SAAS;;;ECOtB,IAAM,cAAc;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA,EACA,IAAM,2BAA2B;AAAA,EACjC,IAAM,2BAA2B;AAAA,EACjC,IAAM,aAAa;AAAA,EACnB,IAAM,cAAc;AAAA,EACpB,IAAM,aAAa;AAAA,EACnB,IAAM,qBAAqB;AAAA,EAC3B,IAAM,uBAAuB;AAAA,EAC7B,IAAM,uBAAuB;AAAA,EAC7B,IAAM,sBAAsB;AAAA,EAG5B,IAAM,uBAAuB;AAAA,IAC3B;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EAOF;AAAA,EACA,IAAM,mBAAmB;AAAA,IACvB,KAAK;AAAA,IACL,OAAO;AAAA,IACP,OAAO;AAAA,IACP,OAAO;AAAA,IACP,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IAON,MAAM;AAAA,IACN,MAAM;AAAA,IACN,MAAM;AAAA,IAIN,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO;AAAA,IACP,OAAO;AAAA,IACP,KAAK;AAAA,IACL,KAAK;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IAIN,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,EACP;AAAA,EACA,IAAM,kBAAkB;AAAA,IACtB;AAAA,IACA;AAAA,IAEA;AAAA,EACF;AAAA,EACA,IAAM,4BAA4B;AAAA,EAClC,IAAM,4BAA4B;AAAA,EAGlC,IAAM,WAAW;AAAA,IACf,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,IACN;AAAA,EACF;AAAA,EAEA,IAAM,iBAAiB,CACrB,cACI,aAAa,MAAM,aAAa;AAAA,EAEtC,IAAM,mBAAmB,CACvB,cACG,kBAAkB,SAAS,KAAK,eAAe,SAAS;AAAA,EAE7D,IAAM,oBAAoB,CACxB,cAEA,cAAc,MACb,aAAa,MAAM,aAAa,MACjC,cAAc,MACb,aAAa,MAAM,aAAa,MAChC,aAAa,MAAM,aAAa;AAAA,EAEnC,IAAe,iBACb,eACG;AAAA,IACH,IAAI,QAAQ;AAAA,IAEZ,MAAM,cAAc,MACf;AAAA,MACH;AAAA,MAEA,OAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU,iBAAiB,oBAAoB;AAAA,MACjD;AAAA;AAAA,IAGF,MAAM,mBAAmB,CACvB,gBACG;AAAA,MACH,MAAM,aAAa,CAAC;AAAA,MACpB,IAAI,SAAS;AAAA,MAEb,IAAI,iBAAiB;AAAA,MACrB,OAAO,QAAQ,WAAW,QAAQ;AAAA,QAChC,aAAa;AAAA,QACb,MAAM,iBAAiB,WAAW,WAAW,KAAK;AAAA,QAElD,IAAI,mBAAmB,aAAa;AAAA,UAClC,SAAS;AAAA,UACT;AAAA,UAEA,IAAI,gBAAgB,4BAA4B,kBAAkB,kBAAkB,WAAW,QAAQ;AAAA,YACrG,MAAM,IAAI,MAAM,sBAAsB,OAAO,aAAa,WAAW,CAAC;AAAA,UACxE;AAAA,UACA;AAAA,QACF,EAAO,SAAI,mBAAmB,YAAY;AAAA,UACxC;AAAA,UACA;AAAA,UAEA,IAAI,mBAAmB,WAAW,QAAQ;AAAA,YACxC,IAAI,gBAAgB,0BAA0B;AAAA,cAC5C,MAAM,IAAI,MAAM,oBAAoB;AAAA,YACtC,EAAO,SAAI,gBAAgB,sBAAsB;AAAA,cAC/C,SAAS,IAAI,WAAW,OAAQ,IAAI,gBAAgB,KAAK;AAAA,gBACvD,WAAW,KAAK,IAAI;AAAA,cACtB;AAAA,YACF;AAAA,UACF;AAAA,QACF,EAAO,SAAI,WAAW,WAAW,kBAAkB,mBAAmB,GAAG;AAAA,UACvE,MAAM,IAAI,MAAM,gBAAgB;AAAA,QAClC,EAAO;AAAA,UACL,MAAM,OAAO,iBAAiB;AAAA,UAE9B,IAAI,CAAC,MAAM;AAAA,YACT,MAAM,IAAI,MAAM,gBAAgB;AAAA,UAClC;AAAA,UAEA,WAAW,KAAK,IAAI;AAAA;AAAA,MAExB;AAAA,MAEA,IAAI,CAAC,QAAQ;AAAA,QACX,MAAM,IAAI,MAAM,cAAc,OAAO,aAAa,WAAW,CAAC;AAAA,MAChE;AAAA,MAEA,OAAO;AAAA;AAAA,IAGT,MAAM,yBAAyB,MAC1B;AAAA,MACH,IAAI,OAAO,YAAY;AAAA,MACvB,IAAI,CAAC,MAAM;AAAA,QACT,OAAO;AAAA,MACT;AAAA,MAEA,IAAI,WAAW,sBAAsB;AAAA,MACrC,IAAI,CAAC,UAAU;AAAA,QACb,OAAO;AAAA,MACT;AAAA,MAEA,IAAI,sBAAsB;AAAA,QACxB,OAAO;AAAA,QACP,YAAY,iBAAiB,aAAa;AAAA,MAC5C;AAAA,MAEA,IAAI,QAAQ,YAAY;AAAA,MACxB,IAAI,CAAC,OAAO;AAAA,QACV,MAAM,IAAI,MAAM,+BAA+B,QAAQ;AAAA,MACzD;AAAA,MAEA,MAAM,QAAQ;AAAA,QACZ;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MAEA,IAAI;AAAA,MACJ,OAAQ,WAAW,sBAAsB,GAAI;AAAA,QAC3C,MAAM,aAAa,iBAAiB,aAAa;AAAA,QAEjD,IAAI,eAAe,GAAG;AAAA,UACpB,SAAS,SAAS;AAAA,UAClB;AAAA,QACF;AAAA,QAEA,sBAAsB;AAAA,UACpB,OAAO;AAAA,UACP;AAAA,QACF;AAAA,QAEA,MAAM,yBAAyB;AAAA,QAC/B,OAAO,MAAM,SAAS,KAAK,MAAM,MAAM,SAAS,KAAK,YAAY;AAAA,UAC/D,QAAQ,MAAM,IAAI;AAAA,UAClB,WAAW,MAAM,IAAI,EAAE;AAAA,UACvB,OAAO,MAAM,IAAI;AAAA,UACjB,OAAO;AAAA,YACL,MAAM,qBAAqB,QAAQ,QAAQ,KAAK,IAC5C,SACA;AAAA,YACJ;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACA,MAAM,KAAK,IAAI;AAAA,QACjB;AAAA,QAEA,OAAO,YAAY;AAAA,QAEnB,IAAI,CAAC,MAAM;AAAA,UACT,MAAM,IAAI,MAAM,+BAA+B,sBAAsB;AAAA,QACvE;AAAA,QAEA,MAAM,KAAK,qBAAqB,IAAI;AAAA,MACtC;AAAA,MAEA,IAAI,IAAI,MAAM,SAAS;AAAA,MACvB,OAAO,MAAM;AAAA,MAEb,OAAO,IAAI,GAAG;AAAA,QACZ,WAAW,MAAM,IAAI,GAAG;AAAA,QACxB,OAAO;AAAA,UACL,MAAM,qBAAqB,QAAQ,QAAQ,KAAK,IAC5C,SACA;AAAA,UACJ;AAAA,UACA,MAAM,MAAM,IAAI;AAAA,UAChB,OAAO;AAAA,QACT;AAAA,QACA,KAAK;AAAA,MACP;AAAA,MAEA,OAAO;AAAA;AAAA,IAGT,MAAM,wBAAwB,MACzB;AAAA,MACH,aAAa;AAAA,MACb,IAAI,UAAU,WAAW,UAAU,OAAO,QAAQ,CAAC;AAAA,MACnD,IAAI,gBAAgB,QAAQ;AAAA,MAE5B,OAAO,gBAAgB,GAAG;AAAA,QACxB,IAAI,OAAO,UAAU,eAAe,KAAK,kBAAkB,OAAO,MAChE,CAAC,kBAAkB,WAAW,WAAW,KAAK,CAAC,KAC9C,QAAQ,QAAQ,SAAS,WAAW,UAAU,CAAC,iBAAiB,WAAW,WAAW,QAAQ,QAAQ,MAAM,CAAC,IAC7G;AAAA,UACD,SAAS;AAAA,UACT,OAAO;AAAA,QACT;AAAA,QACA,UAAU,QAAQ,UAAU,GAAG,EAAE,aAAa;AAAA,MAChD;AAAA,MACA,OAAO;AAAA;AAAA,IAGT,MAAM,mBAAmB,MACpB;AAAA,MACH,IAAI,OAAO,uBAAuB;AAAA,MAClC,aAAa;AAAA,MACb,OAAO,cAAc,IAAI;AAAA,MACzB,OAAO;AAAA;AAAA,IAGT,MAAM,oBAAoB,CACxB,uBACG;AAAA,MACH,MAAM,SAAQ,CAAC;AAAA,MACf,OAAO,QAAQ,WAAW,QAAQ;AAAA,QAChC,MAAM,iBAAiB,WAAW,WAAW,KAAK;AAAA,QAClD,IACE,mBAAmB,MACnB,mBAAmB,YACnB;AAAA,UACA;AAAA,QACF,EAAO;AAAA,UACL,MAAM,OAAO,iBAAiB;AAAA,UAC9B,IAAI,MAAM;AAAA,YACR,OAAM,KAAK,IAAI;AAAA,UACjB,EAAO,SAAI,QAAQ,WAAW,QAAQ;AAAA,YACpC,IAAI,mBAAmB,oBAAoB;AAAA,cACzC;AAAA,YACF;AAAA,YACA,MAAM,IAAI,MAAM,iBAAiB,WAAW,OAAO,KAAK,IAAI,GAAG;AAAA,UACjE;AAAA;AAAA,MAEJ;AAAA,MACA,OAAO;AAAA;AAAA,IAGT,MAAM,mBAAmB,MACpB;AAAA,MACH,IAAI,YAAY,WAAW,WAAW,KAAK;AAAA,MAC3C,MAAM,QAAQ;AAAA,MAEd,IAAI,kBAAkB,SAAS,GAAG;AAAA,QAChC;AAAA,MACF,EAAO;AAAA,QACL,MAAM,IAAI,MAAM,gBAAgB,WAAW,OAAO,KAAK,CAAC;AAAA;AAAA,MAG1D,OAAO,QAAQ,WAAW,QAAQ;AAAA,QAChC,YAAY,WAAW,WAAW,KAAK;AAAA,QAEvC,IAAI,iBAAiB,SAAS,GAAG;AAAA,UAC/B;AAAA,QACF,EAAO;AAAA,UACL;AAAA;AAAA,MAEJ;AAAA,MACA,OAAO;AAAA,QACL,MAAM;AAAA,QACN,MAAM,WAAW,MAAM,OAAO,KAAK;AAAA,MACrC;AAAA;AAAA,IAGF,MAAM,uBAAuB,MACxB;AAAA,MACH,IAAI,SAAS;AAAA,MACb,OAAO,eAAe,WAAW,WAAW,KAAK,CAAC,GAAG;AAAA,QACnD,UAAU,WAAW,OAAO,OAAO;AAAA,MACrC;AAAA,MACA,IAAI,WAAW,WAAW,KAAK,MAAM,aAAa;AAAA,QAChD,UAAU,WAAW,OAAO,OAAO;AAAA,QACnC,OAAO,eAAe,WAAW,WAAW,KAAK,CAAC,GAAG;AAAA,UACnD,UAAU,WAAW,OAAO,OAAO;AAAA,QACrC;AAAA,MACF;AAAA,MAEA,IAAI,YAAY,WAAW,OAAO,KAAK;AAAA,MACvC,IAAI,cAAc,OAAO,cAAc,KAAK;AAAA,QAC1C,UAAU,WAAW,OAAO,OAAO;AAAA,QACnC,YAAY,WAAW,OAAO,KAAK;AAAA,QAEnC,IAAI,cAAc,OAAO,cAAc,KAAK;AAAA,UAC1C,UAAU,WAAW,OAAO,OAAO;AAAA,QACrC;AAAA,QAEA,OAAO,eAAe,WAAW,WAAW,KAAK,CAAC,GAAG;AAAA,UACnD,UAAU,WAAW,OAAO,OAAO;AAAA,QACrC;AAAA,QAEA,IAAI,CAAC,eAAe,WAAW,WAAW,QAAQ,CAAC,CAAC,GAAG;AAAA,UACrD,MAAM,IAAI,MAAM,wBAAwB,SAAS,WAAW,OAAO,KAAK,IAAI,GAAG;AAAA,QACjF;AAAA,MACF;AAAA,MAEA,MAAM,gBAAgB,WAAW,WAAW,KAAK;AAAA,MACjD,IAAI,kBAAkB,aAAa,GAAG;AAAA,QACpC,MAAM,IAAI,MAAM,gDAAgD,SAAS,WAAW,OAAO,KAAK,IAAI,GAAG;AAAA,MACzG,EAAO,SACL,kBAAkB,eAEhB,OAAO,WAAW,KAClB,OAAO,WAAW,CAAC,MAAM,aAE3B;AAAA,QACA,MAAM,IAAI,MAAM,mBAAmB;AAAA,MACrC;AAAA,MAEA,OAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO,WAAW,MAAM;AAAA,MAE1B;AAAA;AAAA,IAGF,MAAM,yBAAyB,MAC1B;AAAA,MAEH,IAAI,WAAW,WAAW,KAAK,MAAM,KAAK;AAAA,QACxC;AAAA,MACF;AAAA,MACA;AAAA,MAEA,MAAM,aAAa,CAAC;AAAA,MACpB,OAAO,CAAC,MAAM,WAAW,WAAW,KAAK,CAAC,GAAG;AAAA,QAC3C,aAAa;AAAA,QACb,IAAI,WAAW,WAAW,KAAK,MAAM,qBAAqB;AAAA,UACxD;AAAA,UACA,OAAO,oBAAoB;AAAA,YACzB,MAAM;AAAA,YACN;AAAA,UACF,CAAC;AAAA,QACH;AAAA,QAEA,MAAM,MAAM,YAAY;AAAA,QACxB,IAAI,CAAC,KAAK;AAAA,UACR,MAAM,IAAI,MAAM,WAAW;AAAA,QAC7B;AAAA,QACA,aAAa;AAAA,QAEb,IACE,IAAI,SAAS,eAEX,WAAW,WAAW,KAAK,MAAM,cACjC,WAAW,WAAW,KAAK,MAAM,sBAEnC;AAAA,UACA,WAAW,KAAK;AAAA,YACd,MAAM;AAAA,YACN,UAAU;AAAA,YACV;AAAA,YACA,OAAO;AAAA,YACP,WAAW;AAAA,UACb,CAAC;AAAA,QACH,EAAO,SAAI,WAAW,WAAW,KAAK,MAAM,YAAY;AAAA,UACtD;AAAA,UACA,aAAa;AAAA,UACb,MAAM,QAAQ,iBAAiB;AAAA,UAC/B,IAAI,CAAC,OAAO;AAAA,YACV,MAAM,IAAI,MAAM,4BAA4B;AAAA,UAC9C;AAAA,UAEA,MAAM,WAAW,IAAI,SAAS;AAAA,UAC9B,WAAW,KAAK;AAAA,YACd;AAAA,YACA,KAAK,WACD,IAAI,SAAS,KACb;AAAA,YACJ,WAAW;AAAA,YACX,MAAM;AAAA,YACN;AAAA,UACF,CAAC;AAAA,UACD,aAAa;AAAA,QACf,EAAO,SAAI,KAAK;AAAA,UACd,WAAW,KAAK,GAAG;AAAA,QACrB;AAAA,QAEA,IAAI,WAAW,WAAW,KAAK,MAAM,YAAY;AAAA,UAC/C;AAAA,QACF;AAAA,MACF;AAAA,MACA,MAAM,IAAI,MAAM,WAAW;AAAA;AAAA,IAG7B,MAAM,iBAAiB,MAClB;AAAA,MACH;AAAA,MAEA,MAAM,SAAQ,kBAAkB,wBAAwB;AAAA,MACxD,IAAI,WAAW,WAAW,KAAK,MAAM,0BAA0B;AAAA,QAC7D;AAAA,QAEA,IAAI,OAAM,WAAW,GAAG;AAAA,UACtB,OAAO,OAAM;AAAA,QACf;AAAA,QACA,IAAI,CAAC,OAAM,QAAQ;AAAA,UACjB,OAAO;AAAA,QACT;AAAA,QAEA,OAAO;AAAA,UACL,MAAM;AAAA,UACN,aAAa;AAAA,QACf;AAAA,MACF;AAAA,MAEA,MAAM,IAAI,MAAM,YAAY;AAAA;AAAA,IAG9B,MAAM,eAAe,MAChB;AAAA,MACH,OAAO,YAAY,QAAQ,WAAW,WAAW,KAAK,CAAC,KAAK,GAAG;AAAA,QAC7D;AAAA,MACF;AAAA;AAAA,IAGF,MAAM,sBAAsB,MACvB;AAAA,MACH,IAAI,SAAS;AAAA,MAEb,MAAM,QAAQ,WAAW,OAAO,OAAO;AAAA,MACvC,IAAI,SAAS;AAAA,MAEb,OAAO,QAAQ,WAAW,QAAQ;AAAA,QAChC,IAAI,YAAY,WAAW,OAAO,OAAO;AAAA,QAEzC,IAAI,cAAc,OAAO;AAAA,UACvB,SAAS;AAAA,UACT;AAAA,QACF;AAAA,QACA,IAAI,cAAc,MAAM;AAAA,UACtB,YAAY,WAAW,OAAO,OAAO;AAAA,UAErC,QAAQ;AAAA,iBACD;AAAA,cACH,UAAU;AAAA;AAAA,cACV;AAAA,iBAEG;AAAA,cACH,UAAU;AAAA,cACV;AAAA,iBAEG;AAAA,cACH,UAAU;AAAA,cACV;AAAA,iBAEG;AAAA,cACH,UAAU;AAAA,cACV;AAAA,iBAEG;AAAA,cACH,UAAU;AAAA,cACV;AAAA,iBAEG;AAAA,cACH,UAAU;AAAA,cACV;AAAA;AAAA,cAGA,UAAU;AAAA;AAAA,QAEhB,EAAO;AAAA,UACL,UAAU;AAAA;AAAA,MAEd;AAAA,MAEA,IAAI,CAAC,QAAQ;AAAA,QACX,MAAM,IAAI,MAAM,2BAA2B,SAAS,GAAG;AAAA,MACzD;AAAA,MAEA,OAAO;AAAA,QACL,MAAM;AAAA,QACN,OAAO;AAAA,MAET;AAAA;AAAA,IAGF,MAAM,gBAAgB,CACpB,SACG;AAAA,MACH,IAAI,CAAC,QAAQ,WAAW,WAAW,KAAK,MAAM,oBAAoB;AAAA,QAChE,OAAO;AAAA,MACT;AAAA,MACA;AAAA,MAEA,MAAM,aAAa,iBAAiB;AAAA,MACpC,IAAI,CAAC,YAAY;AAAA,QACf,MAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAAA,MAEA,aAAa;AAAA,MAEb,IAAI,CAAC,WAAW,WAAW,KAAK,MAAM,YAAY;AAAA,QAChD,MAAM,IAAI,MAAM,YAAY;AAAA,MAC9B;AAAA,MACA;AAAA,MAEA,MAAM,YAAY,iBAAiB;AAAA,MACnC,IAAI,CAAC,WAAW;AAAA,QACd,MAAM,IAAI,MAAM,qBAAqB;AAAA,MACvC;AAAA,MAEA,IAAI,cAAc;AAAA,QAChB,MAAM;AAAA,QACN,WAAW;AAAA,QACX;AAAA,QACA;AAAA,MACF;AAAA,MAEA,IAAI,KAAK,YAAY,iBAAiB,KAAK,aAAa,GAAG;AAAA,QACzD,IAAI,eAAe;AAAA,QACnB,OAAO,aAAa,MAAM,YAAY,iBAAiB,aAAa,MAAM,aAAa,GAAG;AAAA,UACxF,eAAe,aAAa;AAAA,QAC9B;AAAA,QACA,YAAY,YAAY,aAAa;AAAA,QACrC,aAAa,QAAQ;AAAA,QACrB,cAAc;AAAA,MAChB;AAAA,MAEA,OAAO;AAAA;AAAA,IAGT,MAAM,cAAc,MACf;AAAA,MACH,IAAI,OAAO,uBAAuB,KAAK,6BAA6B;AAAA,MACpE,IAAI,MAAM;AAAA,QACR,OAAO,6BAA6B,IAAI;AAAA,MAC1C;AAAA,MACA,aAAa;AAAA,MAEb,MAAM,YAAY,WAAW,WAAW,KAAK;AAAA,MAC7C,IAAI,eAAe,SAAS,KAAK,cAAc,aAAa;AAAA,QAC1D,OAAO,qBAAqB;AAAA,MAC9B;AAAA,MAEA,IAAI,cAAc,MAAM,cAAc,IAAI;AAAA,QACxC,OAAO,oBAAoB;AAAA,MAC7B,EAAO,SAAI,cAAc,sBAAsB;AAAA,QAC7C,OAAO,YAAY;AAAA,MACrB,EAAO;AAAA,QACL,IAAI,UAAU,WAAW,UAAU,OAAO,QAAQ,CAAC;AAAA,QACnD,IAAI,gBAAgB,QAAQ;AAAA,QAE5B,OAAO,gBAAgB,GAAG;AAAA,UACxB,IAAI,gBAAgB,QAAQ,OAAO,KAAK,MACtC,CAAC,kBAAkB,WAAW,WAAW,KAAK,CAAC,KAC9C,QAAQ,QAAQ,SAAS,WAAW,UAAU,CAAC,iBAAiB,WAAW,WAAW,QAAQ,QAAQ,MAAM,CAAC,IAC7G;AAAA,YACD,SAAS;AAAA,YACT,MAAM,YAAY,YAAY;AAAA,YAC9B,IAAI,CAAC,WAAW;AAAA,cACd,MAAM,IAAI,MAAM,mCAAmC;AAAA,YACrD;AAAA,YACA,OAAO,6BAA6B;AAAA,cAClC,MAAM;AAAA,cACN,UAAU;AAAA,cACV;AAAA,YACF,CAAC;AAAA,UACH;AAAA,UAEA,UAAU,QAAQ,OAAO,GAAG,EAAE,aAAa;AAAA,QAC7C;AAAA,QAEA,IAAI,kBAAkB,SAAS,GAAG;AAAA,UAChC,OAAO,iBAAiB;AAAA,UACxB,IAAI,OAAO,UAAU,eAAe,KAAK,UAAU,KAAK,IAAI,GAAG;AAAA,YAC7D,OAAO;AAAA,cACL,MAAM;AAAA,cACN,OAAO,SAAS,KAAK;AAAA,YAEvB;AAAA,UACF;AAAA,QACF,EAAO,SAAI,cAAc,0BAA0B;AAAA,UACjD,OAAO,eAAe;AAAA,QACxB;AAAA;AAAA,MAGF,OAAO,6BACL,oBAAoB,IAAI,CAC1B;AAAA;AAAA,IAGF,MAAM,sBAAsB,CAC1B,SACG;AAAA,MACH,aAAa;AAAA,MAEb,IAAI,YAAY,WAAW,WAAW,KAAK;AAAA,MAC3C,OACE,cAAc,eACd,cAAc,wBACd,cAAc,4BACd,cAAc,oBACd;AAAA,QACA,IAAI;AAAA,QACJ,IAAI,cAAc,oBAAoB;AAAA,UACpC,IAAI,WAAW,WAAW,QAAQ,CAAC,MAAM,aAAa;AAAA,YACpD;AAAA,UACF;AAAA,UACA,WAAW;AAAA,UACX,SAAS;AAAA,UACT,aAAa;AAAA,UACb,YAAY,WAAW,WAAW,KAAK;AAAA,QACzC;AAAA,QACA;AAAA,QAEA,IAAI,cAAc,sBAAsB;AAAA,UACtC,OAAO;AAAA,YACL,MAAM;AAAA,YACN,UAAU;AAAA,YACV,QAAQ;AAAA,YACR,UAAU,iBAAiB;AAAA,UAC7B;AAAA,UACA,aAAa;AAAA,UACb,YAAY,WAAW,WAAW,KAAK;AAAA,UACvC,IAAI,cAAc,sBAAsB;AAAA,YACtC,MAAM,IAAI,MAAM,YAAY;AAAA,UAC9B;AAAA,UACA;AAAA,QACF,EAAO,SAAI,cAAc,0BAA0B;AAAA,UACjD,OAAO;AAAA,YACL,MAAM;AAAA,YACN,YAAY,iBAAiB,wBAAwB;AAAA,YACrD,QAAQ;AAAA,UACV;AAAA,QACF,EAAO,SAAI,cAAc,eAAe,UAAU;AAAA,UAChD,IAAI,UAAU;AAAA,YACZ;AAAA,UACF;AAAA,UACA,aAAa;AAAA,UACb,OAAO;AAAA,YACL,MAAM;AAAA,YACN,UAAU;AAAA,YACV,QAAQ;AAAA,YACR,UAAU,iBAAiB;AAAA,UAC7B;AAAA,QACF;AAAA,QAEA,IAAI,UAAU;AAAA,UACZ,KAAK,WAAW;AAAA,QAClB;AAAA,QAEA,aAAa;AAAA,QACb,YAAY,WAAW,WAAW,KAAK;AAAA,MACzC;AAAA,MAEA,OAAO;AAAA;AAAA,IAGT,MAAM,+BAA+B,MAChC;AAAA,MACH,IAAI,QAAQ,KAAK,WAAW,QAAQ;AAAA,QAClC;AAAA,MACF;AAAA,MAEA,MAAM,aAAa,WAAW,UAAU,OAAO,QAAQ,CAAC;AAAA,MACxD,IAAI,WAAW;AAAA,MACf,IAAI,eAAe,2BAA2B;AAAA,QAC5C,WAAW;AAAA,MACb,EAAO,SAAI,eAAe,2BAA2B;AAAA,QACnD,WAAW;AAAA,MACb,EAAO;AAAA,QACL;AAAA;AAAA,MAGF,SAAS;AAAA,MACT,MAAM,OAAO;AAAA,QACX,MAAM;AAAA,QACN;AAAA,QACA,WAAW,oBAAoB,iBAAiB,CAAC;AAAA,QACjD,QAAQ;AAAA,MACV;AAAA,MACA,IAAI,CAAC,KAAK,aAAc,KAAK,UAAU,SAAS,cAAc,KAAK,UAAU,SAAS,QAAS;AAAA,QAC7F,MAAM,IAAI,MAAM,gBAAgB,KAAK,QAAQ;AAAA,MAC/C;AAAA,MACA,OAAO;AAAA;AAAA,IAGT,MAAM,+BAA+B,CACnC,SACG;AAAA,MACH,IAAI,CAAC,QAAQ,QAAQ,KAAK,WAAW,QAAQ;AAAA,QAC3C,OAAO;AAAA,MACT;AAAA,MAEA,MAAM,aAAa,WAAW,UAAU,OAAO,QAAQ,CAAC;AAAA,MACxD,IAAI,WAAW;AAAA,MACf,IAAI,eAAe,2BAA2B;AAAA,QAC5C,WAAW;AAAA,MACb,EAAO,SAAI,eAAe,2BAA2B;AAAA,QACnD,WAAW;AAAA,MACb,EAAO;AAAA,QACL,OAAO;AAAA;AAAA,MAGT,SAAS;AAAA,MACT,OAAO;AAAA,QACL,MAAM;AAAA,QACN;AAAA,QACA,WAAW;AAAA,QACX,QAAQ;AAAA,MACV;AAAA,MACA,OAAO;AAAA;AAAA,IAGT,MAAM,QAAQ,kBAAkB;AAAA,IAChC,OAAO,MAAM,WAAW,IAAI,YAAY;AAAA;;;EClxB1C,IAAM,eAAe,CACnB,MACA,OACA,UAAU,CAAC,MACR;AAAA,IACH,QAAQ,KAAK;AAAA,WACN;AAAA,QAEH,QAAQ,KAAK,QAAQ;AAAA,QACrB,OAAO;AAAA,WAEJ;AAAA,QACH,MAAM,eAAe,IAAI,KAAK,QAAQ,OAAO;AAAA,QAC7C,MAAM,iBACJ,KAAK,YAAY,KAAK,SAAS,SAAS,aACpC,IAAI,KAAK,UAAU,OAAO,IAC1B,KAAK,SAAS;AAAA,QACpB,IAAI,OAAQ,UAAW,YAAY;AAAA,UACjC,OAAO,MAAM,KAAK,YAAY;AAAA,QAChC;AAAA,QACA,aAAa,kBAAkB;AAAA,QAC/B,OAAO;AAAA;AAAA,IAGX,MAAM,IAAI,MAAM,gCAAgC;AAAA;AAAA,EAGlD,IAAM,MAAM,CACV,MACA,UAAU,CAAC,MACR;AAAA,IACH,IAAI,CAAC,MAAM;AAAA,MACT;AAAA,IACF;AAAA,IAEA,IAAI,MAAM,QAAQ,IAAI,GAAG;AAAA,MACvB,OAAO,KAAK,IAAI,WAAQ,IAAI,OAAM,OAAO,CAAC;AAAA,IAC5C;AAAA,IAEA,QAAQ,KAAK;AAAA,WACN;AAAA,QACH,OAAO,QAAQ,KAAK;AAAA,WAEjB;AAAA,QACH,OAAO,KAAK;AAAA,WAET;AAAA,QACH,MAAM,eAAe,CAAC;AAAA,QACtB,WAAW,gBAAgB,KAAK,UAAU;AAAA,UACxC,aAAa,KAAK,IAAI,cAAc,OAAO,CAAC;AAAA,QAC9C;AAAA,QACA,OAAO;AAAA,WAEJ;AAAA,QACH,IAAI,kBAAkB,IAAI,KAAK,OAAO,OAAO;AAAA,QAE7C,IAAI,KAAK,aAAa,KAAK;AAAA,UACzB,MAAM,iBAAiB,IAAI,KAAK,MAAM,OAAO;AAAA,UAC7C,QAAQ,KAAK;AAAA,iBACN;AAAA,cACH,IAAI,gBAAgB;AAAA,gBAClB,OAAO;AAAA,cACT;AAAA,cACA;AAAA,iBACG;AAAA,cACH,IAAI,CAAC,gBAAgB;AAAA,gBACnB,OAAO;AAAA,cACT;AAAA,cACA;AAAA,iBACG;AAAA,cACH,IAAI,mBAAmB,QAAQ,mBAAmB,WAAW;AAAA,gBAC3D,OAAO;AAAA,cACT;AAAA,cACA;AAAA,iBACG;AAAA,cACH,kBAAkB,iBAAiB;AAAA,cACnC;AAAA,iBACG;AAAA,cACH,kBAAkB,kBAAkB;AAAA,cACpC;AAAA,iBACG;AAAA,cACH,kBAAkB,iBAAiB;AAAA,cACnC;AAAA,iBACG;AAAA,cACH,kBAAkB,iBAAiB;AAAA,cACnC;AAAA,iBACG;AAAA,cACH,kBAAkB,iBAAiB;AAAA,cACnC;AAAA,iBACG;AAAA,cACH,kBAAkB,iBAAiB;AAAA,cACnC;AAAA;AAAA,QAEN;AAAA,QACA,OAAO,aAAa,KAAK,MAAM,iBAAiB,OAAO;AAAA,WAEpD;AAAA,QACH,MAAM,aAAa,IAAI,KAAK,MAAM,OAAO;AAAA,QACzC,MAAM,cAAc,IAAI,KAAK,OAAO,OAAO;AAAA,QAC3C,QAAQ,KAAK;AAAA,eACN;AAAA,YACH,OAAO,cAAc;AAAA,eAClB;AAAA,YACH,OAAO,cAAc;AAAA,eAClB;AAAA,YACH,OAAO,cAAc;AAAA,eAClB;AAAA,YAEH,OAAO,cAAc;AAAA,eAClB;AAAA,YAEH,OAAO,cAAc;AAAA,eAClB;AAAA,YACH,OAAO,eAAe;AAAA,eACnB;AAAA,YACH,OAAO,eAAe;AAAA,eACnB;AAAA,YACH,OAAO,aAAa;AAAA,eACjB;AAAA,YACH,OAAO,aAAa;AAAA,eACjB;AAAA,YACH,OAAO,cAAc;AAAA,eAClB;AAAA,YACH,OAAO,cAAc;AAAA,eAClB;AAAA,YACH,OAAO,aAAa;AAAA,eACjB;AAAA,YACH,OAAO,aAAa;AAAA,eACjB;AAAA,YACH,OAAO,aAAa;AAAA,eACjB;AAAA,YACH,OAAO,aAAa;AAAA,eACjB;AAAA,YACH,OAAO,aAAa;AAAA;AAAA,QAExB,MAAM,IAAI,MAAM,2BAA2B,KAAK,QAAQ;AAAA,WAErD;AAAA,QACH,MAAM,aAAa,CAAC;AAAA,QACpB,WAAW,aAAa,KAAK,YAAY;AAAA,UACvC,WAAW,KAAK,IAAI,WAAW,OAAO,CAAC;AAAA,QACzC;AAAA,QACA,OAAO,IAAI,KAAK,QAAQ,OAAO,EAAE,GAAG,UAAU;AAAA,WAE3C;AAAA,QACH,OAAO,IAAI,KAAK,WAAW,OAAO,IAC9B,IAAI,KAAK,YAAY,OAAO,IAC5B,IAAI,KAAK,WAAW,OAAO;AAAA,WAE5B;AAAA,QACH,MAAM,eAAe,IAAI,KAAK,QAAQ,OAAO;AAAA,QAC7C,MAAM,iBACJ,KAAK,YAAY,KAAK,SAAS,SAAS,aACpC,IAAI,KAAK,UAAU,OAAO,IAC1B,KAAK,SAAS;AAAA,QACpB,IAAI,OAAQ,aAAa,oBAAqB,YAAY;AAAA,UACxD,OAAO,aAAa,gBAAgB,KAAK,YAAY;AAAA,QACvD;AAAA,QACA,OAAO,aAAa;AAAA,WAEjB;AAAA,QACH,MAAM,eAAe,CAAC;AAAA,QACtB,WAAW,kBAAkB,KAAK,YAAY;AAAA,UAE5C,aACG,eAAe,YAAY,eAAe,IAAI,SAAS,aAAc,IAAI,eAAe,KAAK,OAAO,IAAI,eAAe,IAAI,QAC1H,IAAI,eAAe,OAAO,OAAO;AAAA,QACvC;AAAA,QACA,OAAO;AAAA,WAEJ;AAAA,QACH,OAAO,KAAK,YAAY,IAAI,WAAQ,IAAI,OAAM,OAAO,CAAC;AAAA,WAEnD;AAAA,QACH,MAAM,iBAAiB,IAAI,KAAK,WAAW,OAAO;AAAA,QAClD,QAAQ,KAAK;AAAA,eACN;AAAA,YACH,OAAO,CAAC;AAAA,eACL;AAAA,YACH,OAAO,CAAC;AAAA,eACL;AAAA,YACH,OAAO,CAAC;AAAA;AAAA,QAEZ,MAAM,IAAI,MAAM,2BAA2B,KAAK,QAAQ;AAAA,WAErD;AAAA,QACH,MAAM,eAAe,IAAI,KAAK,WAAW,OAAO;AAAA,QAChD,MAAM,cAAc,KAAK,aAAa,OAAO,KAAK;AAAA,QAClD,aAAa,KAAK,WAAW,eAAe,aAAa,OAAO;AAAA,QAChE,OAAO,KAAK,SAAS,eAAe,cAAc;AAAA;AAAA,IAGtD,MAAM,IAAI,MAAM,2BAA2B,KAAK,OAAO,IAAI;AAAA;AAAA,EAG7D,IAAe;;;EChMR,IAAM,YAAY,CACvB,YACA,YACG,YAAK,cAAO,UAAU,GAAG,OAAO;AAAA,EAC9B,IAAM,QAAQ;AAAA,EACd,IAAM,OAAM;;;ECjBnB,OAAO,YAAY;AAAA,IACjB;AAAA,IACA;AAAA,IACA;AAAA,EACF;",
  "debugId": "2E49713D3DF98C5164756E2164756E21",
  "names": []
}