{
  "version": 3,
  "sources": ["../src/types.js", "../src/parse.js", "../src/run.js", "../src/index.js"],
  "sourcesContent": [
    "export const ARRAY = 5\nexport const ASSIGN = 6\nexport const BINARY = 7\nexport const CALL = 8\nexport const CONDITION = 9\nexport const IDENTIFIER = 2\nexport const LITERAL = 3\nexport const MEMBER = 10\nexport const OBJECT = 11\nexport const PROPERTY = 4\nexport const SEQUENCE = 12\nexport const UNARY = 13\nexport const UPDATE = 14\n\nexport default {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n}\n",
    "// Based on jsep, v1.3.6, https://github.com/EricSmekens/jsep#readme).\n\nimport {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n} from './types.js'\n\n// Character codes.\nconst SPACE_CODES = [\n  9, // Tab\n  10, // LF\n  13, // CR\n  32, // Space\n]\nconst OPENING_PARENTHESIS_CODE = 40 // (\nconst CLOSING_PARENTHESIS_CODE = 41 // )\nconst COMMA_CODE = 44 // ,\nconst PERIOD_CODE = 46 // .\nconst COLON_CODE = 58 // :\nconst QUESTION_MARK_CODE = 63 // ?\nconst OPENING_BRACKET_CODE = 91 // [\nconst CLOSING_BRACKET_CODE = 93 // ]\nconst CLOSING_BRACES_CODE = 125 // }\n\n// Operators.\nconst ASSIGNMENT_OPERATORS = [\n  '=',\n  '||=',\n  '&&=',\n  '??=',\n  '*=',\n  '**=',\n  '/=',\n  '%=',\n  '+=',\n  '-=',\n  // '<<=',\n  // '>>=',\n  // '>>>=',\n  // '&=',\n  // '^=',\n  // '|=',\n]\nconst BINARY_OPERATORS = {\n  '=': 1,\n  '||=': 1,\n  '&&=': 1,\n  '??=': 1,\n  '*=': 1,\n  '**=': 1,\n  '/=': 1,\n  '%=': 1,\n  '+=': 1,\n  '-=': 1,\n  // '<<=': 1,\n  // '>>=': 1,\n  // '>>>=': 1,\n  // '&=': 1,\n  // '^=': 1,\n  // '|=': 1,\n  '||': 2,\n  '&&': 3,\n  '??': 4,\n  // '|': 5,\n  // '^': 6,\n  // '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  // '<<': 10,\n  // '>>': 10,\n  // '>>>': 10,\n  '*': 11,\n  '/': 11,\n  '%': 11,\n  '+': 11,\n  '-': 11,\n}\nconst UNARY_OPERATORS = [\n  '-',\n  '!',\n  // '~',\n  '+',\n]\nconst UPDATE_OPERATOR_DECREMENT = '--'\nconst UPDATE_OPERATOR_INCREMENT = '++'\n\n// Literal lookup.\nconst LITERALS = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n}\n\nconst isDecimalDigit = (\n  character,\n) => (character >= 48 && character <= 57) // Between 0 and 9\n\nconst isIdentifierPart = (\n  character,\n) => isIdentifierStart(character) || isDecimalDigit(character)\n\nconst isIdentifierStart = (\n  character,\n) =>\n  character === 36 || // Dollar ($)\n  (character >= 48 && character <= 57) || // Between 0 and 9\n  character === 95 || // Underscore\n  (character >= 65 && character <= 90) || // Between A and Z\n  (character >= 97 && character <= 122) // Between a and z\n\nexport default (\n  expression,\n) => {\n  let index = 0\n\n  const gobbleArray = (\n  ) => {\n    index++\n\n    return {\n      type: ARRAY,\n      elements: gobbleParameters(CLOSING_BRACKET_CODE),\n    }\n  }\n\n  const gobbleParameters = (\n    termination,\n  ) => {\n    const parameters = []\n    let closed = false\n\n    let separatorCount = 0\n    while (index < expression.length) {\n      gobbleSpaces()\n      const characterIndex = expression.charCodeAt(index)\n\n      if (characterIndex === termination) {\n        closed = true\n        index++\n\n        if (termination === CLOSING_PARENTHESIS_CODE && separatorCount && separatorCount >= parameters.length) {\n          throw new Error('Unexpected token ' + String.fromCharCode(termination))\n        }\n        break\n      } else if (characterIndex === COMMA_CODE) {\n        index++\n        separatorCount++\n\n        if (separatorCount !== parameters.length) {\n          if (termination === CLOSING_PARENTHESIS_CODE) {\n            throw new Error('Unexpected token ,')\n          } else if (termination === CLOSING_BRACKET_CODE) {\n            for (let i = parameters.length; i < separatorCount; i++) {\n              parameters.push(null)\n            }\n          }\n        }\n      } else if (parameters.length !== separatorCount && separatorCount !== 0) {\n        throw new Error('Expected comma')\n      } else {\n        const node = gobbleExpression()\n\n        if (!node) {\n          throw new Error('Expected comma')\n        }\n\n        parameters.push(node)\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Expected ' + String.fromCharCode(termination))\n    }\n\n    return parameters\n  }\n\n  const gobbleBinaryExpression = (\n  ) => {\n    let left = gobbleToken()\n    if (!left) {\n      return left\n    }\n\n    let operator = gobbleBinaryOperation()\n    if (!operator) {\n      return left\n    }\n\n    let binaryOperationInfo = {\n      value: operator,\n      precedence: BINARY_OPERATORS[operator] || 0,\n    }\n\n    let right = gobbleToken()\n    if (!right) {\n      throw new Error('Expected expression after ' + operator)\n    }\n\n    const stack = [\n      left,\n      binaryOperationInfo,\n      right,\n    ]\n\n    let node\n    while ((operator = gobbleBinaryOperation())) {\n      const precedence = BINARY_OPERATORS[operator] || 0\n\n      if (precedence === 0) {\n        index -= operator.length\n        break\n      }\n\n      binaryOperationInfo = {\n        value: operator,\n        precedence,\n      }\n\n      const currentBinaryOperation = operator\n      while (stack.length > 2 && stack[stack.length - 2] > precedence) {\n        right = stack.pop()\n        operator = stack.pop().value\n        left = stack.pop()\n        node = {\n          type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n            ? ASSIGN\n            : BINARY,\n          operator,\n          left,\n          right,\n        }\n        stack.push(node)\n      }\n\n      node = gobbleToken()\n\n      if (!node) {\n        throw new Error('Expected expression after ' + currentBinaryOperation)\n      }\n\n      stack.push(binaryOperationInfo, node)\n    }\n\n    let i = stack.length - 1\n    node = stack[i]\n\n    while (i > 1) {\n      operator = stack[i - 1].value\n      node = {\n        type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n          ? ASSIGN\n          : BINARY,\n        operator,\n        left: stack[i - 2],\n        right: node,\n      }\n      i -= 2\n    }\n\n    return node\n  }\n\n  const gobbleBinaryOperation = (\n  ) => {\n    gobbleSpaces()\n    let toCheck = expression.substring(index, index + 3) // 3 = Maximum binary operator length.\n    let toCheckLength = toCheck.length\n\n    while (toCheckLength > 0) {\n      if (Object.prototype.hasOwnProperty.call(BINARY_OPERATORS, toCheck) && (\n        !isIdentifierStart(expression.charCodeAt(index)) ||\n        (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n      )) {\n        index += toCheckLength\n        return toCheck\n      }\n      toCheck = toCheck.substring(0, --toCheckLength)\n    }\n    return false\n  }\n\n  const gobbleExpression = (\n  ) => {\n    let node = gobbleBinaryExpression()\n    gobbleSpaces()\n    node = gobbleTernary(node)\n    return node\n  }\n\n  const gobbleExpressions = (\n    untilCharacterCode,\n  ) => {\n    const nodes = []\n    while (index < expression.length) {\n      const characterIndex = expression.charCodeAt(index)\n      if (\n        characterIndex === 59 || // Semicolon (;)\n        characterIndex === COMMA_CODE\n      ) {\n        index++\n      } else {\n        const node = gobbleExpression()\n        if (node) {\n          nodes.push(node)\n        } else if (index < expression.length) {\n          if (characterIndex === untilCharacterCode) {\n            break\n          }\n          throw new Error('Unexpected \"' + expression.charAt(index) + '\"')\n        }\n      }\n    }\n    return nodes\n  }\n\n  const gobbleIdentifier = (\n  ) => {\n    let character = expression.charCodeAt(index)\n    const start = index\n\n    if (isIdentifierStart(character)) {\n      index++\n    } else {\n      throw new Error('Unexpected ' + expression.charAt(index))\n    }\n\n    while (index < expression.length) {\n      character = expression.charCodeAt(index)\n\n      if (isIdentifierPart(character)) {\n        index++\n      } else {\n        break\n      }\n    }\n    return {\n      type: IDENTIFIER,\n      name: expression.slice(start, index),\n    }\n  }\n\n  const gobbleNumericLiteral = (\n  ) => {\n    let number = ''\n    while (isDecimalDigit(expression.charCodeAt(index))) {\n      number += expression.charAt(index++)\n    }\n    if (expression.charCodeAt(index) === PERIOD_CODE) {\n      number += expression.charAt(index++)\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n    }\n\n    let character = expression.charAt(index)\n    if (character === 'e' || character === 'E') {\n      number += expression.charAt(index++)\n      character = expression.charAt(index)\n\n      if (character === '+' || character === '-') {\n        number += expression.charAt(index++)\n      }\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n\n      if (!isDecimalDigit(expression.charCodeAt(index - 1))) {\n        throw new Error('Expected exponent (' + number + expression.charAt(index) + ')')\n      }\n    }\n\n    const characterCode = expression.charCodeAt(index)\n    if (isIdentifierStart(characterCode)) {\n      throw new Error('Variable names cannot start with a number (' + number + expression.charAt(index) + ')')\n    } else if (\n      characterCode === PERIOD_CODE ||\n      (\n        number.length === 1 &&\n        number.charCodeAt(0) === PERIOD_CODE\n      )\n    ) {\n      throw new Error('Unexpected period')\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(number),\n      // raw: number,\n    }\n  }\n\n  const gobbleObjectExpression = (\n  ) => {\n    // Check if opening brace \"{\"\n    if (expression.charCodeAt(index) !== 123) {\n      return\n    }\n    index++\n\n    const properties = []\n    while (!isNaN(expression.charCodeAt(index))) {\n      gobbleSpaces()\n      if (expression.charCodeAt(index) === CLOSING_BRACES_CODE) {\n        index++\n        return gobbleTokenProperty({\n          type: OBJECT,\n          properties,\n        })\n      }\n\n      const key = gobbleToken()\n      if (!key) {\n        throw new Error('Missing }')\n      }\n      gobbleSpaces()\n\n      if (\n        key.type === IDENTIFIER &&\n        (\n          expression.charCodeAt(index) === COMMA_CODE ||\n          expression.charCodeAt(index) === CLOSING_BRACES_CODE\n        )\n      ) {\n        properties.push({\n          type: PROPERTY,\n          computed: false,\n          key,\n          value: key,\n          shorthand: true,\n        })\n      } else if (expression.charCodeAt(index) === COLON_CODE) {\n        index++\n        gobbleSpaces()\n        const value = gobbleExpression()\n        if (!value) {\n          throw new Error('Unexpected object property')\n        }\n\n        const computed = key.type === ARRAY\n        properties.push({\n          computed,\n          key: computed\n            ? key.elements[0]\n            : key,\n          shorthand: false,\n          type: PROPERTY,\n          value,\n        })\n        gobbleSpaces()\n      } else if (key) {\n        properties.push(key)\n      }\n\n      if (expression.charCodeAt(index) === COMMA_CODE) {\n        index++\n      }\n    }\n    throw new Error('Missing }')\n  }\n\n  const gobbleSequence = (\n  ) => {\n    index++\n\n    const nodes = gobbleExpressions(CLOSING_PARENTHESIS_CODE)\n    if (expression.charCodeAt(index) === CLOSING_PARENTHESIS_CODE) {\n      index++\n\n      if (nodes.length === 1) {\n        return nodes[0]\n      }\n      if (!nodes.length) {\n        return false\n      }\n\n      return {\n        type: SEQUENCE,\n        expressions: nodes,\n      }\n    }\n\n    throw new Error('Unclosed (')\n  }\n\n  const gobbleSpaces = (\n  ) => {\n    while (SPACE_CODES.indexOf(expression.charCodeAt(index)) >= 0) {\n      index++\n    }\n  }\n\n  const gobbleStringLiteral = (\n  ) => {\n    let string = ''\n    // const startIndex = index\n    const quote = expression.charAt(index++)\n    let closed = false\n\n    while (index < expression.length) {\n      let character = expression.charAt(index++)\n\n      if (character === quote) {\n        closed = true\n        break\n      }\n      if (character === '\\\\') {\n        character = expression.charAt(index++)\n\n        switch (character) {\n          case 'n':\n            string += '\\n'\n            break\n\n          case 'r':\n            string += '\\r'\n            break\n\n          case 't':\n            string += '\\t'\n            break\n\n          case 'b':\n            string += '\\b'\n            break\n\n          case 'f':\n            string += '\\f'\n            break\n\n          case 'v':\n            string += '\\x0B'\n            break\n\n          default:\n            string += character\n        }\n      } else {\n        string += character\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Unclosed quote after \"' + string + '\"')\n    }\n\n    return {\n      type: LITERAL,\n      value: string,\n      // raw: expression.substring(startIndex, index),\n    }\n  }\n\n  const gobbleTernary = (\n    node,\n  ) => {\n    if (!node || expression.charCodeAt(index) !== QUESTION_MARK_CODE) {\n      return node\n    }\n    index++\n\n    const consequent = gobbleExpression()\n    if (!consequent) {\n      throw new Error('Expected expression')\n    }\n\n    gobbleSpaces()\n\n    if (!expression.charCodeAt(index) === COLON_CODE) {\n      throw new Error('Expected :')\n    }\n    index++\n\n    const alternate = gobbleExpression()\n    if (!alternate) {\n      throw new Error('Expected expression')\n    }\n\n    let conditional = {\n      type: CONDITION,\n      condition: node,\n      consequent,\n      alternate,\n    }\n\n    if (node.operator && BINARY_OPERATORS[node.operator] <= 1) {\n      let newCondition = node\n      while (newCondition.right.operator && BINARY_OPERATORS[newCondition.right.operator] <= 1) {\n        newCondition = newCondition.right\n      }\n      conditional.condition = newCondition.right\n      newCondition.right = conditional\n      conditional = node\n    }\n\n    return conditional\n  }\n\n  const gobbleToken = (\n  ) => {\n    let node = gobbleObjectExpression() || gobbleUpdatePrefixExpression()\n    if (node) {\n      return gobbleUpdateSuffixExpression(node)\n    }\n    gobbleSpaces()\n\n    const character = expression.charCodeAt(index)\n    if (isDecimalDigit(character) || character === PERIOD_CODE) {\n      return gobbleNumericLiteral()\n    }\n\n    if (character === 34 || character === 39) { // Double quote (\") or single quote (')\n      node = gobbleStringLiteral()\n    } else if (character === OPENING_BRACKET_CODE) {\n      node = gobbleArray()\n    } else {\n      let toCheck = expression.substring(index, index + 1) // 1 = Maximum unary operator length.\n      let toCheckLength = toCheck.length\n\n      while (toCheckLength > 0) {\n        if (UNARY_OPERATORS.indexOf(toCheck) >= 0 && (\n          !isIdentifierStart(expression.charCodeAt(index)) ||\n          (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n        )) {\n          index += toCheckLength\n          const parameter = gobbleToken()\n          if (!parameter) {\n            throw new Error('Missing unary operation parameter')\n          }\n          return gobbleUpdateSuffixExpression({\n            type: UNARY,\n            operator: toCheck,\n            parameter,\n          })\n        }\n\n        toCheck = toCheck.substr(0, --toCheckLength)\n      }\n\n      if (isIdentifierStart(character)) {\n        node = gobbleIdentifier()\n        if (Object.prototype.hasOwnProperty.call(LITERALS, node.name)) {\n          node = {\n            type: LITERAL,\n            value: LITERALS[node.name],\n            // raw: node.name,\n          }\n        }\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = gobbleSequence()\n      }\n    }\n\n    return gobbleUpdateSuffixExpression(\n      gobbleTokenProperty(node),\n    )\n  }\n\n  const gobbleTokenProperty = (\n    node,\n  ) => {\n    gobbleSpaces()\n\n    let character = expression.charCodeAt(index)\n    while (\n      character === PERIOD_CODE ||\n      character === OPENING_BRACKET_CODE ||\n      character === OPENING_PARENTHESIS_CODE ||\n      character === QUESTION_MARK_CODE\n    ) {\n      let optional\n      if (character === QUESTION_MARK_CODE) {\n        if (expression.charCodeAt(index + 1) !== PERIOD_CODE) {\n          break\n        }\n        optional = true\n        index += 2\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n      }\n      index++\n\n      if (character === OPENING_BRACKET_CODE) {\n        node = {\n          type: MEMBER,\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n        }\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n        if (character !== CLOSING_BRACKET_CODE) {\n          throw new Error('Unclosed [')\n        }\n        index++\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = {\n          type: CALL,\n          parameters: gobbleParameters(CLOSING_PARENTHESIS_CODE),\n          callee: node,\n        }\n      } else if (character === PERIOD_CODE || optional) {\n        if (optional) {\n          index--\n        }\n        gobbleSpaces()\n        node = {\n          type: MEMBER,\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n        }\n      }\n\n      if (optional) {\n        node.optional = true\n      }\n\n      gobbleSpaces()\n      character = expression.charCodeAt(index)\n    }\n\n    return node\n  }\n\n  const gobbleUpdatePrefixExpression = (\n  ) => {\n    if (index + 1 >= expression.length) {\n      return\n    }\n\n    const characters = expression.substring(index, index + 2) // 2 = Maximum update expression length\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return\n    }\n\n    index += 2\n    const node = {\n      type: UPDATE,\n      operator,\n      parameter: gobbleTokenProperty(gobbleIdentifier()),\n      prefix: true,\n    }\n    if (!node.parameter || (node.parameter.type !== IDENTIFIER && node.parameter.type !== MEMBER)) {\n      throw new Error('Unexpected ' + node.operator)\n    }\n    return node\n  }\n\n  const gobbleUpdateSuffixExpression = (\n    node,\n  ) => {\n    if (!node || index + 1 >= expression.length) {\n      return node\n    }\n\n    const characters = expression.substring(index, index + 2)\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return node\n    }\n\n    index += 2\n    node = {\n      type: UPDATE,\n      operator,\n      parameter: node,\n      prefix: false,\n    }\n    return node\n  }\n\n  const nodes = gobbleExpressions()\n  return nodes.length === 0 ? undefined : nodes\n}\n",
    "import {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n} from './types.js'\n\nconst setToContext = (\n  node,\n  value,\n  context = {},\n) => {\n  switch (node.type) {\n    case IDENTIFIER:\n      // Assign to\n      context[node.name] = value\n      return value\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (value) === 'function') {\n        return value.bind(memberObject)\n      }\n      memberObject[memberProperty] = value\n      return value\n  }\n\n  throw new Error('Unsupported assignment method.')\n}\n\nconst run = (\n  node,\n  context = {},\n) => {\n  if (!node) {\n    return\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(node => run(node, context))\n  }\n\n  switch (node.type) {\n    case IDENTIFIER:\n      return context[node.name]\n\n    case LITERAL:\n      return node.value\n\n    case ARRAY:\n      const arrayResults = []\n      for (const arrayElement of node.elements) {\n        arrayResults.push(run(arrayElement, context))\n      }\n      return arrayResults\n\n    case ASSIGN:\n      let assignmentValue = run(node.right, context)\n      // Modify value if not a direct assignment.\n      if (node.operator !== '=') {\n        const assignmentLeft = run(node.left, context)\n        switch (node.operator) {\n          case '||=':\n            if (assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '&&=':\n            if (!assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '??=':\n            if (assignmentLeft !== null && assignmentLeft !== undefined) {\n              return assignmentLeft\n            }\n            break\n          case '*=':\n            assignmentValue = assignmentLeft * assignmentValue\n            break\n          case '**=':\n            assignmentValue = assignmentLeft ** assignmentValue\n            break\n          case '/=':\n            assignmentValue = assignmentLeft / assignmentValue\n            break\n          case '%=':\n            assignmentValue = assignmentLeft % assignmentValue\n            break\n          case '+=':\n            assignmentValue = assignmentLeft + assignmentValue\n            break\n          case '-=':\n            assignmentValue = assignmentLeft - assignmentValue\n            break\n        }\n      }\n      return setToContext(node.left, assignmentValue, context)\n\n    case BINARY:\n      const binaryLeft = run(node.left, context)\n      const binaryRight = run(node.right, context)\n      switch (node.operator) {\n        case '||':\n          return binaryLeft || binaryRight\n        case '&&':\n          return binaryLeft && binaryRight\n        case '??':\n          return binaryLeft ?? binaryRight\n        case '==':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft == binaryRight\n        case '!=':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft != binaryRight\n        case '===':\n          return binaryLeft === binaryRight\n        case '!==':\n          return binaryLeft !== binaryRight\n        case '<':\n          return binaryLeft < binaryRight\n        case '>':\n          return binaryLeft > binaryRight\n        case '<=':\n          return binaryLeft <= binaryRight\n        case '>=':\n          return binaryLeft >= binaryRight\n        case '-':\n          return binaryLeft - binaryRight\n        case '+':\n          return binaryLeft + binaryRight\n        case '*':\n          return binaryLeft * binaryRight\n        case '/':\n          return binaryLeft / binaryRight\n        case '%':\n          return binaryLeft % binaryRight\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case CALL:\n      const parameters = []\n      for (const parameter of node.parameters) {\n        parameters.push(run(parameter, context))\n      }\n      return run(node.callee, context)(...parameters)\n\n    case CONDITION:\n      return run(node.condition, context)\n        ? run(node.consequent, context)\n        : run(node.alternate, context)\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (memberObject[memberProperty]) === 'function') {\n        return memberObject[memberProperty].bind(memberObject)\n      }\n      return memberObject[memberProperty]\n\n    case OBJECT:\n      const objectResult = {}\n      for (const objectProperty of node.properties) {\n        // Expects each property to be of type PROPERTY.\n        objectResult[\n          (objectProperty.computed || objectProperty.key.type !== IDENTIFIER) ? run(objectProperty.key, context) : objectProperty.key.name\n        ] = run(objectProperty.value, context)\n      }\n      return objectResult\n\n    case SEQUENCE:\n      return node.expressions.map(node => run(node, context))\n\n    case UNARY:\n      const unaryParameter = run(node.parameter, context)\n      switch (node.operator) {\n        case '!':\n          return !unaryParameter\n        case '-':\n          return -unaryParameter\n        case '+':\n          return +unaryParameter\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case UPDATE:\n      const updateResult = run(node.parameter, context)\n      const updateValue = node.operator === '--' ? -1 : 1\n      setToContext(node.parameter, updateResult + updateValue, context)\n      return node.prefix ? updateResult + updateValue : updateResult\n  }\n\n  throw new Error('Unexpected node type \"' + node.type + '\".')\n}\n\nexport default run\n",
    "import _parse from './parse.js'\nimport _run from './run.js'\nimport {\n  ARRAY as _ARRAY,\n  ASSIGN as _ASSIGN,\n  BINARY as _BINARY,\n  CALL as _CALL,\n  CONDITION as _CONDITION,\n  IDENTIFIER as _IDENTIFIER,\n  LITERAL as _LITERAL,\n  MEMBER as _MEMBER,\n  OBJECT as _OBJECT,\n  PROPERTY as _PROPERTY,\n  SEQUENCE as _SEQUENCE,\n  UNARY as _UNARY,\n  UPDATE as _UPDATE,\n} from './types.js'\n\nexport const interpret = (\n  expression,\n  context,\n) => _run(_parse(expression), context)\nexport const parse = _parse\nexport const run = _run\n\nexport const ARRAY = _ARRAY\nexport const ASSIGN = _ASSIGN\nexport const BINARY = _BINARY\nexport const CALL = _CALL\nexport const CONDITION = _CONDITION\nexport const IDENTIFIER = _IDENTIFIER\nexport const LITERAL = _LITERAL\nexport const MEMBER = _MEMBER\nexport const OBJECT = _OBJECT\nexport const PROPERTY = _PROPERTY\nexport const SEQUENCE = _SEQUENCE\nexport const UNARY = _UNARY\nexport const UPDATE = _UPDATE\n\nexport default {\n  interpret,\n  parse: _parse,\n  run: _run,\n\n  ARRAY: _ARRAY,\n  ASSIGN: _ASSIGN,\n  BINARY: _BINARY,\n  CALL: _CALL,\n  CONDITION: _CONDITION,\n  IDENTIFIER: _IDENTIFIER,\n  LITERAL: _LITERAL,\n  MEMBER: _MEMBER,\n  OBJECT: _OBJECT,\n  PROPERTY: _PROPERTY,\n  SEQUENCE: _SEQUENCE,\n  UNARY: _UNARY,\n  UPDATE: _UPDATE,\n}\n"
  ],
  "mappings": "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",
  "debugId": "DA05C3D01711CBB464756E2164756E21",
  "names": []
}