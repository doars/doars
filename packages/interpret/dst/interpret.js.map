{
  "version": 3,
  "sources": ["../src/types.js", "../src/parse.js", "../src/run.js", "../src/index.js"],
  "sourcesContent": ["export const ARRAY = 5\nexport const ASSIGN = 6\nexport const BINARY = 7\nexport const CALL = 8\nexport const CONDITION = 9\nexport const IDENTIFIER = 2\nexport const LITERAL = 3\nexport const MEMBER = 10\nexport const OBJECT = 11\nexport const PROPERTY = 4\nexport const SEQUENCE = 12\nexport const UNARY = 13\nexport const UPDATE = 14\n\nexport default {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE,\n}\n", "// Based on jsep, v1.3.6, https://github.com/EricSmekens/jsep#readme).\n\nimport {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE\n} from './types.js'\n\n// Character codes.\nconst SPACE_CODES = [\n  9, // Tab\n  10, // LF\n  13, // CR\n  32, // Space\n]\nconst OPENING_PARENTHESIS_CODE = 40 // (\nconst CLOSING_PARENTHESIS_CODE = 41 // )\nconst COMMA_CODE = 44 // ,\nconst PERIOD_CODE = 46 // .\nconst COLON_CODE = 58 // :\nconst QUESTION_MARK_CODE = 63 // ?\nconst OPENING_BRACKET_CODE = 91 // [\nconst CLOSING_BRACKET_CODE = 93 // ]\nconst CLOSING_BRACES_CODE = 125 // }\n\n// Operators.\nconst ASSIGNMENT_OPERATORS = [\n  '=',\n  '||=',\n  '&&=',\n  '??=',\n  '*=',\n  '**=',\n  '/=',\n  '%=',\n  '+=',\n  '-=',\n  // '<<=',\n  // '>>=',\n  // '>>>=',\n  // '&=',\n  // '^=',\n  // '|=',\n]\nconst BINARY_OPERATORS = {\n  '=': 1,\n  '||=': 1,\n  '&&=': 1,\n  '??=': 1,\n  '*=': 1,\n  '**=': 1,\n  '/=': 1,\n  '%=': 1,\n  '+=': 1,\n  '-=': 1,\n  // '<<=': 1,\n  // '>>=': 1,\n  // '>>>=': 1,\n  // '&=': 1,\n  // '^=': 1,\n  // '|=': 1,\n  '||': 2,\n  '&&': 3,\n  '??': 4,\n  // '|': 5,\n  // '^': 6,\n  // '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  // '<<': 10,\n  // '>>': 10,\n  // '>>>': 10,\n  '*': 11,\n  '/': 11,\n  '%': 11,\n  '+': 11,\n  '-': 11,\n}\nconst UNARY_OPERATORS = [\n  '-',\n  '!',\n  // '~',\n  '+',\n]\nconst UPDATE_OPERATOR_DECREMENT = '--'\nconst UPDATE_OPERATOR_INCREMENT = '++'\n\n// Literal lookup.\nconst LITERALS = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n}\n\nconst isDecimalDigit = (character) =>\n  (character >= 48 && character <= 57) // Between 0 and 9\n\nconst isIdentifierPart = (character) =>\n  isIdentifierStart(character) || isDecimalDigit(character)\n\nconst isIdentifierStart = (character) =>\n  character === 36 || // Dollar ($)\n  (character >= 48 && character <= 57) || // Between 0 and 9\n  character === 95 || // Underscore\n  (character >= 65 && character <= 90) || // Between A and Z\n  (character >= 97 && character <= 122) // Between a and z\n\nexport default (expression) => {\n  let index = 0\n\n  const gobbleArray = () => {\n    index++\n\n    return {\n      type: ARRAY,\n      elements: gobbleParameters(CLOSING_BRACKET_CODE),\n    }\n  }\n\n  const gobbleParameters = (termination) => {\n    const parameters = []\n    let closed = false\n\n    let separatorCount = 0\n    while (index < expression.length) {\n      gobbleSpaces()\n      const characterIndex = expression.charCodeAt(index)\n\n      if (characterIndex === termination) {\n        closed = true\n        index++\n\n        if (termination === CLOSING_PARENTHESIS_CODE && separatorCount && separatorCount >= parameters.length) {\n          throw new Error('Unexpected token ' + String.fromCharCode(termination))\n        }\n        break\n      } else if (characterIndex === COMMA_CODE) {\n        index++\n        separatorCount++\n\n        if (separatorCount !== parameters.length) {\n          if (termination === CLOSING_PARENTHESIS_CODE) {\n            throw new Error('Unexpected token ,')\n          } else if (termination === CLOSING_BRACKET_CODE) {\n            for (let i = parameters.length; i < separatorCount; i++) {\n              parameters.push(null)\n            }\n          }\n        }\n      } else if (parameters.length !== separatorCount && separatorCount !== 0) {\n        throw new Error('Expected comma')\n      } else {\n        const node = gobbleExpression()\n\n        if (!node) {\n          throw new Error('Expected comma')\n        }\n\n        parameters.push(node)\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Expected ' + String.fromCharCode(termination))\n    }\n\n    return parameters\n  }\n\n  const gobbleBinaryExpression = () => {\n    let left = gobbleToken()\n    if (!left) {\n      return left\n    }\n\n    let operator = gobbleBinaryOperation()\n    if (!operator) {\n      return left\n    }\n\n    let binaryOperationInfo = {\n      value: operator,\n      precedence: BINARY_OPERATORS[operator] || 0,\n    }\n\n    let right = gobbleToken()\n    if (!right) {\n      throw new Error('Expected expression after ' + operator)\n    }\n\n    const stack = [\n      left,\n      binaryOperationInfo,\n      right,\n    ]\n\n    let node\n    while ((operator = gobbleBinaryOperation())) {\n      const precedence = BINARY_OPERATORS[operator] || 0\n\n      if (precedence === 0) {\n        index -= operator.length\n        break\n      }\n\n      binaryOperationInfo = {\n        value: operator,\n        precedence,\n      }\n\n      const currentBinaryOperation = operator\n      while (stack.length > 2 && stack[stack.length - 2] > precedence) {\n        right = stack.pop()\n        operator = stack.pop().value\n        left = stack.pop()\n        node = {\n          type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n            ? ASSIGN\n            : BINARY,\n          operator,\n          left,\n          right,\n        }\n        stack.push(node)\n      }\n\n      node = gobbleToken()\n\n      if (!node) {\n        throw new Error('Expected expression after ' + currentBinaryOperation)\n      }\n\n      stack.push(binaryOperationInfo, node)\n    }\n\n    let i = stack.length - 1\n    node = stack[i]\n\n    while (i > 1) {\n      operator = stack[i - 1].value\n      node = {\n        type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n          ? ASSIGN\n          : BINARY,\n        operator,\n        left: stack[i - 2],\n        right: node,\n      }\n      i -= 2\n    }\n\n    return node\n  }\n\n  const gobbleBinaryOperation = () => {\n    gobbleSpaces()\n    let toCheck = expression.substring(index, index + 3) // 3 = Maximum binary operator length.\n    let toCheckLength = toCheck.length\n\n    while (toCheckLength > 0) {\n      if (Object.prototype.hasOwnProperty.call(BINARY_OPERATORS, toCheck) && (\n        !isIdentifierStart(expression.charCodeAt(index)) ||\n        (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n      )) {\n        index += toCheckLength\n        return toCheck\n      }\n      toCheck = toCheck.substring(0, --toCheckLength)\n    }\n    return false\n  }\n\n  const gobbleExpression = () => {\n    let node = gobbleBinaryExpression()\n    gobbleSpaces()\n    node = gobbleTernary(node)\n    return node\n  }\n\n  const gobbleExpressions = (untilCharacterCode) => {\n    const nodes = []\n    while (index < expression.length) {\n      const characterIndex = expression.charCodeAt(index)\n      if (\n        characterIndex === 59 || // Semicolon (;)\n        characterIndex === COMMA_CODE\n      ) {\n        index++\n      } else {\n        const node = gobbleExpression()\n        if (node) {\n          nodes.push(node)\n        } else if (index < expression.length) {\n          if (characterIndex === untilCharacterCode) {\n            break\n          }\n          throw new Error('Unexpected \"' + expression.charAt(index) + '\"')\n        }\n      }\n    }\n    return nodes\n  }\n\n  const gobbleIdentifier = () => {\n    let character = expression.charCodeAt(index)\n    const start = index\n\n    if (isIdentifierStart(character)) {\n      index++\n    } else {\n      throw new Error('Unexpected ' + expression.charAt(index))\n    }\n\n    while (index < expression.length) {\n      character = expression.charCodeAt(index)\n\n      if (isIdentifierPart(character)) {\n        index++\n      } else {\n        break\n      }\n    }\n    return {\n      type: IDENTIFIER,\n      name: expression.slice(start, index),\n    }\n  }\n\n  const gobbleNumericLiteral = () => {\n    let number = ''\n    while (isDecimalDigit(expression.charCodeAt(index))) {\n      number += expression.charAt(index++)\n    }\n    if (expression.charCodeAt(index) === PERIOD_CODE) {\n      number += expression.charAt(index++)\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n    }\n\n    let character = expression.charAt(index)\n    if (character === 'e' || character === 'E') {\n      number += expression.charAt(index++)\n      character = expression.charAt(index)\n\n      if (character === '+' || character === '-') {\n        number += expression.charAt(index++)\n      }\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n\n      if (!isDecimalDigit(expression.charCodeAt(index - 1))) {\n        throw new Error('Expected exponent (' + number + expression.charAt(index) + ')')\n      }\n    }\n\n    const characterCode = expression.charCodeAt(index)\n    if (isIdentifierStart(characterCode)) {\n      throw new Error('Variable names cannot start with a number (' + number + expression.charAt(index) + ')')\n    } else if (\n      characterCode === PERIOD_CODE ||\n      (\n        number.length === 1 &&\n        number.charCodeAt(0) === PERIOD_CODE\n      )\n    ) {\n      throw new Error('Unexpected period')\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(number),\n      // raw: number,\n    }\n  }\n\n  const gobbleObjectExpression = () => {\n    // Check if opening brace \"{\"\n    if (expression.charCodeAt(index) !== 123) {\n      return\n    }\n    index++\n\n    const properties = []\n    while (!isNaN(expression.charCodeAt(index))) {\n      gobbleSpaces()\n      if (expression.charCodeAt(index) === CLOSING_BRACES_CODE) {\n        index++\n        return gobbleTokenProperty({\n          type: OBJECT,\n          properties,\n        })\n      }\n\n      const key = gobbleToken()\n      if (!key) {\n        throw new Error('Missing }')\n      }\n      gobbleSpaces()\n\n      if (\n        key.type === IDENTIFIER &&\n        (\n          expression.charCodeAt(index) === COMMA_CODE ||\n          expression.charCodeAt(index) === CLOSING_BRACES_CODE\n        )\n      ) {\n        properties.push({\n          type: PROPERTY,\n          computed: false,\n          key,\n          value: key,\n          shorthand: true,\n        })\n      } else if (expression.charCodeAt(index) === COLON_CODE) {\n        index++\n        gobbleSpaces()\n        const value = gobbleExpression()\n        if (!value) {\n          throw new Error('Unexpected object property')\n        }\n\n        const computed = key.type === ARRAY\n        properties.push({\n          computed,\n          key: computed\n            ? key.elements[0]\n            : key,\n          shorthand: false,\n          type: PROPERTY,\n          value,\n        })\n        gobbleSpaces()\n      } else if (key) {\n        properties.push(key)\n      }\n\n      if (expression.charCodeAt(index) === COMMA_CODE) {\n        index++\n      }\n    }\n    throw new Error('Missing }')\n  }\n\n  const gobbleSequence = () => {\n    index++\n\n    const nodes = gobbleExpressions(CLOSING_PARENTHESIS_CODE)\n    if (expression.charCodeAt(index) === CLOSING_PARENTHESIS_CODE) {\n      index++\n\n      if (nodes.length === 1) {\n        return nodes[0]\n      }\n      if (!nodes.length) {\n        return false\n      }\n\n      return {\n        type: SEQUENCE,\n        expressions: nodes,\n      }\n    }\n\n    throw new Error('Unclosed (')\n  }\n\n  const gobbleSpaces = () => {\n    while (SPACE_CODES.indexOf(expression.charCodeAt(index)) >= 0) {\n      index++\n    }\n  }\n\n  const gobbleStringLiteral = () => {\n    let string = ''\n    // const startIndex = index\n    const quote = expression.charAt(index++)\n    let closed = false\n\n    while (index < expression.length) {\n      let character = expression.charAt(index++)\n\n      if (character === quote) {\n        closed = true\n        break\n      }\n      if (character === '\\\\') {\n        character = expression.charAt(index++)\n\n        switch (character) {\n          case 'n':\n            string += '\\n'\n            break\n\n          case 'r':\n            string += '\\r'\n            break\n\n          case 't':\n            string += '\\t'\n            break\n\n          case 'b':\n            string += '\\b'\n            break\n\n          case 'f':\n            string += '\\f'\n            break\n\n          case 'v':\n            string += '\\x0B'\n            break\n\n          default:\n            string += character\n        }\n      } else {\n        string += character\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Unclosed quote after \"' + string + '\"')\n    }\n\n    return {\n      type: LITERAL,\n      value: string,\n      // raw: expression.substring(startIndex, index),\n    }\n  }\n\n  const gobbleTernary = (node) => {\n    if (!node || expression.charCodeAt(index) !== QUESTION_MARK_CODE) {\n      return node\n    }\n    index++\n\n    const consequent = gobbleExpression()\n    if (!consequent) {\n      throw new Error('Expected expression')\n    }\n\n    gobbleSpaces()\n\n    if (!expression.charCodeAt(index) === COLON_CODE) {\n      throw new Error('Expected :')\n    }\n    index++\n\n    const alternate = gobbleExpression()\n    if (!alternate) {\n      throw new Error('Expected expression')\n    }\n\n    let conditional = {\n      type: CONDITION,\n      condition: node,\n      consequent,\n      alternate,\n    }\n\n    if (node.operator && BINARY_OPERATORS[node.operator] <= 1) {\n      let newCondition = node\n      while (newCondition.right.operator && BINARY_OPERATORS[newCondition.right.operator] <= 1) {\n        newCondition = newCondition.right\n      }\n      conditional.condition = newCondition.right\n      newCondition.right = conditional\n      conditional = node\n    }\n\n    return conditional\n  }\n\n  const gobbleToken = () => {\n    let node = gobbleObjectExpression() || gobbleUpdatePrefixExpression()\n    if (node) {\n      return gobbleUpdateSuffixExpression(node)\n    }\n    gobbleSpaces()\n\n    const character = expression.charCodeAt(index)\n    if (isDecimalDigit(character) || character === PERIOD_CODE) {\n      return gobbleNumericLiteral()\n    }\n\n    if (character === 34 || character === 39) { // Double quote (\") or single quote (')\n      node = gobbleStringLiteral()\n    } else if (character === OPENING_BRACKET_CODE) {\n      node = gobbleArray()\n    } else {\n      let toCheck = expression.substring(index, index + 1) // 1 = Maximum unary operator length.\n      let toCheckLength = toCheck.length\n\n      while (toCheckLength > 0) {\n        if (UNARY_OPERATORS.indexOf(toCheck) >= 0 && (\n          !isIdentifierStart(expression.charCodeAt(index)) ||\n          (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n        )) {\n          index += toCheckLength\n          const parameter = gobbleToken()\n          if (!parameter) {\n            throw new Error('Missing unary operation parameter')\n          }\n          return gobbleUpdateSuffixExpression({\n            type: UNARY,\n            operator: toCheck,\n            parameter,\n          })\n        }\n\n        toCheck = toCheck.substr(0, --toCheckLength)\n      }\n\n      if (isIdentifierStart(character)) {\n        node = gobbleIdentifier()\n        if (Object.prototype.hasOwnProperty.call(LITERALS, node.name)) {\n          node = {\n            type: LITERAL,\n            value: LITERALS[node.name],\n            // raw: node.name,\n          }\n        }\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = gobbleSequence()\n      }\n    }\n\n    return gobbleUpdateSuffixExpression(\n      gobbleTokenProperty(node)\n    )\n  }\n\n  const gobbleTokenProperty = (node) => {\n    gobbleSpaces()\n\n    let character = expression.charCodeAt(index)\n    while (\n      character === PERIOD_CODE ||\n      character === OPENING_BRACKET_CODE ||\n      character === OPENING_PARENTHESIS_CODE ||\n      character === QUESTION_MARK_CODE\n    ) {\n      let optional\n      if (character === QUESTION_MARK_CODE) {\n        if (expression.charCodeAt(index + 1) !== PERIOD_CODE) {\n          break\n        }\n        optional = true\n        index += 2\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n      }\n      index++\n\n      if (character === OPENING_BRACKET_CODE) {\n        node = {\n          type: MEMBER,\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n        }\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n        if (character !== CLOSING_BRACKET_CODE) {\n          throw new Error('Unclosed [')\n        }\n        index++\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = {\n          type: CALL,\n          parameters: gobbleParameters(CLOSING_PARENTHESIS_CODE),\n          callee: node,\n        }\n      } else if (character === PERIOD_CODE || optional) {\n        if (optional) {\n          index--\n        }\n        gobbleSpaces()\n        node = {\n          type: MEMBER,\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n        }\n      }\n\n      if (optional) {\n        node.optional = true\n      }\n\n      gobbleSpaces()\n      character = expression.charCodeAt(index)\n    }\n\n    return node\n  }\n\n  const gobbleUpdatePrefixExpression = () => {\n    if (index + 1 >= expression.length) {\n      return\n    }\n\n    const characters = expression.substring(index, index + 2) // 2 = Maximum update expression length\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return\n    }\n\n    index += 2\n    const node = {\n      type: UPDATE,\n      operator,\n      parameter: gobbleTokenProperty(gobbleIdentifier()),\n      prefix: true,\n    }\n    if (!node.parameter || (node.parameter.type !== IDENTIFIER && node.parameter.type !== MEMBER)) {\n      throw new Error('Unexpected ' + node.operator)\n    }\n    return node\n  }\n\n  const gobbleUpdateSuffixExpression = (node) => {\n    if (!node || index + 1 >= expression.length) {\n      return node\n    }\n\n    const characters = expression.substring(index, index + 2)\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return node\n    }\n\n    index += 2\n    node = {\n      type: UPDATE,\n      operator,\n      parameter: node,\n      prefix: false,\n    }\n    return node\n  }\n\n  const nodes = gobbleExpressions()\n  return nodes.length === 0 ? undefined : nodes\n}\n", "import {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  SEQUENCE,\n  UNARY,\n  UPDATE\n} from './types.js'\n\nconst setToContext = (\n  node,\n  value,\n  context = {}\n) => {\n  switch (node.type) {\n    case IDENTIFIER:\n      // Assign to\n      context[node.name] = value\n      return value\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (value) === 'function') {\n        return value.bind(memberObject)\n      }\n      memberObject[memberProperty] = value\n      return value\n  }\n\n  throw new Error('Unsupported assignment method.')\n}\n\nconst run = (\n  node,\n  context = {}\n) => {\n  if (!node) {\n    return\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(node => run(node, context))\n  }\n\n  switch (node.type) {\n    case IDENTIFIER:\n      return context[node.name]\n\n    case LITERAL:\n      return node.value\n\n    case ARRAY:\n      const arrayResults = []\n      for (const arrayElement of node.elements) {\n        arrayResults.push(run(arrayElement, context))\n      }\n      return arrayResults\n\n    case ASSIGN:\n      let assignmentValue = run(node.right, context)\n      // Modify value if not a direct assignment.\n      if (node.operator !== '=') {\n        const assignmentLeft = run(node.left, context)\n        switch (node.operator) {\n          case '||=':\n            if (assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '&&=':\n            if (!assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '??=':\n            if (assignmentLeft !== null && assignmentLeft !== undefined) {\n              return assignmentLeft\n            }\n            break\n          case '*=':\n            assignmentValue = assignmentLeft * assignmentValue\n            break\n          case '**=':\n            assignmentValue = assignmentLeft ** assignmentValue\n            break\n          case '/=':\n            assignmentValue = assignmentLeft / assignmentValue\n            break\n          case '%=':\n            assignmentValue = assignmentLeft % assignmentValue\n            break\n          case '+=':\n            assignmentValue = assignmentLeft + assignmentValue\n            break\n          case '-=':\n            assignmentValue = assignmentLeft - assignmentValue\n            break\n        }\n      }\n      return setToContext(node.left, assignmentValue, context)\n\n    case BINARY:\n      const binaryLeft = run(node.left, context)\n      const binaryRight = run(node.right, context)\n      switch (node.operator) {\n        case '||':\n          return binaryLeft || binaryRight\n        case '&&':\n          return binaryLeft && binaryRight\n        case '??':\n          return binaryLeft ?? binaryRight\n        case '==':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft == binaryRight\n        case '!=':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft != binaryRight\n        case '===':\n          return binaryLeft === binaryRight\n        case '!==':\n          return binaryLeft !== binaryRight\n        case '<':\n          return binaryLeft < binaryRight\n        case '>':\n          return binaryLeft > binaryRight\n        case '<=':\n          return binaryLeft <= binaryRight\n        case '>=':\n          return binaryLeft >= binaryRight\n        case '-':\n          return binaryLeft - binaryRight\n        case '+':\n          return binaryLeft + binaryRight\n        case '*':\n          return binaryLeft * binaryRight\n        case '/':\n          return binaryLeft / binaryRight\n        case '%':\n          return binaryLeft % binaryRight\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case CALL:\n      const parameters = []\n      for (const parameter of node.parameters) {\n        parameters.push(run(parameter, context))\n      }\n      return run(node.callee, context)(...parameters)\n\n    case CONDITION:\n      return run(node.condition, context)\n        ? run(node.consequent, context)\n        : run(node.alternate, context)\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (memberObject[memberProperty]) === 'function') {\n        return memberObject[memberProperty].bind(memberObject)\n      }\n      return memberObject[memberProperty]\n\n    case OBJECT:\n      const objectResult = {}\n      for (const objectProperty of node.properties) {\n        // Expects each property to be of type PROPERTY.\n        objectResult[\n          (objectProperty.computed || objectProperty.key.type !== IDENTIFIER) ? run(objectProperty.key, context) : objectProperty.key.name\n        ] = run(objectProperty.value, context)\n      }\n      return objectResult\n\n    case SEQUENCE:\n      return node.expressions.map(node => run(node, context))\n\n    case UNARY:\n      const unaryParameter = run(node.parameter, context)\n      switch (node.operator) {\n        case '!':\n          return !unaryParameter\n        case '-':\n          return -unaryParameter\n        case '+':\n          return +unaryParameter\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case UPDATE:\n      const updateResult = run(node.parameter, context)\n      const updateValue = node.operator === '--' ? -1 : 1\n      setToContext(node.parameter, updateResult + updateValue, context)\n      return node.prefix ? updateResult + updateValue : updateResult\n  }\n\n  throw new Error('Unexpected node type \"' + node.type + '\".')\n}\nexport default run\n", "import _parse from './parse.js'\nimport _run from './run.js'\nimport {\n  ARRAY as _ARRAY,\n  ASSIGN as _ASSIGN,\n  BINARY as _BINARY,\n  CALL as _CALL,\n  CONDITION as _CONDITION,\n  IDENTIFIER as _IDENTIFIER,\n  LITERAL as _LITERAL,\n  MEMBER as _MEMBER,\n  OBJECT as _OBJECT,\n  PROPERTY as _PROPERTY,\n  SEQUENCE as _SEQUENCE,\n  UNARY as _UNARY,\n  UPDATE as _UPDATE\n} from './types.js'\n\nexport const interpret = (expression, context) => {\n  return _run(_parse(expression), context)\n}\nexport const parse = _parse\nexport const run = _run\n\nexport const ARRAY = _ARRAY\nexport const ASSIGN = _ASSIGN\nexport const BINARY = _BINARY\nexport const CALL = _CALL\nexport const CONDITION = _CONDITION\nexport const IDENTIFIER = _IDENTIFIER\nexport const LITERAL = _LITERAL\nexport const MEMBER = _MEMBER\nexport const OBJECT = _OBJECT\nexport const PROPERTY = _PROPERTY\nexport const SEQUENCE = _SEQUENCE\nexport const UNARY = _UNARY\nexport const UPDATE = _UPDATE\n\nexport default {\n  interpret,\n  parse: _parse,\n  run: _run,\n\n  ARRAY: _ARRAY,\n  ASSIGN: _ASSIGN,\n  BINARY: _BINARY,\n  CALL: _CALL,\n  CONDITION: _CONDITION,\n  IDENTIFIER: _IDENTIFIER,\n  LITERAL: _LITERAL,\n  MEMBER: _MEMBER,\n  OBJECT: _OBJECT,\n  PROPERTY: _PROPERTY,\n  SEQUENCE: _SEQUENCE,\n  UNARY: _UNARY,\n  UPDATE: _UPDATE,\n}\n"],
  "mappings": "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",
  "names": ["nodes", "node", "run", "ARRAY", "ASSIGN", "BINARY", "CALL", "CONDITION", "IDENTIFIER", "LITERAL", "MEMBER", "OBJECT", "PROPERTY", "SEQUENCE", "UNARY", "UPDATE"]
}
