{
  "version": 3,
  "sources": ["../src/parse.js", "../src/run.js", "../src/index.js"],
  "sourcesContent": ["// Based on jsep, v1.3.6, https://github.com/EricSmekens/jsep#readme).\n\nimport {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  PROPERTY,\n  SEQUENCE,\n  UNARY,\n  UPDATE\n} from './types.js'\n\n// Character codes.\nconst SPACE_CODES = [\n  9, // Tab\n  10, // LF\n  13, // CR\n  32, // Space\n]\nconst OPENING_PARENTHESIS_CODE = 40 // (\nconst CLOSING_PARENTHESIS_CODE = 41 // )\nconst COMMA_CODE = 44 // ,\nconst PERIOD_CODE = 46 // .\nconst COLON_CODE = 58 // :\nconst QUESTION_MARK_CODE = 63 // ?\nconst OPENING_BRACKET_CODE = 91 // [\nconst CLOSING_BRACKET_CODE = 93 // ]\nconst CLOSING_BRACES_CODE = 125 // }\n\n// Operators.\nconst ASSIGNMENT_OPERATORS = [\n  '=',\n  '||=',\n  '&&=',\n  '??=',\n  '*=',\n  '**=',\n  '/=',\n  '%=',\n  '+=',\n  '-=',\n  // '<<=',\n  // '>>=',\n  // '>>>=',\n  // '&=',\n  // '^=',\n  // '|=',\n]\nconst BINARY_OPERATORS = {\n  '=': 1,\n  '||=': 1,\n  '&&=': 1,\n  '??=': 1,\n  '*=': 1,\n  '**=': 1,\n  '/=': 1,\n  '%=': 1,\n  '+=': 1,\n  '-=': 1,\n  // '<<=': 1,\n  // '>>=': 1,\n  // '>>>=': 1,\n  // '&=': 1,\n  // '^=': 1,\n  // '|=': 1,\n  '||': 2,\n  '&&': 3,\n  '??': 4,\n  // '|': 5,\n  // '^': 6,\n  // '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  // '<<': 10,\n  // '>>': 10,\n  // '>>>': 10,\n  '*': 11,\n  '/': 11,\n  '%': 11,\n  '+': 11,\n  '-': 11,\n}\nconst UNARY_OPERATORS = [\n  '-',\n  '!',\n  // '~',\n  '+',\n]\nconst UPDATE_OPERATOR_DECREMENT = '--'\nconst UPDATE_OPERATOR_INCREMENT = '++'\n\n// Literal lookup.\nconst LITERALS = {\n  true: true,\n  false: false,\n  null: null,\n  undefined,\n}\n\nconst isDecimalDigit = (character) =>\n  (character >= 48 && character <= 57) // Between 0 and 9\n\nconst isIdentifierPart = (character) =>\n  isIdentifierStart(character) || isDecimalDigit(character)\n\nconst isIdentifierStart = (character) =>\n  character === 36 || // Dollar ($)\n  (character >= 48 && character <= 57) || // Between 0 and 9\n  character === 95 || // Underscore\n  (character >= 65 && character <= 90) || // Between A and Z\n  (character >= 97 && character <= 122) // Between a and z\n\nexport default (expression) => {\n  let index = 0\n\n  const gobbleArray = () => {\n    index++\n\n    return {\n      type: ARRAY,\n      elements: gobbleParameters(CLOSING_BRACKET_CODE),\n    }\n  }\n\n  const gobbleParameters = (termination) => {\n    const parameters = []\n    let closed = false\n\n    let separatorCount = 0\n    while (index < expression.length) {\n      gobbleSpaces()\n      const characterIndex = expression.charCodeAt(index)\n\n      if (characterIndex === termination) {\n        closed = true\n        index++\n\n        if (termination === CLOSING_PARENTHESIS_CODE && separatorCount && separatorCount >= parameters.length) {\n          throw new Error('Unexpected token ' + String.fromCharCode(termination))\n        }\n        break\n      } else if (characterIndex === COMMA_CODE) {\n        index++\n        separatorCount++\n\n        if (separatorCount !== parameters.length) {\n          if (termination === CLOSING_PARENTHESIS_CODE) {\n            throw new Error('Unexpected token ,')\n          } else if (termination === CLOSING_BRACKET_CODE) {\n            for (let i = parameters.length; i < separatorCount; i++) {\n              parameters.push(null)\n            }\n          }\n        }\n      } else if (parameters.length !== separatorCount && separatorCount !== 0) {\n        throw new Error('Expected comma')\n      } else {\n        const node = gobbleExpression()\n\n        if (!node) {\n          throw new Error('Expected comma')\n        }\n\n        parameters.push(node)\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Expected ' + String.fromCharCode(termination))\n    }\n\n    return parameters\n  }\n\n  const gobbleBinaryExpression = () => {\n    let left = gobbleToken()\n    if (!left) {\n      return left\n    }\n\n    let operator = gobbleBinaryOperation()\n    if (!operator) {\n      return left\n    }\n\n    let binaryOperationInfo = {\n      value: operator,\n      precedence: BINARY_OPERATORS[operator] || 0,\n    }\n\n    let right = gobbleToken()\n    if (!right) {\n      throw new Error('Expected expression after ' + operator)\n    }\n\n    const stack = [\n      left,\n      binaryOperationInfo,\n      right,\n    ]\n\n    let node\n    while ((operator = gobbleBinaryOperation())) {\n      const precedence = BINARY_OPERATORS[operator] || 0\n\n      if (precedence === 0) {\n        index -= operator.length\n        break\n      }\n\n      binaryOperationInfo = {\n        value: operator,\n        precedence,\n      }\n\n      const currentBinaryOperation = operator\n      while (stack.length > 2 && stack[stack.length - 2] > precedence) {\n        right = stack.pop()\n        operator = stack.pop().value\n        left = stack.pop()\n        node = {\n          type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n            ? ASSIGN\n            : BINARY,\n          operator,\n          left,\n          right,\n        }\n        stack.push(node)\n      }\n\n      node = gobbleToken()\n\n      if (!node) {\n        throw new Error('Expected expression after ' + currentBinaryOperation)\n      }\n\n      stack.push(binaryOperationInfo, node)\n    }\n\n    let i = stack.length - 1\n    node = stack[i]\n\n    while (i > 1) {\n      operator = stack[i - 1].value\n      node = {\n        type: ASSIGNMENT_OPERATORS.indexOf(operator) >= 0\n          ? ASSIGN\n          : BINARY,\n        operator,\n        left: stack[i - 2],\n        right: node,\n      }\n      i -= 2\n    }\n\n    return node\n  }\n\n  const gobbleBinaryOperation = () => {\n    gobbleSpaces()\n    let toCheck = expression.substring(index, index + 3) // 3 = Maximum binary operator length.\n    let toCheckLength = toCheck.length\n\n    while (toCheckLength > 0) {\n      if (Object.prototype.hasOwnProperty.call(BINARY_OPERATORS, toCheck) && (\n        !isIdentifierStart(expression.charCodeAt(index)) ||\n        (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n      )) {\n        index += toCheckLength\n        return toCheck\n      }\n      toCheck = toCheck.substring(0, --toCheckLength)\n    }\n    return false\n  }\n\n  const gobbleExpression = () => {\n    let node = gobbleBinaryExpression()\n    gobbleSpaces()\n    node = gobbleTernary(node)\n    return node\n  }\n\n  const gobbleExpressions = (untilCharacterCode) => {\n    const nodes = []\n    while (index < expression.length) {\n      const characterIndex = expression.charCodeAt(index)\n      if (\n        characterIndex === 59 || // Semicolon (;)\n        characterIndex === COMMA_CODE\n      ) {\n        index++\n      } else {\n        const node = gobbleExpression()\n        if (node) {\n          nodes.push(node)\n        } else if (index < expression.length) {\n          if (characterIndex === untilCharacterCode) {\n            break\n          }\n          throw new Error('Unexpected \"' + expression.charAt(index) + '\"')\n        }\n      }\n    }\n    return nodes\n  }\n\n  const gobbleIdentifier = () => {\n    let character = expression.charCodeAt(index)\n    const start = index\n\n    if (isIdentifierStart(character)) {\n      index++\n    } else {\n      throw new Error('Unexpected ' + expression.charAt(index))\n    }\n\n    while (index < expression.length) {\n      character = expression.charCodeAt(index)\n\n      if (isIdentifierPart(character)) {\n        index++\n      } else {\n        break\n      }\n    }\n    return {\n      type: IDENTIFIER,\n      name: expression.slice(start, index),\n    }\n  }\n\n  const gobbleNumericLiteral = () => {\n    let number = ''\n    while (isDecimalDigit(expression.charCodeAt(index))) {\n      number += expression.charAt(index++)\n    }\n    if (expression.charCodeAt(index) === PERIOD_CODE) {\n      number += expression.charAt(index++)\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n    }\n\n    let character = expression.charAt(index)\n    if (character === 'e' || character === 'E') {\n      number += expression.charAt(index++)\n      character = expression.charAt(index)\n\n      if (character === '+' || character === '-') {\n        number += expression.charAt(index++)\n      }\n\n      while (isDecimalDigit(expression.charCodeAt(index))) {\n        number += expression.charAt(index++)\n      }\n\n      if (!isDecimalDigit(expression.charCodeAt(index - 1))) {\n        throw new Error('Expected exponent (' + number + expression.charAt(index) + ')')\n      }\n    }\n\n    const characterCode = expression.charCodeAt(index)\n    if (isIdentifierStart(characterCode)) {\n      throw new Error('Variable names cannot start with a number (' + number + expression.charAt(index) + ')')\n    } else if (\n      characterCode === PERIOD_CODE ||\n      (\n        number.length === 1 &&\n        number.charCodeAt(0) === PERIOD_CODE\n      )\n    ) {\n      throw new Error('Unexpected period')\n    }\n\n    return {\n      type: LITERAL,\n      value: parseFloat(number),\n      // raw: number,\n    }\n  }\n\n  const gobbleObjectExpression = () => {\n    // Check if opening brace \"{\"\n    if (expression.charCodeAt(index) !== 123) {\n      return\n    }\n    index++\n\n    const properties = []\n    while (!isNaN(expression.charCodeAt(index))) {\n      gobbleSpaces()\n      if (expression.charCodeAt(index) === CLOSING_BRACES_CODE) {\n        index++\n        return gobbleTokenProperty({\n          type: OBJECT,\n          properties,\n        })\n      }\n\n      const key = gobbleToken()\n      if (!key) {\n        throw new Error('Missing }')\n      }\n      gobbleSpaces()\n\n      if (\n        key.type === IDENTIFIER &&\n        (\n          expression.charCodeAt(index) === COMMA_CODE ||\n          expression.charCodeAt(index) === CLOSING_BRACES_CODE\n        )\n      ) {\n        properties.push({\n          type: PROPERTY,\n          computed: false,\n          key,\n          value: key,\n          shorthand: true,\n        })\n      } else if (expression.charCodeAt(index) === COLON_CODE) {\n        index++\n        gobbleSpaces()\n        const value = gobbleExpression()\n        if (!value) {\n          throw new Error('Unexpected object property')\n        }\n\n        const computed = key.type === ARRAY\n        properties.push({\n          computed,\n          key: computed\n            ? key.elements[0]\n            : key,\n          shorthand: false,\n          type: PROPERTY,\n          value,\n        })\n        gobbleSpaces()\n      } else if (key) {\n        properties.push(key)\n      }\n\n      if (expression.charCodeAt(index) === COMMA_CODE) {\n        index++\n      }\n    }\n    throw new Error('Missing }')\n  }\n\n  const gobbleSequence = () => {\n    index++\n\n    const nodes = gobbleExpressions(CLOSING_PARENTHESIS_CODE)\n    if (expression.charCodeAt(index) === CLOSING_PARENTHESIS_CODE) {\n      index++\n\n      if (nodes.length === 1) {\n        return nodes[0]\n      }\n      if (!nodes.length) {\n        return false\n      }\n\n      return {\n        type: SEQUENCE,\n        expressions: nodes,\n      }\n    }\n\n    throw new Error('Unclosed (')\n  }\n\n  const gobbleSpaces = () => {\n    while (SPACE_CODES.indexOf(expression.charCodeAt(index)) >= 0) {\n      index++\n    }\n  }\n\n  const gobbleStringLiteral = () => {\n    let string = ''\n    // const startIndex = index\n    const quote = expression.charAt(index++)\n    let closed = false\n\n    while (index < expression.length) {\n      let character = expression.charAt(index++)\n\n      if (character === quote) {\n        closed = true\n        break\n      }\n      if (character === '\\\\') {\n        character = expression.charAt(index++)\n\n        switch (character) {\n          case 'n':\n            string += '\\n'\n            break\n\n          case 'r':\n            string += '\\r'\n            break\n\n          case 't':\n            string += '\\t'\n            break\n\n          case 'b':\n            string += '\\b'\n            break\n\n          case 'f':\n            string += '\\f'\n            break\n\n          case 'v':\n            string += '\\x0B'\n            break\n\n          default:\n            string += character\n        }\n      } else {\n        string += character\n      }\n    }\n\n    if (!closed) {\n      throw new Error('Unclosed quote after \"' + string + '\"')\n    }\n\n    return {\n      type: LITERAL,\n      value: string,\n      // raw: expression.substring(startIndex, index),\n    }\n  }\n\n  const gobbleTernary = (node) => {\n    if (!node || expression.charCodeAt(index) !== QUESTION_MARK_CODE) {\n      return node\n    }\n    index++\n\n    const consequent = gobbleExpression()\n    if (!consequent) {\n      throw new Error('Expected expression')\n    }\n\n    gobbleSpaces()\n\n    if (!expression.charCodeAt(index) === COLON_CODE) {\n      throw new Error('Expected :')\n    }\n    index++\n\n    const alternate = gobbleExpression()\n    if (!alternate) {\n      throw new Error('Expected expression')\n    }\n\n    let conditional = {\n      type: CONDITION,\n      condition: node,\n      consequent,\n      alternate,\n    }\n\n    if (node.operator && BINARY_OPERATORS[node.operator] <= 1) {\n      let newCondition = node\n      while (newCondition.right.operator && BINARY_OPERATORS[newCondition.right.operator] <= 1) {\n        newCondition = newCondition.right\n      }\n      conditional.condition = newCondition.right\n      newCondition.right = conditional\n      conditional = node\n    }\n\n    return conditional\n  }\n\n  const gobbleToken = () => {\n    let node = gobbleObjectExpression() || gobbleUpdatePrefixExpression()\n    if (node) {\n      return gobbleUpdateSuffixExpression(node)\n    }\n    gobbleSpaces()\n\n    const character = expression.charCodeAt(index)\n    if (isDecimalDigit(character) || character === PERIOD_CODE) {\n      return gobbleNumericLiteral()\n    }\n\n    if (character === 34 || character === 39) { // Double quote (\") or single quote (')\n      node = gobbleStringLiteral()\n    } else if (character === OPENING_BRACKET_CODE) {\n      node = gobbleArray()\n    } else {\n      let toCheck = expression.substring(index, index + 1) // 1 = Maximum unary operator length.\n      let toCheckLength = toCheck.length\n\n      while (toCheckLength > 0) {\n        if (UNARY_OPERATORS.indexOf(toCheck) >= 0 && (\n          !isIdentifierStart(expression.charCodeAt(index)) ||\n          (index + toCheck.length < expression.length && !isIdentifierPart(expression.charCodeAt(index + toCheck.length)))\n        )) {\n          index += toCheckLength\n          const parameter = gobbleToken()\n          if (!parameter) {\n            throw new Error('Missing unary operation parameter')\n          }\n          return gobbleUpdateSuffixExpression({\n            type: UNARY,\n            operator: toCheck,\n            parameter,\n          })\n        }\n\n        toCheck = toCheck.substr(0, --toCheckLength)\n      }\n\n      if (isIdentifierStart(character)) {\n        node = gobbleIdentifier()\n        if (Object.prototype.hasOwnProperty.call(LITERALS, node.name)) {\n          node = {\n            type: LITERAL,\n            value: LITERALS[node.name],\n            // raw: node.name,\n          }\n        }\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = gobbleSequence()\n      }\n    }\n\n    return gobbleUpdateSuffixExpression(\n      gobbleTokenProperty(node)\n    )\n  }\n\n  const gobbleTokenProperty = (node) => {\n    gobbleSpaces()\n\n    let character = expression.charCodeAt(index)\n    while (\n      character === PERIOD_CODE ||\n      character === OPENING_BRACKET_CODE ||\n      character === OPENING_PARENTHESIS_CODE ||\n      character === QUESTION_MARK_CODE\n    ) {\n      let optional\n      if (character === QUESTION_MARK_CODE) {\n        if (expression.charCodeAt(index + 1) !== PERIOD_CODE) {\n          break\n        }\n        optional = true\n        index += 2\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n      }\n      index++\n\n      if (character === OPENING_BRACKET_CODE) {\n        node = {\n          type: MEMBER,\n          computed: true,\n          object: node,\n          property: gobbleExpression(),\n        }\n        gobbleSpaces()\n        character = expression.charCodeAt(index)\n        if (character !== CLOSING_BRACKET_CODE) {\n          throw new Error('Unclosed [')\n        }\n        index++\n      } else if (character === OPENING_PARENTHESIS_CODE) {\n        node = {\n          type: CALL,\n          parameters: gobbleParameters(CLOSING_PARENTHESIS_CODE),\n          callee: node,\n        }\n      } else if (character === PERIOD_CODE || optional) {\n        if (optional) {\n          index--\n        }\n        gobbleSpaces()\n        node = {\n          type: MEMBER,\n          computed: false,\n          object: node,\n          property: gobbleIdentifier(),\n        }\n      }\n\n      if (optional) {\n        node.optional = true\n      }\n\n      gobbleSpaces()\n      character = expression.charCodeAt(index)\n    }\n\n    return node\n  }\n\n  const gobbleUpdatePrefixExpression = () => {\n    if (index + 1 >= expression.length) {\n      return\n    }\n\n    const characters = expression.substring(index, index + 2) // 2 = Maximum update expression length\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return\n    }\n\n    index += 2\n    const node = {\n      type: UPDATE,\n      operator,\n      parameter: gobbleTokenProperty(gobbleIdentifier()),\n      prefix: true,\n    }\n    if (!node.parameter || (node.parameter.type !== IDENTIFIER && node.parameter.type !== MEMBER)) {\n      throw new Error('Unexpected ' + node.operator)\n    }\n    return node\n  }\n\n  const gobbleUpdateSuffixExpression = (node) => {\n    if (!node || index + 1 >= expression.length) {\n      return node\n    }\n\n    const characters = expression.substring(index, index + 2)\n    let operator = null\n    if (characters === UPDATE_OPERATOR_DECREMENT) {\n      operator = UPDATE_OPERATOR_DECREMENT\n    } else if (characters === UPDATE_OPERATOR_INCREMENT) {\n      operator = UPDATE_OPERATOR_INCREMENT\n    } else {\n      return node\n    }\n\n    index += 2\n    node = {\n      type: UPDATE,\n      operator,\n      parameter: node,\n      prefix: false,\n    }\n    return node\n  }\n\n  const nodes = gobbleExpressions()\n  return nodes.length === 0 ? undefined : nodes\n}\n", "import {\n  ARRAY,\n  ASSIGN,\n  BINARY,\n  CALL,\n  CONDITION,\n  IDENTIFIER,\n  LITERAL,\n  MEMBER,\n  OBJECT,\n  SEQUENCE,\n  UNARY,\n  UPDATE\n} from './types.js'\n\nconst setToContext = (\n  node,\n  value,\n  context = {}\n) => {\n  switch (node.type) {\n    case IDENTIFIER:\n      // Assign to\n      context[node.name] = value\n      return value\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (value) === 'function') {\n        return value.bind(memberObject)\n      }\n      memberObject[memberProperty] = value\n      return value\n  }\n\n  throw new Error('Unsupported assignment method.')\n}\n\nconst run = (\n  node,\n  context = {}\n) => {\n  if (!node) {\n    return\n  }\n\n  if (Array.isArray(node)) {\n    return node.map(node => run(node, context))\n  }\n\n  switch (node.type) {\n    case IDENTIFIER:\n      return context[node.name]\n\n    case LITERAL:\n      return node.value\n\n    case ARRAY:\n      const arrayResults = []\n      for (const arrayElement of node.elements) {\n        arrayResults.push(run(arrayElement, context))\n      }\n      return arrayResults\n\n    case ASSIGN:\n      let assignmentValue = run(node.right, context)\n      // Modify value if not a direct assignment.\n      if (node.operator !== '=') {\n        const assignmentLeft = run(node.left, context)\n        switch (node.operator) {\n          case '||=':\n            if (assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '&&=':\n            if (!assignmentLeft) {\n              return assignmentLeft\n            }\n            break\n          case '??=':\n            if (assignmentLeft !== null && assignmentLeft !== undefined) {\n              return assignmentLeft\n            }\n            break\n          case '*=':\n            assignmentValue = assignmentLeft * assignmentValue\n            break\n          case '**=':\n            assignmentValue = assignmentLeft ** assignmentValue\n            break\n          case '/=':\n            assignmentValue = assignmentLeft / assignmentValue\n            break\n          case '%=':\n            assignmentValue = assignmentLeft % assignmentValue\n            break\n          case '+=':\n            assignmentValue = assignmentLeft + assignmentValue\n            break\n          case '-=':\n            assignmentValue = assignmentLeft - assignmentValue\n            break\n        }\n      }\n      return setToContext(node.left, assignmentValue, context)\n\n    case BINARY:\n      const binaryLeft = run(node.left, context)\n      const binaryRight = run(node.right, context)\n      switch (node.operator) {\n        case '||':\n          return binaryLeft || binaryRight\n        case '&&':\n          return binaryLeft && binaryRight\n        case '??':\n          return binaryLeft ?? binaryRight\n        case '==':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft == binaryRight\n        case '!=':\n          // eslint-disable-next-line eqeqeq\n          return binaryLeft != binaryRight\n        case '===':\n          return binaryLeft === binaryRight\n        case '!==':\n          return binaryLeft !== binaryRight\n        case '<':\n          return binaryLeft < binaryRight\n        case '>':\n          return binaryLeft > binaryRight\n        case '<=':\n          return binaryLeft <= binaryRight\n        case '>=':\n          return binaryLeft >= binaryRight\n        case '-':\n          return binaryLeft - binaryRight\n        case '+':\n          return binaryLeft + binaryRight\n        case '*':\n          return binaryLeft * binaryRight\n        case '/':\n          return binaryLeft / binaryRight\n        case '%':\n          return binaryLeft % binaryRight\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case CALL:\n      const parameters = []\n      for (const parameter of node.parameters) {\n        parameters.push(run(parameter, context))\n      }\n      return run(node.callee, context)(...parameters)\n\n    case CONDITION:\n      return run(node.condition, context)\n        ? run(node.consequent, context)\n        : run(node.alternate, context)\n\n    case MEMBER:\n      const memberObject = run(node.object, context)\n      const memberProperty =\n        node.computed || node.property.type !== IDENTIFIER\n          ? run(node.property, context)\n          : node.property.name\n      if (typeof (memberObject[memberProperty]) === 'function') {\n        return memberObject[memberProperty].bind(memberObject)\n      }\n      return memberObject[memberProperty]\n\n    case OBJECT:\n      const objectResult = {}\n      for (const objectProperty of node.properties) {\n        // Expects each property to be of type PROPERTY.\n        objectResult[\n          (objectProperty.computed || objectProperty.key.type !== IDENTIFIER) ? run(objectProperty.key, context) : objectProperty.key.name\n        ] = run(objectProperty.value, context)\n      }\n      return objectResult\n\n    case SEQUENCE:\n      return node.expressions.map(node => run(node, context))\n\n    case UNARY:\n      const unaryParameter = run(node.parameter, context)\n      switch (node.operator) {\n        case '!':\n          return !unaryParameter\n        case '-':\n          return -unaryParameter\n        case '+':\n          return +unaryParameter\n      }\n      throw new Error('Unsupported operator: ' + node.operator)\n\n    case UPDATE:\n      const updateResult = run(node.parameter, context)\n      const updateValue = node.operator === '--' ? -1 : 1\n      setToContext(node.parameter, updateResult + updateValue, context)\n      return node.prefix ? updateResult + updateValue : updateResult\n  }\n\n  throw new Error('Unexpected node type \"' + node.type + '\".')\n}\nexport default run\n", "import _parse from './parse.js'\nimport _run from './run.js'\nimport {\n  ARRAY as _ARRAY,\n  ASSIGN as _ASSIGN,\n  BINARY as _BINARY,\n  CALL as _CALL,\n  CONDITION as _CONDITION,\n  IDENTIFIER as _IDENTIFIER,\n  LITERAL as _LITERAL,\n  MEMBER as _MEMBER,\n  OBJECT as _OBJECT,\n  PROPERTY as _PROPERTY,\n  SEQUENCE as _SEQUENCE,\n  UNARY as _UNARY,\n  UPDATE as _UPDATE\n} from './types.js'\n\nexport const interpret = (expression, context) => {\n  return _run(_parse(expression), context)\n}\nexport const parse = _parse\nexport const run = _run\n\nexport const ARRAY = _ARRAY\nexport const ASSIGN = _ASSIGN\nexport const BINARY = _BINARY\nexport const CALL = _CALL\nexport const CONDITION = _CONDITION\nexport const IDENTIFIER = _IDENTIFIER\nexport const LITERAL = _LITERAL\nexport const MEMBER = _MEMBER\nexport const OBJECT = _OBJECT\nexport const PROPERTY = _PROPERTY\nexport const SEQUENCE = _SEQUENCE\nexport const UNARY = _UNARY\nexport const UPDATE = _UPDATE\n\nexport default {\n  interpret,\n  parse: _parse,\n  run: _run,\n\n  ARRAY: _ARRAY,\n  ASSIGN: _ASSIGN,\n  BINARY: _BINARY,\n  CALL: _CALL,\n  CONDITION: _CONDITION,\n  IDENTIFIER: _IDENTIFIER,\n  LITERAL: _LITERAL,\n  MEMBER: _MEMBER,\n  OBJECT: _OBJECT,\n  PROPERTY: _PROPERTY,\n  SEQUENCE: _SEQUENCE,\n  UNARY: _UNARY,\n  UPDATE: _UPDATE,\n}\n"],
  "mappings": "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",
  "names": ["SPACE_CODES", "OPENING_PARENTHESIS_CODE", "CLOSING_PARENTHESIS_CODE", "COMMA_CODE", "PERIOD_CODE", "COLON_CODE", "QUESTION_MARK_CODE", "OPENING_BRACKET_CODE", "CLOSING_BRACKET_CODE", "CLOSING_BRACES_CODE", "ASSIGNMENT_OPERATORS", "BINARY_OPERATORS", "UNARY_OPERATORS", "UPDATE_OPERATOR_DECREMENT", "UPDATE_OPERATOR_INCREMENT", "LITERALS", "isDecimalDigit", "character", "isIdentifierPart", "isIdentifierStart", "parse_default", "expression", "index", "gobbleArray", "gobbleParameters", "termination", "parameters", "closed", "separatorCount", "gobbleSpaces", "characterIndex", "node", "gobbleExpression", "gobbleBinaryExpression", "left", "gobbleToken", "operator", "gobbleBinaryOperation", "binaryOperationInfo", "right", "stack", "precedence", "currentBinaryOperation", "i", "toCheck", "toCheckLength", "gobbleTernary", "gobbleExpressions", "untilCharacterCode", "nodes", "gobbleIdentifier", "start", "gobbleNumericLiteral", "number", "characterCode", "gobbleObjectExpression", "properties", "gobbleTokenProperty", "key", "value", "computed", "gobbleSequence", "gobbleStringLiteral", "string", "quote", "consequent", "alternate", "conditional", "newCondition", "gobbleUpdatePrefixExpression", "gobbleUpdateSuffixExpression", "parameter", "optional", "characters", "setToContext", "node", "value", "context", "memberObject", "run", "memberProperty", "arrayResults", "arrayElement", "assignmentValue", "assignmentLeft", "__pow", "binaryLeft", "binaryRight", "parameters", "parameter", "objectResult", "objectProperty", "unaryParameter", "updateResult", "updateValue", "run_default", "interpret", "expression", "context", "run_default", "parse_default", "parse", "run", "ARRAY", "ASSIGN", "BINARY", "CALL", "CONDITION", "IDENTIFIER", "LITERAL", "MEMBER", "OBJECT", "PROPERTY", "SEQUENCE", "UNARY", "UPDATE", "src_default"]
}
