{
  "version": 3,
  "sources": ["../src/factories/contexts/store.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../../common/src/utils/Object.js", "../src/DoarsStore.js"],
  "sourcesContent": ["export default ((options, id, store, proxy) => {\n  return {\n    deconstruct: !!options.deconstruct,\n    name: '$store',\n    create: (component, attribute, update, {\n      RevocableProxy\n    }) => {\n      // Create event handlers.\n      const onDelete = (target, path) => update(id, path.join('.'));\n\n      const onGet = (target, path) => attribute.accessed(id, path.join('.'));\n\n      const onSet = (target, path) => update(id, path.join('.')); // Add event listeners.\n\n\n      proxy.addEventListener('delete', onDelete);\n      proxy.addEventListener('get', onGet);\n      proxy.addEventListener('set', onSet); // Wrap in a revocable proxy.\n\n      const revocable = RevocableProxy(store, {});\n      return {\n        value: revocable.proxy,\n        // Remove event listeners.\n        destroy: () => {\n          proxy.removeEventListener('delete', onDelete);\n          proxy.removeEventListener('get', onGet);\n          proxy.removeEventListener('set', onSet); // Revoke access to store.\n\n          revocable.revoke();\n        }\n      };\n    }\n  };\n});", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = ['apply', 'construct', 'defineProperty', 'deleteProperty', 'get', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf'];\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\n\nexport default ((target, handler) => {\n  // Keep track of status.\n  let revoked = false; // Add revocable handlers for each given handlers.\n\n  const revocableHandler = {};\n\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy');\n        return;\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters);\n      }\n\n      return Reflect[key](...parameters);\n    };\n  } // Return proxy and revoke method.\n\n\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true;\n    }\n  };\n});", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {};\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = [];\n      } // Add to events.\n\n\n      events[name].push({\n        callback: callback,\n        options: options\n      });\n    };\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n\n\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return;\n      }\n\n      const eventData = events[name]; // Get index of callback in events.\n\n      let index = -1;\n\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return;\n      } // Remove item from events.\n\n\n      eventData.splice(index, 1); // Remove event if list is empty.\n\n      if (Object.keys(eventData).length === 0) {\n        delete events[name];\n      }\n    };\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeEventListeners = name => {\n      if (!name) {\n        return;\n      } // Remove all handlers with the event name.\n\n\n      delete events[name];\n    };\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {};\n    };\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n\n\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return;\n      } // Get events by trigger name.\n\n\n      const eventData = events[name]; // Dispatch a call to each event.\n\n      for (let i = 0; i < eventData.length; i++) {\n        const event = options && options.reverse ? eventData[eventData.length - (i + 1)] : eventData[i]; // If once is truthy then remove the callback.\n\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1);\n        } // Execute callback.\n\n\n        event.callback(...parameters);\n      }\n    };\n  }\n\n}\n\nexport default EventDispatcher;", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'; // Import event dispatcher.\n\nimport EventDispatcher from './EventDispatcher.js';\n\nclass ProxyDispatcher extends EventDispatcher {\n  constructor(options = {}) {\n    super();\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true\n    }, options); // Setup WeakMap for keep track of created proxies.\n\n    const map = new WeakMap();\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n\n    this.add = (target, path = []) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target);\n      } // Recursively create proxies for each property.\n\n\n      for (const key in target) {\n        if (target[key] && typeof target[key] === 'object') {\n          target[key] = this.add(target[key], [...path, key]);\n        }\n      } // Create handler and add the handler for which a callback exits..\n\n\n      const handler = {};\n\n      if (options.delete) {\n        handler.deleteProperty = (target, key) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true;\n          } // Remove proxy.\n\n\n          this.remove(target, key); // Delete property.\n\n          const deleted = Reflect.deleteProperty(target, key); // Dispatch delete event.\n\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]]);\n          } // Return deleted.\n\n\n          return deleted;\n        };\n      }\n\n      if (options.get) {\n        handler.get = (target, key, receiver) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver]);\n          } // Return value from object.\n\n\n          return Reflect.get(target, key, receiver);\n        };\n      }\n\n      if (options.set) {\n        handler.set = (target, key, value, receiver) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true;\n          } // Add proxy if value is an object.\n\n\n          if (typeof value === 'object') {\n            value = this.add(value, [...path, key]);\n          } // Store value.\n\n\n          target[key] = value; // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver]); // Return success.\n\n          return true;\n        };\n      } // Create proxy.\n\n\n      const revocable = RevocableProxy(target, handler); // Store target at proxy.\n\n      map.set(revocable, target); // Return proxy.\n\n      return revocable.proxy;\n    };\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n\n\n    this.remove = target => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return;\n      }\n\n      const revocable = map.get(target);\n      map.delete(revocable); // Recursively remove properties as well.\n\n      for (const property in revocable.proxy) {\n        if (typeof revocable.proxy[property] === 'object') {\n          this.remove(revocable.proxy[property]);\n        }\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    };\n  }\n\n}\n\nexport default ProxyDispatcher;", "/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (target, ...sources) => {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepAssign(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map(value => {\n          if (isObject(value)) {\n            return deepAssign({}, value);\n          }\n\n          return value;\n        });\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources);\n};\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\n\nexport const getDeeply = (object, path) => {\n  let objectTemp = object;\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]];\n  }\n\n  return objectTemp[path[i]];\n};\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\n\nexport const isObject = value => {\n  return value && typeof value === 'object' && !Array.isArray(value);\n};\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\n\nexport const setDeeply = (object, path, value) => {\n  // Exit early if not an object.\n  if (typeof object !== 'object') {\n    return;\n  }\n\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]; // Exit early if not an object.\n\n    if (typeof object !== 'object') {\n      return;\n    }\n  }\n\n  object[path[i]] = value;\n};\nexport default {\n  deepAssign: deepAssign,\n  getDeeply: getDeeply,\n  isObject: isObject,\n  setDeeply: setDeeply\n};", "// Import contexts.\nimport createContextStore from './factories/contexts/store.js'; // Import proxy dispatcher.\n\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'; // Import utils.\n\nimport { deepAssign } from '@doars/common/src/utils/Object.js';\nexport default class DoarsStore {\n  /**\n   * Create plugin instance.\n   * @param {Doars} library Doars instance to add onto.\n   * @param {Object} options The plugin options.\n   * @param {Object} dataStore Initial store data.\n   */\n  constructor(library, options = null, dataStore = {}) {\n    // Clone options.\n    options = Object.assign({\n      deconstruct: false\n    }, options); // Set private variables.\n\n    let contextStore, dataStoreCopy, proxy, store; // Enable plugin when library is enabling.\n\n    library.addEventListener('enabling', () => {\n      // Create proxy.\n      dataStoreCopy = deepAssign({}, dataStore);\n      proxy = new ProxyDispatcher();\n      store = proxy.add(dataStoreCopy); // Create store id.\n\n      const id = Symbol('ID_STORE'); // Create contexts.\n\n      contextStore = createContextStore(options, id, store, proxy); // Get index of state and insert the context directly before it.\n\n      const existingContexts = library.getContexts();\n      let stateIndex = 0;\n\n      for (let i = existingContexts.length - 1; i >= 0; i--) {\n        const context = existingContexts[i];\n\n        if (context.name === '$state') {\n          stateIndex = i;\n          break;\n        }\n      }\n\n      library.addContexts(stateIndex, contextStore);\n    }); // Disable plugin when library is disabling.\n\n    library.addEventListener('disabling', () => {\n      // Remove contexts.\n      library.removeContexts(contextStore); // Reset references.\n\n      store = null;\n      proxy.remove(dataStoreCopy);\n      proxy = null;\n      dataStoreCopy = null;\n      directiveSyncStore = null;\n      contextStore = null;\n    });\n  }\n\n}"],
  "mappings": "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",
  "names": []
}
