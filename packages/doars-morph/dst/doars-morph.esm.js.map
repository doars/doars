{
  "version": 3,
  "sources": ["../../common/src/utilities/Attribute.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Morph.js", "../src/contexts/morph.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/Promise.js", "../src/directives/morph.js", "../src/DoarsMorph.js"],
  "sourcesContent": ["/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className);\n      }\n\n      continue;\n    } // Set attribute.\n\n\n    element.setAttribute(name, data[name]);\n  }\n};\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\n\nexport const copyAttributes = (existingNode, newNode) => {\n  const existingAttributes = existingNode.attributes;\n  const newAttributes = newNode.attributes;\n  let attributeNamespaceURI = null;\n  let attributeValue = null;\n  let fromValue = null;\n  let attributeName = null;\n  let attribute = null;\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i];\n    attributeName = attribute.name;\n    attributeNamespaceURI = attribute.namespaceURI;\n    attributeValue = attribute.value;\n\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName;\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName);\n\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue);\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue);\n      } else {\n        fromValue = existingNode.getAttribute(attributeName);\n\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName);\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue);\n          }\n        }\n      }\n    }\n  } // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n\n\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j];\n\n    if (attribute.specified !== false) {\n      attributeName = attribute.name;\n      attributeNamespaceURI = attribute.namespaceURI;\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName;\n\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName);\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n};\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\n\nexport const removeAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className);\n      }\n\n      continue;\n    } // Check if optional values match.\n\n\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue;\n    } // Remove attribute.\n\n\n    element.removeAttribute(name);\n  }\n};\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\n\nexport const setAttribute = (element, key, data) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = '';\n    } // Exit early if nothing will change.\n\n\n    if (element.getAttribute(key) === data) {\n      return;\n    } // Update attribute.\n\n\n    element.setAttribute(key, data); // Exit special cases early.\n\n    return;\n  } // If checked attribute then set the checked property instead.\n\n\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data;\n      return;\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ');\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';');\n    }\n  } // Update attribute on element.\n\n\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key);\n  } else {\n    element.setAttribute(key, data);\n  }\n};\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\n\nexport const setAttributes = (element, data) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name]);\n  }\n};\nexport default {\n  addAttributes: addAttributes,\n  copyAttributes: copyAttributes,\n  removeAttributes: removeAttributes,\n  setAttribute: setAttribute\n};", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = string => {\n  const template = document.createElement('template');\n  template.innerHTML = string;\n  return template.content.childNodes[0];\n};\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\n\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling);\n  } else {\n    reference.parentNode.appendChild(node);\n  }\n};\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\n\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b);\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false;\n  }\n\n  if (a.type === 3) {\n    // Text node.\n    return a.nodeValue === b.nodeValue;\n  }\n\n  return false;\n};\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\n\nexport const walk = (element, filter) => {\n  let index = -1;\n  let iterator = null;\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator();\n\n      if (child) {\n        return child;\n      }\n    } // Get next child that passes the filter.\n\n\n    let child = null;\n\n    do {\n      index++;\n\n      if (index >= element.childElementCount) {\n        return null;\n      }\n\n      child = element.children[index];\n    } while (!filter(child)); // Setup iterator for child.\n\n\n    if (child.childElementCount) {\n      iterator = walk(child, filter);\n    } // Return the child.\n\n\n    return child;\n  };\n};\nexport default {\n  fromString: fromString,\n  insertAfter: insertAfter,\n  isSame: isSame,\n  walk: walk\n};", "// Based on choo's nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme).\n// Import utilities.\nimport { copyAttributes } from './Attribute.js';\nimport { fromString as ElementFromString, isSame as ElementIsSame } from './Element.js';\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\n\nexport const morphNode = (existingNode, newNode) => {\n  const nodeType = newNode.nodeType;\n  const nodeName = newNode.nodeName; // Element node.\n\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode);\n  } // Text node or comment node.\n\n\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue;\n    }\n  } // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n\n\n  if (nodeName === 'INPUT') {\n    updateInput(existingNode, newNode);\n  } else if (nodeName === 'OPTION') {\n    updateAttribute(existingNode, newNode, 'selected');\n  } else if (nodeName === 'TEXTAREA') {\n    updateTextarea(existingNode, newNode);\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\n\nexport const morphTree = (existingTree, newTree, options) => {\n  if (typeof existingTree !== 'object') {\n    throw new Error('Existing tree should be an object.');\n  }\n\n  if (typeof newTree === 'string') {\n    newTree = ElementFromString(newTree);\n  } else if (typeof newTree !== 'object') {\n    throw new Error('New tree should be an object.');\n  } // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n\n\n  if (options && options.childrenOnly || newTree.nodeType === 11) {\n    updateChildren(existingTree, newTree);\n    return existingTree;\n  }\n\n  return updateTree(existingTree, newTree);\n};\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\nconst updateInput = (existingNode, newNode) => {\n  // The \"value\" attribute is special for the <input> element since it sets the\n  // initial value. Changing the \"value\" attribute without changing the \"value\"\n  // property will have no effect since it is only used to the set the initial\n  // value. Similar for the \"checked\" attribute, and \"disabled\".\n  const newValue = newNode.value;\n  const existingValue = existingNode.value;\n  updateAttribute(existingNode, newNode, 'checked');\n  updateAttribute(existingNode, newNode, 'disabled'); // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate;\n  } // Persist file value since file inputs can't be changed programmatically\n\n\n  if (existingNode.type === 'file') {\n    return;\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue);\n    existingNode.value = newValue;\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = '';\n    existingNode.removeAttribute('value');\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value');\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue;\n  }\n};\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateTextarea = (existingNode, newNode) => {\n  const newValue = newNode.value;\n\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue;\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and visa versa. This ignores an empty update.\n    if (existingNode.firstChild.nodeValue === existingNode.placeholder && newValue === '') {\n      return;\n    }\n\n    existingNode.firstChild.nodeValue = newValue;\n  }\n};\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateAttribute = (existingNode, newNode, name) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name];\n\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '');\n    } else {\n      existingNode.removeAttribute(name);\n    }\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\n\n\nconst updateTree = (existingTree, newTree) => {\n  if (!existingTree) {\n    return newTree;\n  }\n\n  if (!newTree) {\n    return null;\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree;\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree;\n  }\n\n  morphNode(existingTree, newTree);\n  updateChildren(existingTree, newTree);\n  return existingTree;\n};\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\n\n\nconst updateChildren = (existingNode, newNode) => {\n  let existingChild, newChild, morphed, existingMatch; // The offset is only ever increased, and used for [i - offset] in the loop\n\n  let offset = 0;\n\n  for (let i = 0;; i++) {\n    existingChild = existingNode.childNodes[i];\n    newChild = newNode.childNodes[i - offset]; // Both nodes are empty, do nothing\n\n    if (!existingChild && !newChild) {\n      break; // There is no new child, remove old\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild);\n      i--; // There is no old child, add new\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild);\n      offset++; // Both nodes are the same, morph\n    } else if (ElementIsSame(existingChild, newChild)) {\n      morphed = updateTree(existingChild, newChild);\n\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild);\n        offset++;\n      } // Both nodes do not share an ID or a placeholder, try reorder\n\n    } else {\n      existingMatch = null; // Try and find a similar node somewhere in the tree\n\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (ElementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j];\n          break;\n        }\n      } // If there was a node with the same ID or placeholder in the old list\n\n\n      if (existingMatch) {\n        morphed = updateTree(existingMatch, newChild);\n        if (morphed !== existingMatch) offset++;\n        existingNode.insertBefore(morphed, existingChild); // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = updateTree(existingChild, newChild);\n\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild);\n          offset++;\n        } // Insert the node at the index if we couldn't morph or find a matching node\n\n      } else {\n        existingNode.insertBefore(newChild, existingChild);\n        offset++;\n      }\n    }\n  }\n};\n\nexport default {\n  morphNode: morphNode,\n  morphTree: morphTree\n};", "import { morphTree } from '@doars/common/src/utilities/Morph.js';\nexport default {\n  name: '$morph',\n  create: () => {\n    return morphTree;\n  }\n};", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"'\n};\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;'\n};\nconst ENCODE_REGEXP = /[&<>'\"]/g;\nexport const decode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(DECODE_REGEXP, character => {\n    return DECODE_LOOKUP[character];\n  });\n};\nexport const encode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, character => {\n    return ENCODE_LOOKUP[character];\n  });\n};\nexport default {\n  decode: decode,\n  encode: encode\n};", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function\n/* A native object */\n).replace('Function', 'Promise') // Replace identifier.\n.replace(/\\(.*\\)/, '()'); // Remove possible FormalParameterList.\n\nexport const isNativePromise = value => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise;\n};\nexport const isPromise = value => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]';\n};\nexport default {\n  isPromise: isPromise,\n  isNativePromise: isNativePromise\n};", "// Import utilities.\nimport { decode } from '@doars/common/src/utilities/Html.js';\nimport { isPromise } from '@doars/common/src/utilities/Promise.js';\nimport { morphTree } from '@doars/common/src/utilities/Morph.js';\nexport default {\n  name: 'morph',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = html => {\n      // Decode string.\n      if (modifiers.decode && typeof html === 'string') {\n        html = decode(html);\n      } // Ensure element only has one child.\n\n\n      if (element.children.length === 0) {\n        element.appendChild(document.createElement('div'));\n      } else if (element.children.length > 1) {\n        for (let i = element.children.length - 1; i >= 1; i--) {\n          element.children[i].remove();\n        }\n      } // Morph first child to given element tree.\n\n\n      const root = morphTree(element.children[0], html);\n\n      if (!element.children[0].isSameNode(root)) {\n        element.children[0].remove();\n        element.appendChild(root);\n      }\n    }; // Execute value and retrieve result.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "// Import contexts and directive.\nimport contextMorph from './contexts/morph.js';\nimport directiveMorph from './directives/morph.js';\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n */\n\nexport default function (library) {\n  // Set private variables.\n  let isEnabled = false;\n\n  const onEnable = function () {\n    // Add contexts and directives.\n    library.addContexts(0, contextMorph);\n    library.addDirectives(-1, directiveMorph);\n  };\n\n  const onDisable = function () {\n    // Remove contexts and directives.\n    library.removeContexts(contextMorph);\n    library.removeDirectives(directiveMorph);\n  };\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false; // Stop listening to enable state of the library.\n\n      library.removeEventListener('enabling', onEnable);\n      library.removeEventListener('disabling', onDisable);\n    }\n  };\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true; // Listen to enable state of the library.\n\n      library.addEventListener('enabling', onEnable);\n      library.addEventListener('disabling', onDisable);\n    }\n  }; // Automatically enable plugin.\n\n\n  this.enable();\n}"],
  "mappings": "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",
  "names": ["morph_default", "morph_default"]
}
