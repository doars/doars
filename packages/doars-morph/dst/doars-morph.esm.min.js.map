{
  "version": 3,
  "sources": ["../../common/src/utilities/Attribute.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Morph.js", "../src/contexts/morph.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/Promise.js", "../src/directives/morph.js", "../src/DoarsMorph.js"],
  "sourcesContent": ["/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className);\n      }\n\n      continue;\n    } // Set attribute.\n\n\n    element.setAttribute(name, data[name]);\n  }\n};\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\n\nexport const copyAttributes = (existingNode, newNode) => {\n  const existingAttributes = existingNode.attributes;\n  const newAttributes = newNode.attributes;\n  let attributeNamespaceURI = null;\n  let attributeValue = null;\n  let fromValue = null;\n  let attributeName = null;\n  let attribute = null;\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i];\n    attributeName = attribute.name;\n    attributeNamespaceURI = attribute.namespaceURI;\n    attributeValue = attribute.value;\n\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName;\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName);\n\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue);\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue);\n      } else {\n        fromValue = existingNode.getAttribute(attributeName);\n\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName);\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue);\n          }\n        }\n      }\n    }\n  } // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n\n\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j];\n\n    if (attribute.specified !== false) {\n      attributeName = attribute.name;\n      attributeNamespaceURI = attribute.namespaceURI;\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName;\n\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName);\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n};\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\n\nexport const removeAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className);\n      }\n\n      continue;\n    } // Check if optional values match.\n\n\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue;\n    } // Remove attribute.\n\n\n    element.removeAttribute(name);\n  }\n};\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\n\nexport const setAttribute = (element, key, data) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = '';\n    } // Exit early if nothing will change.\n\n\n    if (element.getAttribute(key) === data) {\n      return;\n    } // Update attribute.\n\n\n    element.setAttribute(key, data); // Exit special cases early.\n\n    return;\n  } // If checked attribute then set the checked property instead.\n\n\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data;\n      return;\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ');\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';');\n    }\n  } // Update attribute on element.\n\n\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key);\n  } else {\n    element.setAttribute(key, data);\n  }\n};\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\n\nexport const setAttributes = (element, data) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name]);\n  }\n};\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute\n};", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = string => {\n  const template = document.createElement('template');\n  template.innerHTML = string;\n  return template.content.childNodes[0];\n};\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\n\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling);\n  } else {\n    reference.parentNode.appendChild(node);\n  }\n};\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\n\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b);\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false;\n  }\n\n  if (a.type === 3) {\n    // Text node.\n    return a.nodeValue === b.nodeValue;\n  }\n\n  return false;\n};\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\n\nexport const walk = (element, filter) => {\n  let index = -1;\n  let iterator = null;\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator();\n\n      if (child) {\n        return child;\n      }\n    } // Get next child that passes the filter.\n\n\n    let child = null;\n\n    do {\n      index++;\n\n      if (index >= element.childElementCount) {\n        return null;\n      }\n\n      child = element.children[index];\n    } while (!filter(child)); // Setup iterator for child.\n\n\n    if (child.childElementCount) {\n      iterator = walk(child, filter);\n    } // Return the child.\n\n\n    return child;\n  };\n};\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk\n};", "// Based on choo's nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme).\n// Import utilities.\nimport { copyAttributes } from './Attribute.js';\nimport { fromString as ElementFromString, isSame as ElementIsSame } from './Element.js';\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\n\nexport const morphNode = (existingNode, newNode) => {\n  const nodeType = newNode.nodeType;\n  const nodeName = newNode.nodeName; // Element node.\n\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode);\n  } // Text node or comment node.\n\n\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue;\n    }\n  } // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n\n\n  if (nodeName === 'INPUT') {\n    updateInput(existingNode, newNode);\n  } else if (nodeName === 'OPTION') {\n    updateAttribute(existingNode, newNode, 'selected');\n  } else if (nodeName === 'TEXTAREA') {\n    updateTextarea(existingNode, newNode);\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\n\nexport const morphTree = (existingTree, newTree, options) => {\n  if (typeof existingTree !== 'object') {\n    throw new Error('Existing tree should be an object.');\n  }\n\n  if (typeof newTree === 'string') {\n    newTree = ElementFromString(newTree);\n  } else if (typeof newTree !== 'object') {\n    throw new Error('New tree should be an object.');\n  } // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n\n\n  if (options && options.childrenOnly || newTree.nodeType === 11) {\n    updateChildren(existingTree, newTree);\n    return existingTree;\n  }\n\n  return updateTree(existingTree, newTree);\n};\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\nconst updateInput = (existingNode, newNode) => {\n  // The \"value\" attribute is special for the <input> element since it sets the\n  // initial value. Changing the \"value\" attribute without changing the \"value\"\n  // property will have no effect since it is only used to the set the initial\n  // value. Similar for the \"checked\" attribute, and \"disabled\".\n  const newValue = newNode.value;\n  const existingValue = existingNode.value;\n  updateAttribute(existingNode, newNode, 'checked');\n  updateAttribute(existingNode, newNode, 'disabled'); // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate;\n  } // Persist file value since file inputs can't be changed programmatically\n\n\n  if (existingNode.type === 'file') {\n    return;\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue);\n    existingNode.value = newValue;\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = '';\n    existingNode.removeAttribute('value');\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value');\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue;\n  }\n};\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateTextarea = (existingNode, newNode) => {\n  const newValue = newNode.value;\n\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue;\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and visa versa. This ignores an empty update.\n    if (existingNode.firstChild.nodeValue === existingNode.placeholder && newValue === '') {\n      return;\n    }\n\n    existingNode.firstChild.nodeValue = newValue;\n  }\n};\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateAttribute = (existingNode, newNode, name) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name];\n\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '');\n    } else {\n      existingNode.removeAttribute(name);\n    }\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\n\n\nconst updateTree = (existingTree, newTree) => {\n  if (!existingTree) {\n    return newTree;\n  }\n\n  if (!newTree) {\n    return null;\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree;\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree;\n  }\n\n  morphNode(existingTree, newTree);\n  updateChildren(existingTree, newTree);\n  return existingTree;\n};\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\n\n\nconst updateChildren = (existingNode, newNode) => {\n  let existingChild, newChild, morphed, existingMatch; // The offset is only ever increased, and used for [i - offset] in the loop\n\n  let offset = 0;\n\n  for (let i = 0;; i++) {\n    existingChild = existingNode.childNodes[i];\n    newChild = newNode.childNodes[i - offset]; // Both nodes are empty, do nothing\n\n    if (!existingChild && !newChild) {\n      break; // There is no new child, remove old\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild);\n      i--; // There is no old child, add new\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild);\n      offset++; // Both nodes are the same, morph\n    } else if (ElementIsSame(existingChild, newChild)) {\n      morphed = updateTree(existingChild, newChild);\n\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild);\n        offset++;\n      } // Both nodes do not share an ID or a placeholder, try reorder\n\n    } else {\n      existingMatch = null; // Try and find a similar node somewhere in the tree\n\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (ElementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j];\n          break;\n        }\n      } // If there was a node with the same ID or placeholder in the old list\n\n\n      if (existingMatch) {\n        morphed = updateTree(existingMatch, newChild);\n        if (morphed !== existingMatch) offset++;\n        existingNode.insertBefore(morphed, existingChild); // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = updateTree(existingChild, newChild);\n\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild);\n          offset++;\n        } // Insert the node at the index if we couldn't morph or find a matching node\n\n      } else {\n        existingNode.insertBefore(newChild, existingChild);\n        offset++;\n      }\n    }\n  }\n};\n\nexport default {\n  morphNode,\n  morphTree\n};", "import { morphTree } from '@doars/common/src/utilities/Morph.js';\nexport default {\n  name: '$morph',\n  create: () => {\n    return {\n      value: morphTree\n    };\n  }\n};", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"'\n};\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;'\n};\nconst ENCODE_REGEXP = /[&<>'\"]/g;\nexport const decode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(DECODE_REGEXP, character => {\n    return DECODE_LOOKUP[character];\n  });\n};\nexport const encode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, character => {\n    return ENCODE_LOOKUP[character];\n  });\n};\nexport default {\n  decode,\n  encode\n};", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function\n/* A native object */\n).replace('Function', 'Promise') // Replace identifier.\n.replace(/\\(.*\\)/, '()'); // Remove possible FormalParameterList.\n\nexport const isNativePromise = value => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise;\n};\nexport const isPromise = value => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]';\n};\nexport default {\n  isPromise,\n  isNativePromise\n};", "// Import utilities.\nimport { decode } from '@doars/common/src/utilities/Html.js';\nimport { isPromise } from '@doars/common/src/utilities/Promise.js';\nimport { morphTree } from '@doars/common/src/utilities/Morph.js';\nexport default {\n  name: 'morph',\n  update: (component, attribute, {\n    processExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = html => {\n      // Decode string.\n      if (modifiers.decode && typeof html === 'string') {\n        html = decode(html);\n      } // Ensure element only has one child.\n\n\n      if (element.children.length === 0) {\n        element.appendChild(document.createElement('div'));\n      } else if (element.children.length > 1) {\n        for (let i = element.children.length - 1; i >= 1; i--) {\n          element.children[i].remove();\n        }\n      } // Morph first child to given element tree.\n\n\n      const root = morphTree(element.children[0], html);\n\n      if (!element.children[0].isSameNode(root)) {\n        element.children[0].remove();\n        element.appendChild(root);\n      }\n    }; // Execute value and retrieve result.\n\n\n    const result = processExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "// Import contexts and directive.\nimport contextMorph from './contexts/morph.js';\nimport directiveMorph from './directives/morph.js';\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n */\n\nexport default function (library) {\n  // Set private variables.\n  let isEnabled = false;\n\n  const onEnable = function () {\n    // Add contexts and directives.\n    library.addContexts(0, contextMorph);\n    library.addDirectives(-1, directiveMorph);\n  };\n\n  const onDisable = function () {\n    // Remove contexts and directives.\n    library.removeContexts(contextMorph);\n    library.removeDirectives(directiveMorph);\n  };\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false; // Stop listening to enable state of the library.\n\n      library.removeEventListener('enabling', onEnable);\n      library.removeEventListener('disabling', onDisable);\n    }\n  };\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true; // Listen to enable state of the library.\n\n      library.addEventListener('enabling', onEnable);\n      library.addEventListener('disabling', onDisable);\n    }\n  }; // Automatically enable plugin.\n\n\n  this.enable();\n}"],
  "mappings": "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",
  "names": ["copyAttributes", "existingNode", "newNode", "existingAttributes", "newAttributes", "attributeNamespaceURI", "attributeValue", "fromValue", "attributeName", "attribute", "i", "j", "fromString", "string", "template", "isSame", "a", "b", "morphNode", "existingNode", "newNode", "nodeType", "nodeName", "copyAttributes", "updateInput", "updateAttribute", "updateTextarea", "morphTree", "existingTree", "newTree", "options", "fromString", "updateChildren", "updateTree", "newValue", "existingValue", "name", "existingChild", "newChild", "morphed", "existingMatch", "offset", "i", "isSame", "j", "morph_default", "morphTree", "DECODE_LOOKUP", "DECODE_REGEXP", "decode", "string", "DECODE_REGEXP", "character", "DECODE_LOOKUP", "nativePromise", "isPromise", "value", "morph_default", "component", "attribute", "processExpression", "element", "modifiers", "set", "html", "decode", "i", "root", "morphTree", "result", "isPromise", "resultResolved", "DoarsMorph_default", "library", "isEnabled", "onEnable", "morph_default", "onDisable"]
}
