{
  "version": 3,
  "sources": ["../../common/src/utilities/Attribute.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Morph.js", "../src/contexts/morph.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/Promise.js", "../src/directives/morph.js", "../src/DoarsMorph.js"],
  "sourcesContent": ["/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const stringStart = string.substring(0, 15).toLowerCase()\n  const isDocument = (\n    stringStart.startsWith('<!doctype html>') ||\n    stringStart.startsWith('<html>')\n  )\n  if (isDocument) {\n    const html = document.createElement('html')\n    html.innerHTML = string\n    return html\n  }\n\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (\n  reference,\n  node,\n) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (a.isSameNode && a.isSameNode(b)) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  element,\n  filter,\n) => {\n  let index = -1\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame,\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement | string} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the initial value. Changing the \"value\" attribute without changing the \"value\" property will have no effect since it is only used to the set the initial value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop.\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing.\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old.\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new.\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild)\n      offset++\n\n      // Both nodes are the same, morph.\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder.\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree.\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list.\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID.\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node.\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n", "import { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nexport default {\n  name: '$morph',\n\n  create: (\n  ) => {\n    return {\n      value: morphTree,\n    }\n  },\n}\n", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (\n  value,\n) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (\n  value,\n) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n", "// Import utilities.\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nexport default {\n  name: 'morph',\n\n  update: (\n    component,\n    attribute, {\n      processExpression,\n    },\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    const set = (\n      html,\n    ) => {\n      // Decode string.\n      if (modifiers.decode && typeof (html) === 'string') {\n        html = decode(html)\n      }\n\n      if (modifiers.outer) {\n        // Morph the element as well.\n        morphTree(element, html)\n      } else {\n        // Ensure element only has one child.\n        if (element.children.length === 0) {\n          element.appendChild(document.createElement('div'))\n        } else if (element.children.length > 1) {\n          for (let i = element.children.length - 1; i >= 1; i--) {\n            element.children[i].remove()\n          }\n        }\n\n        // Morph first child to given element tree.\n        const root = morphTree(element.children[0], html)\n        if (!element.children[0].isSameNode(root)) {\n          element.children[0].remove()\n          element.appendChild(root)\n        }\n      }\n    }\n\n    // Execute value and retrieve result.\n    const result = processExpression(\n      component,\n      attribute,\n      attribute.getValue(),\n    )\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((\n          resultResolved,\n        ) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n}\n", "// Import contexts and directive.\nimport contextMorph from './contexts/morph.js'\nimport directiveMorph from './directives/morph.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n */\nexport default function (\n  library,\n) {\n  // Set private variables.\n  let isEnabled = false\n\n  const onEnable = (\n  ) => {\n    // Add contexts and directives.\n    library.addContexts(0, contextMorph)\n    library.addDirectives(-1, directiveMorph)\n  }\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(contextMorph)\n    library.removeDirectives(directiveMorph)\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"],
  "mappings": "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",
  "names": ["morph_default", "morph_default"]
}
