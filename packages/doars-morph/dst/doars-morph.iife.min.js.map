{
  "version": 3,
  "sources": ["../../common/src/utilities/Attribute.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Morph.js", "../src/contexts/morph.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/Promise.js", "../src/directives/morph.js", "../src/DoarsMorph.js", "../src/DoarsMorph.iife.js"],
  "sourcesContent": ["/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (\n  reference,\n  node,\n) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (a.isSameNode && a.isSameNode(b)) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  element,\n  filter,\n) => {\n  let index = -1\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the\n  // initial value. Changing the \"value\" attribute without changing the \"value\"\n  // property will have no effect since it is only used to the set the initial\n  // value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild)\n      offset++\n\n      // Both nodes are the same, morph\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n", "import { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nexport default {\n  name: '$morph',\n\n  create: () => {\n    return {\n      value: morphTree,\n    }\n  },\n}\n", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (string) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (string) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (value) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (value) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n", "// Import utilities.\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nexport default {\n  name: 'morph',\n\n  update: (component, attribute, { processExpression }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    const set = (html) => {\n      // Decode string.\n      if (modifiers.decode && typeof (html) === 'string') {\n        html = decode(html)\n      }\n\n      // Ensure element only has one child.\n      if (element.children.length === 0) {\n        element.appendChild(document.createElement('div'))\n      } else if (element.children.length > 1) {\n        for (let i = element.children.length - 1; i >= 1; i--) {\n          element.children[i].remove()\n        }\n      }\n\n      // Morph first child to given element tree.\n      const root = morphTree(element.children[0], html)\n      if (!element.children[0].isSameNode(root)) {\n        element.children[0].remove()\n        element.appendChild(root)\n      }\n    }\n\n    // Execute value and retrieve result.\n    const result = processExpression(component, attribute, attribute.getValue())\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((resultResolved) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n}\n", "// Import contexts and directive.\nimport contextMorph from './contexts/morph.js'\nimport directiveMorph from './directives/morph.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n */\nexport default function (\n  library\n) {\n  // Set private variables.\n  let isEnabled = false\n\n  const onEnable = function () {\n    // Add contexts and directives.\n    library.addContexts(0, contextMorph)\n    library.addDirectives(-1, directiveMorph)\n  }\n  const onDisable = function () {\n    // Remove contexts and directives.\n    library.removeContexts(contextMorph)\n    library.removeDirectives(directiveMorph)\n  }\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n", "import DoarsMorph from './DoarsMorph.js'\n\nwindow.DoarsMorph = DoarsMorph\n"],
  "mappings": "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",
  "names": ["copyAttributes", "existingNode", "newNode", "existingAttributes", "newAttributes", "attributeNamespaceURI", "attributeValue", "fromValue", "attributeName", "attribute", "i", "j", "fromString", "string", "template", "isSame", "a", "b", "morphNode", "existingNode", "newNode", "nodeType", "nodeName", "copyAttributes", "_updateInput", "_updateAttribute", "_updateTextarea", "morphTree", "existingTree", "newTree", "options", "fromString", "_updateChildren", "_updateTree", "newValue", "existingValue", "name", "existingChild", "newChild", "morphed", "existingMatch", "offset", "i", "isSame", "j", "morph_default", "morphTree", "DECODE_LOOKUP", "DECODE_REGEXP", "decode", "string", "DECODE_REGEXP", "character", "DECODE_LOOKUP", "nativePromise", "isPromise", "value", "morph_default", "component", "attribute", "processExpression", "element", "modifiers", "set", "html", "decode", "i", "root", "morphTree", "result", "isPromise", "resultResolved", "DoarsMorph_default", "library", "isEnabled", "onEnable", "morph_default", "onDisable", "DoarsMorph_default"]
}
