{
  "version": 3,
  "sources": ["../../common/src/utilities/Attribute.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Morph.js", "../src/contexts/morph.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/Promise.js", "../src/directives/morph.js", "../src/DoarsMorph.js", "../src/DoarsMorph.iife.js"],
  "sourcesContent": ["/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (existingNode, newNode) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\nexport const removeAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\nexport const setAttribute = (element, key, data) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\nexport const setAttributes = (element, data) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (string) => {\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b)\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  return false\n}\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (element, filter) => {\n  let index = -1\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "// Based on choo's nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme).\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as ElementFromString,\n  isSame as ElementIsSame\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\nexport const morphNode = (existingNode, newNode) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (existingTree, newTree, options) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = ElementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst updateInput = (existingNode, newNode) => {\n  // The \"value\" attribute is special for the <input> element since it sets the\n  // initial value. Changing the \"value\" attribute without changing the \"value\"\n  // property will have no effect since it is only used to the set the initial\n  // value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  updateAttribute(existingNode, newNode, 'checked')\n  updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can't be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst updateTextarea = (existingNode, newNode) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and visa versa. This ignores an empty update.\n    if (existingNode.firstChild.nodeValue === existingNode.placeholder && newValue === '') {\n      return\n    }\n\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst updateAttribute = (existingNode, newNode, name) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst updateTree = (existingTree, newTree) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst updateChildren = (existingNode, newNode) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild)\n      offset++\n\n      // Both nodes are the same, morph\n    } else if (ElementIsSame(existingChild, newChild)) {\n      morphed = updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (ElementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list\n      if (existingMatch) {\n        morphed = updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) offset++\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we couldn't morph or find a matching node\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n", "import { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nexport default {\n  name: '$morph',\n\n  create: () => {\n    return {\n      value: morphTree,\n    }\n  },\n}\n", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (string) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (string) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (value) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (value) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n", "// Import utilities.\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nexport default {\n  name: 'morph',\n\n  update: (component, attribute, { processExpression }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n\n    const set = (html) => {\n      // Decode string.\n      if (modifiers.decode && typeof (html) === 'string') {\n        html = decode(html)\n      }\n\n      // Ensure element only has one child.\n      if (element.children.length === 0) {\n        element.appendChild(document.createElement('div'))\n      } else if (element.children.length > 1) {\n        for (let i = element.children.length - 1; i >= 1; i--) {\n          element.children[i].remove()\n        }\n      }\n\n      // Morph first child to given element tree.\n      const root = morphTree(element.children[0], html)\n      if (!element.children[0].isSameNode(root)) {\n        element.children[0].remove()\n        element.appendChild(root)\n      }\n    }\n\n    // Execute value and retrieve result.\n    const result = processExpression(component, attribute, attribute.getValue())\n\n    // Store results.\n    attribute.setData(result)\n\n    // Handle promises.\n    if (isPromise(result)) {\n      Promise.resolve(result)\n        .then((resultResolved) => {\n          // If stored data has changed then this promise should be ignored.\n          if (attribute.getData() !== result) {\n            return\n          }\n\n          set(resultResolved)\n        })\n    } else {\n      set(result)\n    }\n  },\n}\n", "// Import contexts and directive.\nimport contextMorph from './contexts/morph.js'\nimport directiveMorph from './directives/morph.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n */\nexport default function (\n  library\n) {\n  // Set private variables.\n  let isEnabled = false\n\n  const onEnable = function () {\n    // Add contexts and directives.\n    library.addContexts(0, contextMorph)\n    library.addDirectives(-1, directiveMorph)\n  }\n  const onDisable = function () {\n    // Remove contexts and directives.\n    library.removeContexts(contextMorph)\n    library.removeDirectives(directiveMorph)\n  }\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n", "import DoarsMorph from './DoarsMorph.js'\n\nwindow.DoarsMorph = DoarsMorph\n"],
  "mappings": "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",
  "names": ["morph_default", "morph_default"]
}
