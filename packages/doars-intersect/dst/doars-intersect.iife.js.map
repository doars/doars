{
  "version": 3,
  "sources": ["../src/directives/intersect.js", "../../common/src/polyfills/IntersectionDispatcher.js", "../src/DoarsIntersect.js", "../src/DoarsIntersect.iife.js"],
  "sourcesContent": [
    "const INTERSECT = Symbol('INTERSECT')\n// Declare constants.\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 5,\n  DELAY: 6,\n}\n\nexport default ({\n  intersectDirectiveName,\n}, intersectionDispatcher,\n) => ({\n  name: intersectDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const key = attribute.getKey()\n    const value = attribute.getValue()\n\n    // Check if existing handler exists.\n    if (attribute[INTERSECT]) {\n      // Exit early if value has not changed.\n      if (attribute[INTERSECT].value === value) {\n        return\n      }\n\n      // Stop observing the element.\n      intersectionDispatcher.remove(element, attribute[INTERSECT].handler)\n      // Clear any ongoing timeouts.\n      if (attribute[INTERSECT].timeout) {\n        clearTimeout(attribute[INTERSECT].timeout)\n      }\n      // Delete directive data.\n      delete attribute[INTERSECT]\n    }\n\n    // Deconstruct attribute.\n    const modifiers = attribute.getModifiers()\n\n    // Process execution modifiers.\n    let executionModifier = EXECUTION_MODIFIERS.NONE\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500\n      }\n    } else if (modifiers.delay) {\n      executionModifier = EXECUTION_MODIFIERS.DELAY\n      if (modifiers.delay === true) {\n        modifiers.delay = 500\n      }\n    }\n\n    // Create intersection handler.\n    const handler = (\n      event,\n    ) => {\n      // Check if intersection has changed.\n      const isChanged = attribute[INTERSECT].isIntersecting !== event.isIntersecting\n      if (!isChanged) {\n        return\n      }\n\n      // Update state in attribute data.\n      attribute[INTERSECT].isIntersecting = event.isIntersecting\n\n      // Exit early if expression should not be executed.\n      if ((key === 'enter' && !event.isIntersecting) || (key === 'leave' && event.isIntersecting)) {\n        // Clear existing timeout.\n        if (attribute[INTERSECT].timeout) {\n          clearTimeout(attribute[INTERSECT].timeout)\n          attribute[INTERSECT].timeout = null\n        }\n        return\n      }\n\n      const execute = (\n      ) => {\n        // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n        processExpression(\n          component,\n          attribute.clone(),\n          value,\n          { $event: event },\n          { return: false },\n        )\n\n        // Reset the buffer.\n        attribute[INTERSECT].buffer = []\n      }\n\n      // Store event in buffer.\n      attribute[INTERSECT].buffer.push(event)\n\n      // Check if we need to apply an execution modifier.\n      if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n        // Exit early if buffer is not full.\n        if (attribute[INTERSECT].buffer.length < modifiers.buffer) {\n          return\n        }\n\n        execute()\n      } else if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n        // Clear existing timeout.\n        if (attribute[INTERSECT].timeout) {\n          clearTimeout(attribute[INTERSECT].timeout)\n          attribute[INTERSECT].timeout = null\n        }\n\n        // Setup timeout and execute expression when it finishes.\n        attribute[INTERSECT].timeout = setTimeout(execute, modifiers.debounce)\n      } else if (executionModifier === EXECUTION_MODIFIERS.THROTTLE) {\n        // Get current time in milliseconds.\n        const now = window.performance.now()\n\n        // Exit early if throttle time has not passed.\n        if (attribute[INTERSECT].lastExecution && now - attribute[INTERSECT].lastExecution < modifiers.throttle) {\n          return\n        }\n\n        execute()\n\n        // Store new latest execution time.\n        attribute[INTERSECT].lastExecution = now\n      } else if (EXECUTION_MODIFIERS.DELAY) {\n        // Setup timeout and execute expression when it finishes.\n        attribute[INTERSECT].timeout = setTimeout(execute, modifiers.delay)\n      } else {\n        // Execute expression.\n        execute()\n      }\n    }\n\n    // Start observing the element.\n    intersectionDispatcher.add(element, handler)\n\n    // Store handler.\n    attribute[INTERSECT] = {\n      buffer: [],\n      handler,\n      isIntersecting: false,\n      timeout: attribute[INTERSECT] ? attribute[INTERSECT].timeout : null,\n      value,\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Check if a handler exists.\n    if (!attribute[INTERSECT]) {\n      return\n    }\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Stop observing the element.\n    intersectionDispatcher.remove(element, attribute[INTERSECT].handler)\n    // Clear any ongoing timeouts.\n    if (attribute[INTERSECT].timeout) {\n      clearTimeout(attribute[INTERSECT].timeout)\n    }\n    // Delete directive data.\n    delete attribute[INTERSECT]\n  },\n})\n",
    "export default class IntersectionDispatcher {\n  /**\n   * Create observer instance.\n   * @param {object} options Intersection observer options.\n   */\n  constructor(\n    options = null,\n  ) {\n    // Store data per element.\n    const items = new WeakMap()\n\n    /**\n     * Intersection observer handler.\n     * @param {Array<IntersectionObserverEntry>} entries Intersection observer entries.\n     */\n    const intersect = (\n      entries,\n    ) => {\n      // Invoke callbacks of each entry.\n      for (const entry of entries) {\n        for (const callback of items.get(entry.target)) {\n          callback(entry)\n        }\n      }\n    }\n\n    // Create intersection observer.\n    const observer = new window.IntersectionObserver(intersect, options)\n\n    /**\n     * Add element to observe.\n     * @param {HTMLElement} element Element to observer.\n     * @param {Function} callback Callback to call on intersection change.\n     */\n    this.add = (\n      element,\n      callback,\n    ) => {\n      // Add callback to list.\n      if (!items.has(element)) {\n        items.set(element, [])\n      }\n      items.get(element).push(callback)\n\n      // Start observing element.\n      observer.observe(element)\n    }\n\n    /**\n     * Remove element from observing.\n     * @param {HTMLElement} element Element that is observed.\n     * @param {Function} callback Callback that is called on intersection change.\n     */\n    this.remove = (\n      element,\n      callback,\n    ) => {\n      // Remove callback from list.\n      if (!items.has(element)) {\n        return\n      }\n      const list = items.get(element)\n      const index = list.indexOf(callback)\n      if (index >= 0) {\n        list.splice(index, 1)\n      }\n\n      // Check if there are no more callbacks.\n      if (list.length === 0) {\n        // Remove element from callbacks list.\n        items.delete(element)\n\n        // Stop observing element.\n        observer.unobserve(element)\n      }\n    }\n  }\n}\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport createIntersectDirective from './directives/intersect.js'\nimport IntersectionDispatcher from '@doars/common/src/polyfills/IntersectionDispatcher.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    intersectDirectiveName: 'intersect',\n\n    intersectionRoot: null,\n    intersectionMargin: '0px',\n    intersectionThreshold: 0,\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n\n  // Setup observer.\n  const intersectionDispatcher = new IntersectionDispatcher({\n    root: options.intersectionRoot\n      ? options.intersectionRoot\n      : library.getOptions().root,\n    rootMargin: options.intersectionMargin,\n    threshold: options.intersectionThreshold,\n  })\n\n  // Create directive.\n  const intersectionDirective = createIntersectDirective(\n    options,\n    intersectionDispatcher,\n  )\n\n  const onEnable = (\n  ) => {\n    // Add directive.\n    library.addDirectives(-1, intersectionDirective)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove directive.\n    library.removeDirectives(intersectionDirective)\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n",
    "import DoarsIntersect from './DoarsIntersect.js'\n\nwindow.DoarsIntersect = DoarsIntersect\n"
  ],
  "mappings": "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",
  "debugId": "D9EF40940F3BCE5264756E2164756E21",
  "names": []
}