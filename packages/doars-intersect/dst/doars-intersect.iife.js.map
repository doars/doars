{
  "version": 3,
  "sources": ["../src/symbols.js", "../src/factories/directives/intersect.js", "../src/IntersectionObserver.js", "../src/DoarsIntersect.js", "../src/DoarsIntersect.iife.js"],
  "sourcesContent": ["export const INTERSECT = Symbol('VIEW')\n", "// Import symbols.\nimport { INTERSECT } from '../../symbols.js'\n\n// Declare constants.\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 3,\n}\n\nexport default (observer) => ({\n  name: 'intersect',\n\n  update: (component, attribute, { processExpression }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const key = attribute.getKey()\n    const value = attribute.getValue()\n\n    // Check if existing handler exists.\n    if (attribute[INTERSECT]) {\n      // Exit early if value has not changed.\n      if (attribute[INTERSECT].value === value) {\n        return\n      }\n\n      // Stop observing the element.\n      observer.remove(element, attribute[INTERSECT].handler)\n      // Clear any ongoing timeouts.\n      if (attribute[INTERSECT].timeout) {\n        clearTimeout(attribute[INTERSECT].timeout)\n      }\n      // Delete directive data.\n      delete attribute[INTERSECT]\n    }\n\n    // Deconstruct attribute.\n    const modifiers = attribute.getModifiers()\n\n    // Process execution modifiers.\n    let executionModifier = EXECUTION_MODIFIERS.NONE\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500\n      }\n    }\n\n    // Create intersection handler.\n    const handler = (event) => {\n      // Check if intersection has changed.\n      const isChanged = attribute[INTERSECT].isIntersecting !== event.isIntersecting\n      if (!isChanged) {\n        return\n      }\n\n      // Update state in attribute data.\n      attribute[INTERSECT].isIntersecting = event.isIntersecting\n\n      // Exit early if expression should not be executed.\n      if ((key === 'enter' && !event.isIntersecting) || (key === 'leave' && event.isIntersecting)) {\n        // Clear existing timeout.\n        if (attribute[INTERSECT].timeout) {\n          clearTimeout(attribute[INTERSECT].timeout)\n          attribute[INTERSECT].timeout = null\n        }\n        return\n      }\n\n      const execute = () => {\n        // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n        processExpression(component, attribute.clone(), value, {\n          $event: event,\n        }, { return: false })\n\n        // Reset the buffer.\n        attribute[INTERSECT].buffer = []\n      }\n\n      // Store event in buffer.\n      attribute[INTERSECT].buffer.push(event)\n\n      // Check if we need to apply an execution modifier.\n      if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n        // Exit early if buffer is not full.\n        if (attribute[INTERSECT].buffer.length < modifiers.buffer) {\n          return\n        }\n\n        execute()\n      } else if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n        // Clear existing timeout.\n        if (attribute[INTERSECT].timeout) {\n          clearTimeout(attribute[INTERSECT].timeout)\n          attribute[INTERSECT].timeout = null\n        }\n\n        // Setup timeout and execute expression when it finishes.\n        attribute[INTERSECT].timeout = setTimeout(execute, modifiers.debounce)\n      } else if (executionModifier === EXECUTION_MODIFIERS.THROTTLE) {\n        // Get current time in milliseconds.\n        const now = window.performance.now()\n\n        // Exit early if throttle time has not passed.\n        if (attribute[INTERSECT].lastExecution && now - attribute[INTERSECT].lastExecution < modifiers.throttle) {\n          return\n        }\n\n        execute()\n\n        // Store new latest execution time.\n        attribute[INTERSECT].lastExecution = now\n      } else {\n        // Execute expression.\n        execute()\n      }\n    }\n\n    // Start observing the element.\n    observer.add(element, handler)\n\n    // Store handler.\n    attribute[INTERSECT] = {\n      buffer: [],\n      handler,\n      isIntersecting: false,\n      timeout: attribute[INTERSECT] ? attribute[INTERSECT].timeout : null,\n      value,\n    }\n  },\n\n  destroy: (component, attribute) => {\n    // Check if a handler exists.\n    if (!attribute[INTERSECT]) {\n      return\n    }\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Stop observing the element.\n    observer.remove(element, attribute[INTERSECT].handler)\n    // Clear any ongoing timeouts.\n    if (attribute[INTERSECT].timeout) {\n      clearTimeout(attribute[INTERSECT].timeout)\n    }\n    // Delete directive data.\n    delete attribute[INTERSECT]\n  },\n})\n", "export default class IntersectionObserver {\n  /**\n   * Create observer instance.\n   * @param {Object} options Intersection observer options.\n   */\n  constructor(options = null) {\n    // Overwrite default options.\n    options = Object.assign({\n      root: null,\n      rootMargin: '0px',\n      threshold: 0,\n    }, options)\n\n    // Store data per element.\n    const items = new WeakMap()\n\n    /**\n     * Intersection observer handler.\n     * @param {Array<IntersectionObserverEntry>} entries Intersection observer entries.\n     */\n    const intersect = (entries) => {\n      // Invoke callbacks of each entry.\n      for (const entry of entries) {\n        for (const callback of items.get(entry.target)) {\n          callback(entry)\n        }\n      }\n    }\n\n    // Create intersection observer.\n    const intersectionObserver = new IntersectionObserver(intersect, options)\n\n    /**\n     * Add element to observe.\n     * @param {HTMLElement} element Element to observer.\n     * @param {Function} callback Callback to call on intersection change.\n     */\n    this.add = (element, callback) => {\n      // Add callback to list.\n      if (!items.has(element)) {\n        items.set(element, [])\n      }\n      items.get(element).push(callback)\n\n      // Start observing element.\n      intersectionObserver.observe(element)\n    }\n\n    /**\n     * Remove element from observing.\n     * @param {HTMLElement} element Element that is observed.\n     * @param {Function} callback Callback that is called on intersection change.\n     */\n    this.remove = (element, callback) => {\n      // Remove callback from list.\n      if (!items.has(element)) {\n        return\n      }\n      const list = items.get(element)\n      const index = list.indexOf(callback)\n      if (index >= 0) {\n        list.splice(index, 1)\n      }\n\n      // Check if there are no more callbacks.\n      if (list.length === 0) {\n        // Remove element from callbacks list.\n        items.delete(element)\n\n        // Stop observing element.\n        intersectionObserver.unobserve(element)\n      }\n    }\n  }\n}\n", "// Import directives.\nimport createDirectiveIntersect from './factories/directives/intersect.js'\n\n// Import observer.\nimport IntersectionObserver from './IntersectionObserver.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null\n) {\n  // Clone options.\n  options = Object.assign({}, options)\n\n  // Set private variables.\n  let isEnabled = false\n  let directiveView, intersectionObserver\n\n  const onEnable = function () {\n    // Overwrite default options.\n    const _options = Object.assign({}, options)\n    if (!_options.root) {\n      _options.root = library.getOptions().root\n    }\n\n    // Setup observer.\n    intersectionObserver = new IntersectionObserver(options)\n\n    // Create and add directive.\n    directiveView = createDirectiveIntersect(intersectionObserver)\n    library.addDirectives(-1, directiveView)\n  }\n  const onDisable = function () {\n    // Remove directive.\n    library.removeDirectives(directiveView)\n    directiveView = null\n\n    // Remove observer.\n    intersectionObserver = null\n  }\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n", "import DoarsIntersect from './DoarsIntersect.js'\n\nwindow.DoarsIntersect = DoarsIntersect\n"],
  "mappings": "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",
  "names": []
}
