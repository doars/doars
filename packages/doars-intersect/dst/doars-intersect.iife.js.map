{
  "version": 3,
  "sources": ["../src/symbols.js", "../src/factories/directives/intersect.js", "../src/IntersectionObserver.js", "../src/DoarsIntersect.js", "../src/DoarsIntersect.iife.js"],
  "sourcesContent": ["export const INTERSECT = Symbol('VIEW');", "// Import symbols.\nimport { INTERSECT } from '../../symbols.js'; // Declare constants.\n\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 3\n};\nexport default (observer => {\n  return {\n    name: 'intersect',\n    update: (component, attribute, {\n      processExpression\n    }) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement();\n      const key = attribute.getKey();\n      const value = attribute.getValue(); // Check if existing handler exists.\n\n      if (attribute[INTERSECT]) {\n        // Exit early if value has not changed.\n        if (attribute[INTERSECT].value === value) {\n          return;\n        } // Stop observing the element.\n\n\n        observer.remove(element, attribute[INTERSECT].handler); // Clear any ongoing timeouts.\n\n        if (attribute[INTERSECT].timeout) {\n          clearTimeout(attribute[INTERSECT].timeout);\n        } // Delete directive data.\n\n\n        delete attribute[INTERSECT];\n      } // Deconstruct attribute.\n\n\n      const modifiers = attribute.getModifiers(); // Process execution modifiers.\n\n      let executionModifier = EXECUTION_MODIFIERS.NONE;\n\n      if (modifiers.buffer) {\n        executionModifier = EXECUTION_MODIFIERS.BUFFER;\n\n        if (modifiers.buffer === true) {\n          modifiers.buffer = 5;\n        }\n      } else if (modifiers.debounce) {\n        executionModifier = EXECUTION_MODIFIERS.DEBOUNCE;\n\n        if (modifiers.debounce === true) {\n          modifiers.debounce = 500;\n        }\n      } else if (modifiers.throttle) {\n        executionModifier = EXECUTION_MODIFIERS.THROTTLE;\n\n        if (modifiers.throttle === true) {\n          modifiers.throttle = 500;\n        }\n      } // Create intersection handler.\n\n\n      const handler = event => {\n        // Check if intersection has changed.\n        const isChanged = attribute[INTERSECT].isIntersecting !== event.isIntersecting;\n\n        if (!isChanged) {\n          return;\n        } // Update state in attribute data.\n\n\n        attribute[INTERSECT].isIntersecting = event.isIntersecting; // Exit early if expression should not be executed.\n\n        if (key === 'enter' && !event.isIntersecting || key === 'leave' && event.isIntersecting) {\n          // Clear existing timeout.\n          if (attribute[INTERSECT].timeout) {\n            clearTimeout(attribute[INTERSECT].timeout);\n            attribute[INTERSECT].timeout = null;\n          }\n\n          return;\n        }\n\n        const execute = () => {\n          // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n          processExpression(component, attribute.clone(), value, {\n            $event: event\n          }, {\n            return: false\n          }); // Reset the buffer.\n\n          attribute[INTERSECT].buffer = [];\n        }; // Store event in buffer.\n\n\n        attribute[INTERSECT].buffer.push(event); // Check if we need to apply an execution modifier.\n\n        if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n          // Exit early if buffer is not full.\n          if (attribute[INTERSECT].buffer.length < modifiers.buffer) {\n            return;\n          }\n\n          execute();\n        } else if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n          // Clear existing timeout.\n          if (attribute[INTERSECT].timeout) {\n            clearTimeout(attribute[INTERSECT].timeout);\n            attribute[INTERSECT].timeout = null;\n          } // Setup timeout and execute expression when it finishes.\n\n\n          attribute[INTERSECT].timeout = setTimeout(execute, modifiers.debounce);\n        } else if (executionModifier === EXECUTION_MODIFIERS.THROTTLE) {\n          // Get current time in milliseconds.\n          const now = window.performance.now(); // Exit early if throttle time has not passed.\n\n          if (attribute[INTERSECT].lastExecution && now - attribute[INTERSECT].lastExecution < modifiers.throttle) {\n            return;\n          }\n\n          execute(); // Store new latest execution time.\n\n          attribute[INTERSECT].lastExecution = now;\n        } else {\n          // Execute expression.\n          execute();\n        }\n      }; // Start observing the element.\n\n\n      observer.add(element, handler); // Store handler.\n\n      attribute[INTERSECT] = {\n        buffer: [],\n        handler: handler,\n        isIntersecting: false,\n        timeout: attribute[INTERSECT] ? attribute[INTERSECT].timeout : null,\n        value: value\n      };\n    },\n    destroy: (component, attribute) => {\n      // Check if a handler exists.\n      if (!attribute[INTERSECT]) {\n        return;\n      } // Deconstruct attribute.\n\n\n      const element = attribute.getElement(); // Stop observing the element.\n\n      observer.remove(element, attribute[INTERSECT].handler); // Clear any ongoing timeouts.\n\n      if (attribute[INTERSECT].timeout) {\n        clearTimeout(attribute[INTERSECT].timeout);\n      } // Delete directive data.\n\n\n      delete attribute[INTERSECT];\n    }\n  };\n});", "export default class IntersectionObserver {\n  /**\n   * Create observer instance.\n   * @param {Object} options Intersection observer options.\n   */\n  constructor(options = null) {\n    // Overwrite default options.\n    options = Object.assign({\n      root: null,\n      rootMargin: '0px',\n      threshold: 0\n    }, options); // Store data per element.\n\n    const items = new WeakMap();\n    /**\n     * Intersection observer handler.\n     * @param {Array<IntersectionObserverEntry>} entries Intersection observer entries.\n     */\n\n    const intersect = entries => {\n      // Invoke callbacks of each entry.\n      for (const entry of entries) {\n        for (const callback of items.get(entry.target)) {\n          callback(entry);\n        }\n      }\n    }; // Create intersection observer.\n\n\n    const intersectionObserver = new IntersectionObserver(intersect, options);\n    /**\n     * Add element to observe.\n     * @param {HTMLElement} element Element to observer.\n     * @param {Function} callback Callback to call on intersection change.\n     */\n\n    this.add = (element, callback) => {\n      // Add callback to list.\n      if (!items.has(element)) {\n        items.set(element, []);\n      }\n\n      items.get(element).push(callback); // Start observing element.\n\n      intersectionObserver.observe(element);\n    };\n    /**\n     * Remove element from observing.\n     * @param {HTMLElement} element Element that is observed.\n     * @param {Function} callback Callback that is called on intersection change.\n     */\n\n\n    this.remove = (element, callback) => {\n      // Remove callback from list.\n      if (!items.has(element)) {\n        return;\n      }\n\n      const list = items.get(element);\n      const index = list.indexOf(callback);\n\n      if (index >= 0) {\n        list.splice(index, 1);\n      } // Check if there are no more callbacks.\n\n\n      if (list.length === 0) {\n        // Remove element from callbacks list.\n        items.delete(element); // Stop observing element.\n\n        intersectionObserver.unobserve(element);\n      }\n    };\n  }\n\n}", "// Import directives.\nimport createDirectiveIntersect from './factories/directives/intersect.js'; // Import observer.\n\nimport IntersectionObserver from './IntersectionObserver.js';\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\n\nexport default function (library, options = null) {\n  // Clone options.\n  options = Object.assign({}, options); // Set private variables.\n\n  let isEnabled = false;\n  let directiveView, intersectionObserver;\n\n  const onEnable = function () {\n    // Overwrite default options.\n    const _options = Object.assign({}, options);\n\n    if (!_options.root) {\n      _options.root = library.getOptions().root;\n    } // Setup observer.\n\n\n    intersectionObserver = new IntersectionObserver(options); // Create and add directive.\n\n    directiveView = createDirectiveIntersect(intersectionObserver);\n    library.addDirectives(-1, directiveView);\n  };\n\n  const onDisable = function () {\n    // Remove directive.\n    library.removeDirectives(directiveView);\n    directiveView = null; // Remove observer.\n\n    intersectionObserver = null;\n  };\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false; // Stop listening to enable state of the library.\n\n      library.removeEventListener('enabling', onEnable);\n      library.removeEventListener('disabling', onDisable);\n    }\n  };\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true; // Listen to enable state of the library.\n\n      library.addEventListener('enabling', onEnable);\n      library.addEventListener('disabling', onDisable);\n    }\n  }; // Automatically enable plugin.\n\n\n  this.enable();\n}", "import DoarsIntersect from './DoarsIntersect.js';\nwindow.DoarsIntersect = DoarsIntersect;"],
  "mappings": "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",
  "names": []
}
