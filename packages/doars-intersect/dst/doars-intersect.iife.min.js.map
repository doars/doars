{
  "version": 3,
  "sources": ["../src/symbols.js", "../src/factories/directives/intersect.js", "../src/IntersectionObserver.js", "../src/DoarsIntersect.js", "../src/DoarsIntersect.iife.js"],
  "sourcesContent": ["export const INTERSECT = Symbol('VIEW')\n", "// Import symbols.\nimport { INTERSECT } from '../../symbols.js'\n\n// Declare constants.\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 3,\n}\n\nexport default (observer) => {\n  return {\n    name: 'intersect',\n\n    update: (component, attribute, { processExpression }) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement()\n      const key = attribute.getKey()\n      const value = attribute.getValue()\n\n      // Check if existing handler exists.\n      if (attribute[INTERSECT]) {\n        // Exit early if value has not changed.\n        if (attribute[INTERSECT].value === value) {\n          return\n        }\n\n        // Stop observing the element.\n        observer.remove(element, attribute[INTERSECT].handler)\n        // Clear any ongoing timeouts.\n        if (attribute[INTERSECT].timeout) {\n          clearTimeout(attribute[INTERSECT].timeout)\n        }\n        // Delete directive data.\n        delete attribute[INTERSECT]\n      }\n\n      // Deconstruct attribute.\n      const modifiers = attribute.getModifiers()\n\n      // Process execution modifiers.\n      let executionModifier = EXECUTION_MODIFIERS.NONE\n      if (modifiers.buffer) {\n        executionModifier = EXECUTION_MODIFIERS.BUFFER\n        if (modifiers.buffer === true) {\n          modifiers.buffer = 5\n        }\n      } else if (modifiers.debounce) {\n        executionModifier = EXECUTION_MODIFIERS.DEBOUNCE\n        if (modifiers.debounce === true) {\n          modifiers.debounce = 500\n        }\n      } else if (modifiers.throttle) {\n        executionModifier = EXECUTION_MODIFIERS.THROTTLE\n        if (modifiers.throttle === true) {\n          modifiers.throttle = 500\n        }\n      }\n\n      // Create intersection handler.\n      const handler = (event) => {\n        // Check if intersection has changed.\n        const isChanged = attribute[INTERSECT].isIntersecting !== event.isIntersecting\n        if (!isChanged) {\n          return\n        }\n\n        // Update state in attribute data.\n        attribute[INTERSECT].isIntersecting = event.isIntersecting\n\n        // Exit early if expression should not be executed.\n        if ((key === 'enter' && !event.isIntersecting) || (key === 'leave' && event.isIntersecting)) {\n          // Clear existing timeout.\n          if (attribute[INTERSECT].timeout) {\n            clearTimeout(attribute[INTERSECT].timeout)\n            attribute[INTERSECT].timeout = null\n          }\n          return\n        }\n\n        const execute = () => {\n          // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n          processExpression(component, attribute.clone(), value, {\n            $event: event,\n          }, { return: false })\n\n          // Reset the buffer.\n          attribute[INTERSECT].buffer = []\n        }\n\n        // Store event in buffer.\n        attribute[INTERSECT].buffer.push(event)\n\n        // Check if we need to apply an execution modifier.\n        if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n          // Exit early if buffer is not full.\n          if (attribute[INTERSECT].buffer.length < modifiers.buffer) {\n            return\n          }\n\n          execute()\n        } else if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n          // Clear existing timeout.\n          if (attribute[INTERSECT].timeout) {\n            clearTimeout(attribute[INTERSECT].timeout)\n            attribute[INTERSECT].timeout = null\n          }\n\n          // Setup timeout and execute expression when it finishes.\n          attribute[INTERSECT].timeout = setTimeout(execute, modifiers.debounce)\n        } else if (executionModifier === EXECUTION_MODIFIERS.THROTTLE) {\n          // Get current time in milliseconds.\n          const now = window.performance.now()\n\n          // Exit early if throttle time has not passed.\n          if (attribute[INTERSECT].lastExecution && now - attribute[INTERSECT].lastExecution < modifiers.throttle) {\n            return\n          }\n\n          execute()\n\n          // Store new latest execution time.\n          attribute[INTERSECT].lastExecution = now\n        } else {\n          // Execute expression.\n          execute()\n        }\n      }\n\n      // Start observing the element.\n      observer.add(element, handler)\n\n      // Store handler.\n      attribute[INTERSECT] = {\n        buffer: [],\n        handler,\n        isIntersecting: false,\n        timeout: attribute[INTERSECT] ? attribute[INTERSECT].timeout : null,\n        value,\n      }\n    },\n\n    destroy: (component, attribute) => {\n      // Check if a handler exists.\n      if (!attribute[INTERSECT]) {\n        return\n      }\n\n      // Deconstruct attribute.\n      const element = attribute.getElement()\n\n      // Stop observing the element.\n      observer.remove(element, attribute[INTERSECT].handler)\n      // Clear any ongoing timeouts.\n      if (attribute[INTERSECT].timeout) {\n        clearTimeout(attribute[INTERSECT].timeout)\n      }\n      // Delete directive data.\n      delete attribute[INTERSECT]\n    },\n  }\n}\n", "export default class IntersectionObserver {\n  /**\n   * Create observer instance.\n   * @param {Object} options Intersection observer options.\n   */\n  constructor(options = null) {\n    // Overwrite default options.\n    options = Object.assign({\n      root: null,\n      rootMargin: '0px',\n      threshold: 0,\n    }, options)\n\n    // Store data per element.\n    const items = new WeakMap()\n\n    /**\n     * Intersection observer handler.\n     * @param {Array<IntersectionObserverEntry>} entries Intersection observer entries.\n     */\n    const intersect = (entries) => {\n      // Invoke callbacks of each entry.\n      for (const entry of entries) {\n        for (const callback of items.get(entry.target)) {\n          callback(entry)\n        }\n      }\n    }\n\n    // Create intersection observer.\n    const intersectionObserver = new IntersectionObserver(intersect, options)\n\n    /**\n     * Add element to observe.\n     * @param {HTMLElement} element Element to observer.\n     * @param {Function} callback Callback to call on intersection change.\n     */\n    this.add = (element, callback) => {\n      // Add callback to list.\n      if (!items.has(element)) {\n        items.set(element, [])\n      }\n      items.get(element).push(callback)\n\n      // Start observing element.\n      intersectionObserver.observe(element)\n    }\n\n    /**\n     * Remove element from observing.\n     * @param {HTMLElement} element Element that is observed.\n     * @param {Function} callback Callback that is called on intersection change.\n     */\n    this.remove = (element, callback) => {\n      // Remove callback from list.\n      if (!items.has(element)) {\n        return\n      }\n      const list = items.get(element)\n      const index = list.indexOf(callback)\n      if (index >= 0) {\n        list.splice(index, 1)\n      }\n\n      // Check if there are no more callbacks.\n      if (list.length === 0) {\n        // Remove element from callbacks list.\n        items.delete(element)\n\n        // Stop observing element.\n        intersectionObserver.unobserve(element)\n      }\n    }\n  }\n}\n", "// Import directives.\nimport createDirectiveIntersect from './factories/directives/intersect.js'\n\n// Import observer.\nimport IntersectionObserver from './IntersectionObserver.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null\n) {\n  // Clone options.\n  options = Object.assign({}, options)\n\n  // Set private variables.\n  let isEnabled = false\n  let directiveView, intersectionObserver\n\n  const onEnable = function () {\n    // Overwrite default options.\n    const _options = Object.assign({}, options)\n    if (!_options.root) {\n      _options.root = library.getOptions().root\n    }\n\n    // Setup observer.\n    intersectionObserver = new IntersectionObserver(options)\n\n    // Create and add directive.\n    directiveView = createDirectiveIntersect(intersectionObserver)\n    library.addDirectives(-1, directiveView)\n  }\n  const onDisable = function () {\n    // Remove directive.\n    library.removeDirectives(directiveView)\n    directiveView = null\n\n    // Remove observer.\n    intersectionObserver = null\n  }\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n", "import DoarsIntersect from './DoarsIntersect.js'\n\nwindow.DoarsIntersect = DoarsIntersect\n"],
  "mappings": "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",
  "names": ["INTERSECT", "EXECUTION_MODIFIERS", "intersect_default", "observer", "component", "attribute", "processExpression", "element", "key", "value", "INTERSECT", "modifiers", "executionModifier", "handler", "event", "execute", "now", "IntersectionObserver", "_IntersectionObserver", "options", "items", "intersect", "entries", "entry", "callback", "intersectionObserver", "element", "list", "index", "DoarsIntersect_default", "library", "options", "isEnabled", "directiveView", "intersectionObserver", "onEnable", "_options", "IntersectionObserver", "intersect_default", "onDisable", "DoarsIntersect_default"]
}
