{
  "version": 3,
  "sources": ["../../common/src/utilities/Object.js", "../src/utilities/Fetch.js", "../src/factories/contexts/fetch.js", "../src/symbols.js", "../src/factories/directives/fetch.js", "../src/DoarsFetch.js", "../src/DoarsFetch.iife.js"],
  "sourcesContent": ["/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (target, ...sources) => {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepAssign(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map(value => {\n          if (isObject(value)) {\n            return deepAssign({}, value);\n          }\n\n          return value;\n        });\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources);\n};\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\n\nexport const getDeeply = (object, path) => {\n  let objectTemp = object;\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]];\n  }\n\n  return objectTemp[path[i]];\n};\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\n\nexport const isObject = value => {\n  return value && typeof value === 'object' && !Array.isArray(value);\n};\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\n\nexport const setDeeply = (object, path, value) => {\n  // Exit early if not an object.\n  if (typeof object !== 'object') {\n    return;\n  }\n\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]; // Exit early if not an object.\n\n    if (typeof object !== 'object') {\n      return;\n    }\n  }\n\n  object[path[i]] = value;\n};\nexport default {\n  deepAssign: deepAssign,\n  getDeeply: getDeeply,\n  isObject: isObject,\n  setDeeply: setDeeply\n};", "export const parseResponse = (response, type) => {\n  let promise;\n\n  switch (String.prototype.toLowerCase.call(type)) {\n    default:\n      console.warn('Unknown response type \"' + type + '\" used when using the $fetch context.');\n      break;\n\n    case 'arraybuffer':\n      promise = response.arrayBuffer();\n      break;\n\n    case 'blob':\n      promise = response.blob();\n      break;\n\n    case 'formdata':\n      promise = response.formData();\n      break;\n\n    case 'json':\n      promise = response.json();\n      break;\n    // HTML and xml need to be converted to text before being able to be parsed.\n\n    case 'element':\n    case 'html':\n    case 'svg':\n    case 'text':\n    case 'xml':\n      promise = response.text();\n      break;\n  }\n\n  if (!promise) {\n    return null;\n  }\n\n  return promise.then(response => {\n    switch (type) {\n      // Convert from html to HTMLElement inside a document fragment.\n      case 'element':\n        const template = document.createElement('template');\n        template.innerHTML = response;\n        response = template.content.childNodes[0];\n        break;\n      // Parse some values via the DOM parser.\n\n      case 'html':\n        response = new DOMParser().parseFromString(response, 'text/html');\n        break;\n\n      case 'svg':\n        response = new DOMParser().parseFromString(response, 'image/svg+xml');\n        break;\n\n      case 'xml':\n        response = new DOMParser().parseFromString(response, 'application/xml');\n        break;\n    }\n\n    return response;\n  });\n};\nexport const responseType = response => {\n  switch (String.prototype.toLowerCase(response.headers.get('content-type'))) {\n    case 'text/html':\n      return 'html';\n\n    case 'application/json':\n    case 'application/ld+json':\n    case 'application/vnd.api+json':\n      return 'json';\n\n    case 'image/svg+xml':\n      return 'svg';\n\n    case 'text/plain':\n      return 'text';\n\n    case 'application/xml':\n    case 'text/xml':\n      return 'xml';\n  }\n\n  return null;\n};", "// Import utilities.\nimport { deepAssign } from '@doars/common/src/utilities/Object.js';\nimport { parseResponse, responseType } from '../../utilities/Fetch.js';\nexport default (({\n  defaultInit\n}) => {\n  return {\n    name: '$fetch',\n    create: () => {\n      return {\n        value: (url, init = null) => {\n          // Apply default options to init.\n          if (defaultInit) {\n            init = deepAssign({}, defaultInit, init);\n          } // Extract optional return type.\n\n\n          let returnType = init.returnType ? init.returnType : null;\n          delete init.returnType; // Perform and process fetch request.\n\n          return fetch(url, init).then(response => {\n            // Automatically base return type on header.\n            if (returnType === 'auto' && response.headers.get('content-type')) {\n              returnType = responseType(response);\n            } // Parse response based on return type.\n\n\n            if (returnType) {\n              response = parseResponse(response, returnType);\n            }\n\n            return response;\n          });\n        }\n      };\n    }\n  };\n});", "export const FETCH = Symbol('FETCH');", "// Import symbols.\nimport { FETCH } from '../../symbols.js';\nexport default (({\n  defaultInit,\n  encodingConverters\n}) => {\n  return {\n    name: 'fetch',\n    update: (component, attribute, {\n      processExpression\n    }) => {// TODO: Add most modifiers from 'on' directive, such as delay, prevent, and once.\n      // TODO: Add delete, get, patch, post, and put modifiers.\n      // TODO: Add inner, outer, inner-append, outer-append, inner-prepend, outer-prepend, morph modifiers.\n      // TODO: Add reference modifier whose first part is the keyword and the second part the name of the reference key. Only available in combination with the inner or outer modifier.\n      // TODO: Add encoding modifier whose first part is the keyword and the second part the name of the encoding type.\n      // TODO: Auto listen to click events on buttons if no event is specified.\n      // TODO: Auto listen to submit events on forms if no event is specified.\n      // TODO: Handle enctype attribute on form.\n      // TODO: Handle form validation. Take required and pattern attributes into account.\n      // TODO: Handle input type form.\n      // TODO: Use method attribute on form if related modifier is not used.\n      // TODO: Use action attribute on form if no attribute value is specified.\n      // TODO: Dispatch d-fetch event on element.\n      // TODO: Dispatch d-fetch-error event on element when a fetch error occurs.\n      // TODO: Dispatch d-fetch-invalid event on element when form validation fails.\n    }\n  };\n});", "// Import contexts.\nimport createFetchContext from './factories/contexts/fetch.js';\nimport createFetchDirective from './factories/directives/fetch.js';\nexport default class DoarsFetch {\n  /**\n   * Create plugin instance.\n   * @param {Doars} library Doars instance to add onto.\n   * @param {Object} options The plugin options.\n   */\n  constructor(library, options = null) {\n    // Clone options.\n    options = Object.assign({\n      defaultInit: {},\n      encodingConverters: {\n        'application/json': () => {},\n        'application/x-www-form-urlencoded': () => {},\n        'multipart/formdata': () => {}\n      }\n    }, options); // Store contexts and directives.\n\n    let fetchContext, fetchDirective; // Enable plugin when library is enabling.\n\n    library.addEventListener('enabling', () => {\n      // Create and add contexts and directives.\n      fetchContext = createFetchContext(options);\n      library.addContexts(0, fetchContext);\n      fetchDirective = createFetchDirective(options);\n      library.addDirectives(-1, fetchDirective);\n    }); // Disable plugin when library is disabling.\n\n    library.addEventListener('disabling', () => {\n      // Remove contexts and directives.\n      library.removeContexts(fetchContext);\n      fetchContext = null;\n      library.removeDirective(fetchDirective);\n      fetchDirective = null;\n    });\n  }\n\n}", "import DoarsFetch from './DoarsFetch.js';\nwindow.DoarsFetch = DoarsFetch;"],
  "mappings": "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",
  "names": ["response", "fetch_default", "fetch_default"]
}
