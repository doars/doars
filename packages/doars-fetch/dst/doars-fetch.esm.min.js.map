{
  "version": 3,
  "sources": ["../../common/src/utilities/Fetch.js", "../../common/src/utilities/Object.js", "../src/contexts/fetch.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/String.js", "../../common/src/utilities/Attribute.js", "../../common/src/utilities/Transition.js", "../../common/src/utilities/Indicator.js", "../../common/src/utilities/Morph.js", "../../common/src/utilities/Promise.js", "../../common/src/utilities/Script.js", "../src/utilities/Xml.js", "../src/directives/fetch.js", "../../common/src/polyfills/IntersectionDispatcher.js", "../src/DoarsFetch.js"],
  "sourcesContent": [
    "/**\n * Convert response to a desired type.\n * @param {Response} response The response to parse.\n * @param {string} type Simplified type name the data should be converted to.\n * @returns {Promise<any>} Resulting data.\n */\nexport const parseResponse = (\n  response,\n  type,\n) => {\n  let promise\n  switch (String.prototype.toLowerCase.call(type)) {\n    default:\n      console.warn('Unknown response type \"' + type + '\" used.')\n      break\n\n    case 'arraybuffer':\n      promise = response.arrayBuffer()\n      break\n\n    case 'blob':\n      promise = response.blob()\n      break\n\n    case 'formdata':\n      promise = response.formData()\n      break\n\n    case 'json':\n      promise = response.json()\n      break\n\n    // HTML and xml need to be converted to text before being able to be parsed.\n    case 'element': case 'html-partial':\n    case 'html':\n    case 'svg':\n    case 'text':\n    case 'xml':\n      promise = response.text()\n      break\n  }\n\n  if (!promise) {\n    return null\n  }\n\n  return promise\n    .then((\n      response,\n    ) => {\n      switch (type) {\n        // Convert from html to HTMLElement inside a document fragment.\n        case 'element': case 'html-partial':\n          const template = document.createElement('template')\n          template.innerHTML = response\n          response = template.content.childNodes[0]\n          break\n\n        // Parse some values via the DOM parser.\n        case 'html':\n          response = (new DOMParser()).parseFromString(response, 'text/html')\n          break\n        case 'svg':\n          response = (new DOMParser()).parseFromString(response, 'image/svg+xml')\n          break\n        case 'xml':\n          response = (new DOMParser()).parseFromString(response, 'application/xml')\n          break\n      }\n\n      return response\n    })\n}\n\n/**\n * Try and get the mime type of the response.\n * @param {Response} response Response to try and get the type from.\n * @param {Request} request Request the response originates from.\n * @returns {string} mime type.\n */\nexport const responseType = (\n  response,\n  request = null,\n) => {\n  // Check content type header.\n  let contentType = response.headers.get('Content-Type')\n  if (contentType) {\n    contentType = String.prototype.toLowerCase.call(contentType).split(';')[0]\n    const result = simplifyType(contentType.trim())\n    if (result) {\n      return result\n    }\n  }\n\n  // Check url extension.\n  let extension = response.url.split('.')\n  if (extension) {\n    extension = extension[extension.length - 1]\n    switch (extension) {\n      case 'htm':\n      case 'html':\n        return 'html'\n\n      case 'json':\n        return 'json'\n\n      case 'svg':\n        return 'svg'\n\n      case 'txt':\n        return 'text'\n\n      case 'xml':\n        return 'xml'\n    }\n  }\n\n  // Check accept type header.\n  if (request) {\n    let acceptTypes = request.headers.Accept\n    if (acceptTypes) {\n      acceptTypes = String.prototype.toLowerCase.call(acceptTypes).split(',')\n      for (let acceptType of acceptTypes) {\n        acceptType = acceptType.split(';')[0].trim()\n        const result = simplifyType(acceptType)\n        if (result) {\n          return result\n        }\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Simplify the mime type to single word.\n * @param {string} mimeType Mime type to simplify.\n * @returns {string} Simplified type.\n */\nexport const simplifyType = (\n  mimeType,\n) => {\n  switch (mimeType) {\n    case 'text/html':\n      return 'html'\n\n    case 'text/html-partial':\n      return 'html-partial'\n\n    case 'text/json':\n    case 'application/json':\n    case 'application/ld+json':\n    case 'application/vnd.api+json':\n      return 'json'\n\n    case 'image/svg+xml':\n      return 'svg'\n\n    case 'text/plain':\n      return 'text'\n\n    case 'application/xml':\n    case 'text/xml':\n      return 'xml'\n  }\n}\n\n/**\n *\n * @param {string} url Fetch URL.\n * @param {Request} options Fetch options.\n * @param {string} returnType Simplified type name the data should be converted to.\n * @returns {Promise<any>} Resulting data.\n */\nexport const fetchAndParse = (\n  url,\n  options,\n  returnType,\n) => (new Promise((\n  resolve,\n  reject,\n) => {\n  fetch(url, options)\n    .then((response) => {\n      if (\n        response.status < 200\n        || response.status >= 500\n      ) {\n        reject(response)\n        return\n      }\n\n      // Automatically base return type on header.\n      if (\n        !returnType\n        || returnType === 'auto'\n      ) {\n        returnType = responseType(response, options)\n      }\n      // Parse response based on return type.\n      const responseParse = parseResponse(response, returnType)\n      if (!responseParse) {\n        throw new Error('No valid response returned.')\n      }\n      responseParse\n        .then(responseValue => {\n          response.value = responseValue\n          resolve(response)\n        })\n    })\n    .catch((error) => {\n      reject(error)\n    })\n}))\n\nexport default {\n  fetchAndParse,\n  parseResponse,\n  responseType,\n  simplifyType,\n}\n",
    "/**\n * Deeply assign a series of objects properties together.\n * @param {object} target Target object to merge to.\n * @param {...object} sources Objects to merge into the target.\n * @returns {object} Merged resulting object.\n */\nexport const deepAssign = (\n  target,\n  ...sources\n) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {object} object Object to get from.\n * @param  {Array<string>} path Path to value.\n * @returns {any} value at path.\n */\nexport const getDeeply = (\n  object,\n  path,\n) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {any} value Value of unknown type.\n * @returns {boolean} Whether the value is an object.\n */\nexport const isObject = (\n  value,\n) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {object} object Object to set on.\n * @param {Array<string>} path Path to value.\n * @param {any} value Value to set.\n */\nexport const setDeeply = (\n  object,\n  path,\n  value,\n) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n",
    "// Import utilities.\nimport { fetchAndParse } from '@doars/common/src/utilities/Fetch.js'\nimport { deepAssign } from '@doars/common/src/utilities/Object.js'\n\nexport default ({\n  fetchContextName,\n  fetchOptions,\n}) => ({\n  name: fetchContextName,\n\n  create: (\n  ) => {\n    return {\n      value: (\n        url,\n        options = null,\n      ) => {\n        // Apply default options to init.\n        if (fetchOptions) {\n          options = deepAssign({}, fetchOptions, options)\n        }\n\n        // Extract optional return type.\n        const returnType = options.returnType ? options.returnType : null\n        delete options.returnType\n\n        // Perform and process fetch request.\n        return fetchAndParse(\n          url,\n          options,\n          returnType,\n        )\n          .then((result) => {\n            if (\n              result\n              && result.value\n            ) {\n              return result.value\n            }\n          })\n      },\n    }\n  },\n})\n",
    "/**\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').ProcessExpression} ProcessExpression\n */\n\n/**\n * Convert string to HTML element.\n * @param {string} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const stringStart = string.substring(0, 15).toLowerCase()\n  if (\n    stringStart.startsWith('<!doctype html>') ||\n    stringStart.startsWith('<html>')\n  ) {\n    const html = document.createElement('html')\n    html.innerHTML = string\n    return html\n  }\n\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMLElement} a A node.\n * @param {HTMLElement} b Another node.\n * @returns {boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (\n    a.isSameNode &&\n    a.isSameNode(b)\n  ) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Select a section of the element.\n * @param {HTMLElement|string} node Element to select from.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {ProcessExpression} processExpression Function to process an expression with.\n * @returns {HTMLElement|string|null} The selection of the node based on the select directive, if a string was entered in to the function it will also be returned as a string.\n */\nexport const select = (\n  node,\n  component,\n  attribute,\n  processExpression,\n) => {\n  const libraryOptions = component.getLibrary().getOptions()\n  const element = attribute.getElement()\n  const directive = attribute.getDirective()\n\n  const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.selectFromElementDirectiveName\n  if (!element.hasAttribute(attributeName)) {\n    return node\n  }\n  let selector = null\n  if (libraryOptions.selectFromElementDirectiveEvaluate) {\n    selector = processExpression(\n      component,\n      attribute,\n      element.getAttribute(attributeName),\n    )\n    if (typeof (selector) !== 'string') {\n      console.warn('Doars: `' + attributeName + '` must return a string.')\n      return null\n    }\n  } else {\n    selector = element.getAttribute(attributeName)\n  }\n  if (selector) {\n    const asString = typeof (node) === 'string'\n    if (asString) {\n      node = fromString(node)\n    }\n\n    node = node.querySelector(selector)\n\n    if (\n      asString &&\n      node\n    ) {\n      return node.outerHTML\n    }\n  }\n  return node\n}\n\n/**\n * @callback WalkIterate Returns a new child element or null when all items have been iterated on.\n * @returns {HTMLElement|null}\n */\n\n/**\n * @callback WalkFilter Filter function that takes in an element and return true if the element needs to be walked and false when it needs to be skipped.\n * @param {HTMLElement} element Element to decide on.\n * @returns {boolean}\n */\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} node Element to walk over.\n * @param {WalkFilter} filter Filter function, return false to skip element.\n * @returns {WalkIterate} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  node,\n  filter,\n) => {\n  let index = -1\n  /** @type {null|WalkIterate} */\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (\n      index >= 0 &&\n      iterator\n    ) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= node.childElementCount) {\n        return null\n      }\n\n      child = node.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  isSame,\n  select,\n  walk,\n}\n",
    "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n",
    "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {string} text String to escape.\n * @returns {string} Escaped string.\n */\nexport const escapeHtml = (\n  text,\n) => {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\\\'/g, '\\\\\\'')\n    .replace(/\\\\\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n}\n\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {string} text String to modify.\n * @returns {string} Converted string.\n */\nexport const kebabToCamel = (\n  text,\n) => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase())\n}\n\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<string>} modifiers List of modifiers to parse.\n * @returns {object} Parsed modifiers.\n */\nexport const parseAttributeModifiers = (\n  modifiers,\n) => {\n  const result = {}\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-')\n\n    // If no hyphen then set the modifiers to true.\n    if (hyphenIndex < 0) {\n      result[modifier] = true\n      continue\n    }\n\n    // If it starts with hyphen then set the modifier to false.\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false\n      continue\n    }\n\n    // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n    const key = modifier.substring(0, hyphenIndex)\n    let value = modifier.substring(hyphenIndex + 1)\n\n    let tmpValue = value\n\n    // Try to remove time suffixes.\n    let type\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2)\n    } else if (value.endsWith('s')) {\n      type = 's'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('m')) {\n      type = 'm'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('h')) {\n      type = 'h'\n      tmpValue = value.substring(-1)\n    }\n\n    // Try to parse the value as a number.\n    tmpValue = Number.parseInt(tmpValue)\n    if (!isNaN(tmpValue)) {\n      value = tmpValue\n\n      // Convert to milliseconds if given in a different format.\n      switch (type) {\n        case 'h':\n          value *= 60\n        case 'm':\n          value *= 60\n        case 's':\n          value *= 1000\n          break\n      }\n    }\n\n    // Store modifier data.\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {string} prefix Directive prefix.\n * @param {string} name Name to parse.\n * @returns {Array<string> | undefined} list of segments.\n */\nexport const parseAttributeName = (\n  prefix,\n  name,\n) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'))\n  if (!name) {\n    return\n  }\n  // Deconstruct match.\n  let [full, directive, keyRaw, modifiers] = name // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n  keyRaw = keyRaw !== '' ? keyRaw : null\n  const key = keyRaw ? kebabToCamel(keyRaw) : null\n  // Ensure modifiers is and array.\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []\n  // Return result a single array.\n  return [directive, keyRaw, key, modifiers]\n}\n\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n * @param {string} expression For expression to parse.\n * @returns {object | undefined} Iterable type and variables.\n */\nexport const parseForExpression = (\n  expression,\n) => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i)\n  if (!match) {\n    return\n  }\n\n  // Remove parenthesis.\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, '')\n  // Parse for variables.\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i)\n  if (!variables) {\n    return\n  }\n  variables.shift()\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables], // Convert it to an array instead of a regular expression match.\n  }\n}\n\n/**\n * Parse selector to an attributes object.\n * @param {string} selector Selector to parse.\n * @returns {object | undefined} Attributes. Do note the class property is a list of strings not a single string.\n */\nexport const parseSelector = (\n  selector,\n) => {\n  // Convert to array.\n  if (typeof (selector) === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/)\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.')\n    return\n  }\n\n  const attributes = {}\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim()\n\n    // Base what to do of the leading character.\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1)\n        break\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1)\n        // Add to classlist.\n        if (!attributes.class) {\n          attributes.class = []\n        }\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment)\n        }\n        break\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i) // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n        attributes[key] = value\n        break\n    }\n  }\n  return attributes\n}\n\nexport default {\n  escapeHtml,\n  kebabToCamel,\n  parseAttributeModifiers,\n  parseAttributeName,\n  parseForExpression,\n  parseSelector,\n}\n",
    "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n",
    "// Import utilities.\nimport { parseSelector } from './String.js'\nimport { addAttributes, removeAttributes } from './Attribute.js'\n\n// Transition name.\nconst TRANSITION_NAME = '-transition:'\n\n/**\n * @callback TransitionEnd\n */\n\n/**\n * Transition an element.\n * @param {string} type Type of transition, for example 'in' and 'out'.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transition = (\n  type,\n  libraryOptions,\n  element,\n  callback = null,\n) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback()\n    }\n    return\n  }\n\n  // Transition attribute name.\n  const transitionDirectiveName = libraryOptions.prefix + TRANSITION_NAME + type\n\n  // Setup dispatcher function.\n  const dispatchEvent = (phase) => {\n    element.dispatchEvent(\n      new CustomEvent('transition-' + phase),\n    )\n    element.dispatchEvent(\n      new CustomEvent('transition-' + type + '-' + phase),\n    )\n  }\n\n  // Declare variables for later.\n  let name, value, timeout, requestFrame\n  let isDone = false\n  const selectors = {}\n\n  // Process transition during attribute.\n  name = transitionDirectiveName\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.during = parseSelector(value)\n    addAttributes(element, selectors.during)\n  }\n\n  // Process transition from attribute.\n  name = transitionDirectiveName + '.from'\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.from = parseSelector(value)\n    addAttributes(element, selectors.from)\n  }\n\n  // Dispatch transition event.\n  dispatchEvent('start')\n\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null\n\n    // If cancelled then stop immediately.\n    if (isDone) {\n      return\n    }\n\n    // Remove from selector.\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    }\n\n    // Process transition to attribute.\n    name = transitionDirectiveName + '.to'\n    value = element.getAttribute(name)\n    // Parse and apply returned selector.\n    if (value) {\n      selectors.to = parseSelector(value)\n      addAttributes(element, selectors.to)\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n      return\n    }\n\n    // Get computes style.\n    const styles = getComputedStyle(element)\n\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null\n\n      // If cancelled then stop immediately.\n      if (isDone) {\n        return\n      }\n\n      // Remove during selector.\n      if (selectors.during) {\n        removeAttributes(element, selectors.during)\n        selectors.during = undefined\n      }\n\n      // Remove to selector.\n      if (selectors.to) {\n        removeAttributes(element, selectors.to)\n        selectors.to = undefined\n      }\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n    }, duration)\n  })\n\n  return (\n  ) => {\n    if (!isDone) {\n      return\n    }\n    isDone = true\n\n    // Remove applied selector.\n    if (selectors.during) {\n      removeAttributes(element, selectors.during)\n      selectors.during = undefined\n    }\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to)\n      selectors.to = undefined\n    }\n\n    // Clear request animation frame and timeout.\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame)\n      requestFrame = null\n    } else if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    // Dispatch end event.\n    dispatchEvent('end')\n    // Invoke callback.\n    if (callback) {\n      callback()\n    }\n  }\n}\n\n/**\n * Transition an element in.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionIn = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('in', libraryOptions, element, callback)\n}\n\n/**\n * Transition an element out.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionOut = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('out', libraryOptions, element, callback)\n}\n\nexport default {\n  transition,\n  transitionIn,\n  transitionOut,\n}\n",
    "import {\n  transitionIn,\n  transitionOut,\n} from './Transition.js'\n\n/**\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').ProcessExpression} ProcessExpression\n */\n\n/**\n * Hides the indicator.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @returns {void}\n */\nexport const hideIndicator = (\n  component,\n  attribute,\n) => {\n  // Check if a indicator exists.\n  if (!attribute.indicator) {\n    return\n  }\n  // Check if not already transitioning out.\n  if (attribute.indicator.indicatorTransitionOut) {\n    return\n  }\n  // Check if a indicator element exists.\n  if (!attribute.indicator.indicatorElement) {\n    return\n  }\n\n  const libraryOptions = component.getLibrary().getOptions()\n\n  // Transition element in.\n  const indicatorElement = attribute.indicator.indicatorElement\n  attribute.indicator.indicatorTransitionIn =\n    transitionOut(libraryOptions, indicatorElement, () => {\n      if (indicatorElement) {\n        indicatorElement.remove()\n      }\n    })\n}\n\n/**\n * Shows the indicator.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {ProcessExpression} processExpression Function to process an expression with.\n * @returns {void}\n */\nexport const showIndicator = (\n  component,\n  attribute,\n  processExpression,\n) => {\n  const libraryOptions = component.getLibrary().getOptions()\n  const element = attribute.getElement()\n  const directive = attribute.getDirective()\n\n  const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.indicatorDirectiveName\n  if (!element.hasAttribute(attributeName)) {\n    return\n  }\n  let indicatorTemplate = null\n  if (libraryOptions.indicatorDirectiveEvaluate) {\n    indicatorTemplate = processExpression(\n      component,\n      attribute,\n      element.getAttribute(attributeName),\n    )\n  } else {\n    indicatorTemplate = element.getAttribute(attributeName)\n  }\n  if (!indicatorTemplate) {\n    return\n  }\n  if (typeof (indicatorTemplate) === 'string') {\n    indicatorTemplate = element.querySelector(indicatorTemplate)\n    if (!indicatorTemplate) {\n      return\n    }\n  }\n\n  // Check if placed on a template tag.\n  if (indicatorTemplate.tagName !== 'TEMPLATE') {\n    console.warn('Doars: `' + attributeName + '` must be placed on a `<template>`.')\n    return\n  }\n  if (indicatorTemplate.childCount > 1) {\n    console.warn('Doars: `' + attributeName + '` must have one child.')\n    return\n  }\n\n  // Cancel current transition.\n  if (attribute.indicator) {\n    if (attribute.indicator.indicatorTransitionOut) {\n      attribute.indicator.indicatorTransitionOut()\n      attribute.indicator.indicatorTransitionOut = null\n    } else if (attribute.indicator.indicatorElement) {\n      return\n    }\n  }\n\n  // Create new element from template.\n  const indicatorElement = document.importNode(indicatorTemplate.content, true).firstElementChild\n  // Add element after the template element.\n  indicatorTemplate.insertAdjacentElement('afterend', indicatorElement)\n  attribute.indicator = {\n    indicatorElement,\n    // Transition element in.\n    indicatorTransitionIn: transitionIn(libraryOptions, indicatorElement),\n  }\n}\n\nexport default {\n  hideIndicator,\n  showIndicator,\n}\n",
    "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame,\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement | string} newTree The tree to change to.\n * @param {object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the initial value. Changing the \"value\" attribute without changing the \"value\" property will have no effect since it is only used to the set the initial value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n * @param {string} name Name of the attribute.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop.\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing.\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old.\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new.\n    } else if (!existingChild) {\n      existingNode.append(newChild)\n      offset++\n\n      // Both nodes are the same, morph.\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder.\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree.\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list.\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID.\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node.\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n",
    "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (\n  value,\n) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (\n  value,\n) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n",
    "import { walk } from './Element.js'\n\n/**\n * Re-adds a script to the document in order to trigger it again.\n * @param {HTMLElement} element Script to re-add to the DOM.\n * @returns {void}\n */\nconst _readdScript = (\n  element,\n) => {\n  // Check if element is a script without a source.\n  if (\n    element.tagName !== 'SCRIPT' ||\n    element.hasAttribute('src')\n  ) {\n    return false\n  }\n\n  // Set up new script with same content.\n  const newScript = document.createElement('script')\n  newScript.innerText = element.innerText\n\n  // Replace script in the document.\n  element.parentNode.insertBefore(\n    newScript,\n    element,\n  )\n  element.remove()\n  return true\n}\n\n/**\n * Checks the elements for scripts and re-adds these to the DOM.\n * @param  {...HTMLElement} elements Elements to check for scripts.\n * @returns {void}\n */\nexport const readdScripts = (\n  ...elements\n) => {\n  for (const element of elements) {\n    // Try to re-add element in case it is a script.\n    if (!_readdScript(element)) {\n      // Otherwise check its children.\n      const iterate = walk(element)\n      let maybeScript = null\n      while (maybeScript = iterate()) {\n        _readdScript(maybeScript)\n      }\n    }\n  }\n}\n\nexport default {\n  readdScripts,\n}\n",
    "/**\n * Convert a form data object to XML.\n * @param {FormData} formData Data to serialize.\n * @returns {string} Serialized form data.\n */\nexport const serializeFormData = (\n  formData,\n) => {\n  const xml = document.createElement('xml')\n  xml.append(...formData.map((value, key) => {\n    const element = document.createElement(key)\n    element.textContent = value\n    return element\n  }))\n\n  const serializer = new XMLSerializer()\n  return serializer.serializeToString(xml)\n}\n\nexport default {\n  serializeFormData,\n}\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').Directive} Directive\n * @typedef {import('@doars/doars/src/Directive.js').DirectiveUtilities} DirectiveUtilities\n * @typedef {import('@doars/common/src/polyfills/IntersectionDispatcher.js').default} IntersectionDispatcher\n */\n\n// Import utilities.\nimport { fetchAndParse } from '@doars/common/src/utilities/Fetch.js'\nimport {\n  fromString as elementFromString,\n  select as selectFromElement,\n} from '@doars/common/src/utilities/Element'\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport {\n  hideIndicator,\n  showIndicator,\n} from '@doars/common/src/utilities/Indicator.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise'\nimport { readdScripts } from '@doars/common/src/utilities/Script'\n\nimport { serializeFormData } from '../utilities/Xml'\n\nconst FETCH = Symbol('FETCH')\n\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 5,\n  DELAY: 6,\n}\n\n/**\n * @typedef DirectiveOptions\n * @type {object}\n * @property {object} fetchOptions Object of options given to the fetch method when submitting data.\n * @property {string} headerTitle Name of the header that can contain a new document title.\n */\n\n/**\n * @param {DirectiveOptions} options Options used for creating the directive.\n * @param {IntersectionDispatcher} intersectionDispatcher An intersection event dispatcher that directives can listen to.\n * @returns {Directive} Created fetch directive.\n */\nexport default ({\n  fetchOptions,\n  fetchDirectiveEvaluate,\n  fetchDirectiveName,\n\n  intersectionEvent,\n\n  loadedEvent,\n}, intersectionDispatcher) => ({\n  name: fetchDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Destruct component.\n    const library = component.getLibrary()\n    const libraryOptions = library.getOptions()\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const directive = attribute.getDirective()\n    const modifiers = attribute.getModifiers()\n    const value = attribute.getValue()\n\n    // Handle forms differently since the form values need to be used.\n    const isForm = element.tagName === 'FORM'\n    const isButton = element.tagName === 'BUTTON'\n    const isInput = (\n      element.tagName === 'INPUT'\n      || element.tagName === 'SELECT'\n    )\n\n    // Check if existing listener exists.\n    if (attribute[FETCH]) {\n      // Exit early if value has not changed.\n      if (attribute[FETCH].value === value) {\n        return\n      }\n\n      // Remove existing listener so we don't listen twice.\n      attribute[FETCH].target.removeEventListener(\n        attribute[FETCH].eventName,\n        attribute[FETCH].handler,\n      )\n\n      // Clear any ongoing timeouts.\n      if (attribute[FETCH].timeout) {\n        clearTimeout(attribute[FETCH].timeout)\n      }\n\n      // Delete directive data.\n      delete attribute[FETCH]\n    }\n\n    // Process modifiers.\n\n    const encoding = (modifiers.encoding ? modifiers.encoding.toLowerCase() : null)\n    const method = (modifiers.method ? modifiers.method.toUpperCase() : null)\n    const position = (modifiers.position ? modifiers.position.toLowerCase() : null)\n\n    // Set listener options.\n    const listenerOptions = {}\n    if (modifiers.capture) {\n      listenerOptions.capture = true\n    }\n    if (modifiers.once) {\n      listenerOptions.once = true\n    }\n    if (modifiers.passive && !modifiers.prevent) {\n      listenerOptions.passive = true\n    }\n\n    // Process execution modifiers.\n    let executionModifier = EXECUTION_MODIFIERS.NONE\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500\n      }\n    } else if (modifiers.delay) {\n      executionModifier = EXECUTION_MODIFIERS.DELAY\n      if (modifiers.delay === true) {\n        modifiers.delay = 500\n      }\n    }\n\n    if (modifiers.poll === true) {\n      modifiers.poll = 60000 // One minute.\n    }\n\n    let eventName = 'click'\n    if (modifiers.on) {\n      eventName = modifiers.on\n    } else if (isForm) {\n      eventName = 'submit'\n    } else if (isInput) {\n      eventName = 'change'\n    } else if (modifiers.poll) {\n      eventName = loadedEvent\n    }\n\n    const fetchHeaders = {\n      [libraryOptions.prefix + '-' + libraryOptions.requestHeaderName]: directive,\n      Vary: libraryOptions.prefix + '-' + libraryOptions.requestHeaderName,\n    }\n\n    const dispatchEvent = (\n      suffix = '',\n      data = {},\n    ) => {\n      element.dispatchEvent(\n        new CustomEvent(\n          libraryOptions.prefix + '-' + directive + suffix,\n          {\n            detail: Object.assign({\n              attribute,\n              component,\n            }, data),\n          },\n        ),\n      )\n    }\n\n    /**\n     * Perform a request.\n     * @param {URL} url URL of the request to perform.\n     * @returns {void}\n     */\n    const requestHandler = (\n      url,\n    ) => {\n      /** @type {Request} */\n      const _fetchOptions = {\n        headers: {},\n      }\n\n      if (method) {\n        _fetchOptions.method = method\n      } else if (\n        isForm\n        && element.hasAttribute('method')\n      ) {\n        _fetchOptions.method = element.getAttribute('method').toUpperCase()\n      } else {\n        _fetchOptions.method = 'GET'\n      }\n\n      if (isForm) {\n        const formData = new FormData(element)\n        let _encoding = encoding\n        if (\n          !_encoding\n          && element.hasAttribute('enctype')\n        ) {\n          _encoding = element.getAttribute('enctype').toLowerCase()\n        } else {\n          _encoding = 'urlencoded'\n        }\n        if (\n          _fetchOptions.method === 'HEAD'\n          || _fetchOptions.method === 'GET'\n        ) {\n          _encoding = 'parameters'\n        }\n\n        switch (_encoding) {\n          case 'json':\n            _fetchOptions.headers['Content-Type'] = 'application/json; charset=UTF-8'\n            _fetchOptions.body = JSON.stringify(Object.fromEntries(formData))\n            break\n\n          case 'multipart':\n          case 'multipart/form-data':\n            _fetchOptions.headers['Content-Type'] = 'multipart/form-data'\n            _fetchOptions.body = formData\n            break\n\n          case 'parameters':\n            url = new URL(url, window.location.href)\n            const parameters = new URLSearchParams(formData)\n            for (const [parameterName, parameterValue] of parameters) {\n              url.searchParams.set(parameterName, parameterValue)\n            }\n            url = url.toString()\n            break\n\n          case 'urlencoded':\n          case 'application/x-www-form-urlencoded':\n            _fetchOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'\n            _fetchOptions.body = new URLSearchParams(formData).toString()\n            break\n\n          case 'xml':\n            _fetchOptions.headers['Content-Type'] = 'application/xml; charset=UTF-8'\n            _fetchOptions.body = serializeFormData(formData)\n            break\n\n          default:\n            console.warn('DoarsFetch: \"' + directive + '\" directive\\'s invalid encoding type \"' + _encoding + '\".')\n            break\n        }\n      }\n\n      dispatchEvent('-started', {\n        url,\n      })\n\n      return fetchAndParse(\n        url,\n        Object.assign({}, fetchOptions, _fetchOptions, {\n          headers: Object.assign({}, _fetchOptions.headers, fetchHeaders),\n        }),\n        'text',\n      )\n        .then((response) => {\n          isLoading = false\n\n          // Decode string.\n          let html = response.value\n          if (modifiers.decode) {\n            html = decode(html)\n          }\n\n          /** @type {HTMLElement | null} */\n          let target = null\n          if (modifiers.document) {\n            target = document.documentElement\n          } else {\n            const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.targetDirectiveName\n            if (element.getAttribute(attributeName)) {\n              if (libraryOptions.targetDirectiveEvaluate) {\n                target = processExpression(\n                  component,\n                  attribute,\n                  element.getAttribute(attributeName),\n                )\n              } else {\n                target = element.getAttribute(attributeName)\n              }\n              if (target && typeof (target) === 'string') {\n                target = element.querySelector(target)\n              }\n            }\n            if (!target) {\n              target = element\n            }\n          }\n\n          // Update target.\n          if (position === 'append') {\n            const child = selectFromElement(\n              elementFromString(html),\n              component,\n              attribute,\n              processExpression,\n            )\n            target.append(child)\n            if (\n              libraryOptions.allowInlineScript\n              || modifiers.script\n            ) {\n              readdScripts(child)\n            }\n          } else if (position === 'prepend') {\n            const child = selectFromElement(\n              elementFromString(html),\n              component,\n              attribute,\n              processExpression,\n            )\n            target.prepend(child)\n            if (\n              libraryOptions.allowInlineScript\n              || modifiers.script\n            ) {\n              readdScripts(child)\n            }\n          } else if (position === 'after') {\n            const child = selectFromElement(\n              elementFromString(html),\n              component,\n              attribute,\n              processExpression,\n            )\n            target.insertAdjacentElement('afterend', child)\n            if (\n              libraryOptions.allowInlineScript\n              || modifiers.script\n            ) {\n              readdScripts(child)\n            }\n          } else if (position === 'before') {\n            const child = selectFromElement(\n              elementFromString(html),\n              component,\n              attribute,\n              processExpression,\n            )\n            target.insertAdjacentElement('beforebegin', child)\n            if (\n              libraryOptions.allowInlineScript\n              || modifiers.script\n            ) {\n              readdScripts(child)\n            }\n          } else if (position === 'outer') {\n            if (modifiers.morph) {\n              morphTree(\n                target,\n                selectFromElement(\n                  elementFromString(html),\n                  component,\n                  attribute,\n                  processExpression,\n                ),\n              )\n            } else if (target.outerHTML !== html) {\n              target.outerHTML = selectFromElement(\n                html,\n                component,\n                attribute,\n                processExpression,\n              )\n              if (\n                libraryOptions.allowInlineScript\n                || modifiers.script\n              ) {\n                readdScripts(target)\n              }\n            }\n          } else if (modifiers.morph) {\n            // Ensure element only has one child.\n            if (target.children.length === 0) {\n              target.append(document.createElement('div'))\n            } else if (target.children.length > 1) {\n              for (let i = target.children.length - 1; i >= 1; i--) {\n                target.children[i].remove()\n              }\n            }\n\n            // Morph first child to given target tree.\n            const root = morphTree(\n              target.children[0],\n              selectFromElement(\n                elementFromString(html),\n                component,\n                attribute,\n                processExpression,\n              ),\n            )\n            if (!target.children[0].isSameNode(root)) {\n              target.children[0].remove()\n              target.append(root)\n            }\n          } else if (target.innerHTML !== html) {\n            target.innerHTML = selectFromElement(\n              html,\n              component,\n              attribute,\n              processExpression,\n            )\n            if (\n              libraryOptions.allowInlineScript\n              || modifiers.script\n            ) {\n              readdScripts(...target.children)\n            }\n          }\n\n          // Get new document link.\n          if (\n            libraryOptions.redirectHeaderName\n            && response.headers.has(libraryOptions.prefix + '-' + libraryOptions.redirectHeaderName)\n          ) {\n            window.location.href = response.headers.get(libraryOptions.prefix + '-' + libraryOptions.redirectHeaderName)\n            return\n          }\n\n          // Get new document title.\n          let documentTitle = ''\n          if (\n            libraryOptions.titleHeaderName\n            && response.headers.has(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)\n          ) {\n            documentTitle = response.headers.get(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)\n          }\n\n          // Update history api.\n          if (modifiers.history) {\n            history.pushState({}, documentTitle, url)\n          }\n\n          // If document title was not updated via the history update, then set it now.\n          if (\n            documentTitle\n            && document.title !== documentTitle\n          ) {\n            document.title = documentTitle\n          }\n\n          hideIndicator(\n            component,\n            attribute,\n          )\n\n          dispatchEvent('-succeeded', {\n            url,\n          })\n        })\n        .catch(() => {\n          hideIndicator(\n            component,\n            attribute,\n          )\n\n          dispatchEvent('-failed', {\n            url,\n          })\n        })\n    }\n\n    let isLoading = false\n    /**\n     * Handles the interaction with a element containing the directive.\n     * @param {Event} event Document event to handle.\n     * @returns {void}\n     */\n    let handler = (\n      event,\n    ) => new Promise((resolve) => {\n      // Only fire when self is provided if the target is the element itself.\n      if (\n        modifiers.self\n        && event\n        && event.target !== element\n      ) {\n        resolve()\n        return\n      }\n\n      if (\n        isForm\n        && !element.reportValidity()\n      ) {\n        dispatchEvent('-invalid')\n        resolve()\n        return\n      }\n\n      // Prevent the default event action.\n      if (\n        (\n          (\n            isForm\n            && eventName === 'submit'\n          )\n          || (\n            isButton\n            && element.getAttribute('type', 'button')\n            && eventName === 'click'\n          )\n          || modifiers.prevent\n        )\n        && event\n      ) {\n        event.preventDefault()\n      }\n      // Stop propagation if the stop modifier is present.\n      if (modifiers.stop && event) {\n        event.stopPropagation()\n      }\n\n      const execute = (\n      ) => {\n        let url = null\n        if (\n          value\n          && fetchDirectiveEvaluate\n        ) {\n          url = processExpression(\n            component,\n            attribute,\n            value,\n            {\n              $event: event,\n              $events: attribute[FETCH].buffer,\n            },\n          )\n        } else if (\n          isForm\n          && element.hasAttribute('action')\n        ) {\n          url = element.getAttribute('action')\n        } else {\n          url = window.location.href\n        }\n\n        // Reset the buffer.\n        attribute[FETCH].buffer = []\n\n        if (!url) {\n          resolve()\n          return\n        }\n        isLoading = true\n\n        showIndicator(\n          component,\n          attribute,\n          processExpression,\n        );\n\n        (\n          isPromise(url)\n            ? url.then((url) => requestHandler(url))\n            : requestHandler(url)\n        ).finally(() => resolve())\n      }\n\n      if (isLoading) {\n        resolve()\n        return\n      }\n\n      // Store event in buffer.\n      attribute[FETCH].buffer.push(event)\n\n      // Check if we need to apply an execution modifier.\n      switch (executionModifier) {\n        case EXECUTION_MODIFIERS.BUFFER:\n          // Exit early if buffer is not full.\n          if (attribute[FETCH].buffer.length < modifiers.buffer) {\n            resolve()\n            return\n          }\n\n          execute()\n          return\n\n        case EXECUTION_MODIFIERS.DEBOUNCE:\n          // Clear existing timeout.\n          if (attribute[FETCH].timeout) {\n            clearTimeout(attribute[FETCH].timeout)\n            attribute[FETCH].timeout = null\n          }\n\n          // Setup timeout and execute expression when it finishes.\n          attribute[FETCH].timeout = setTimeout(execute, modifiers.debounce)\n          return\n\n        case EXECUTION_MODIFIERS.THROTTLE:\n          // Get current time in milliseconds.\n          const nowThrottle = window.performance.now()\n\n          // Exit early if throttle time has not passed.\n          if (\n            attribute[FETCH].lastExecution\n            && (nowThrottle - attribute[FETCH].lastExecution) < modifiers.throttle\n          ) {\n            resolve()\n            return\n          }\n\n          execute()\n\n          // Store new latest execution time.\n          attribute[FETCH].lastExecution = nowThrottle\n          return\n\n        case EXECUTION_MODIFIERS.DELAY:\n          // Setup timeout and execute expression when it finishes.\n          attribute[FETCH].timeout = setTimeout(execute, modifiers.delay)\n          return\n      }\n\n      // Otherwise execute expression immediately.\n      execute()\n    })\n\n    if (modifiers.poll) {\n      const _handler = handler\n      handler = () => {\n        attribute[FETCH].timeout = setTimeout(() => {\n          _handler(null)\n            .finally(() => {\n              // If the directive is still active poll again.\n              if (attribute[FETCH]) {\n                handler()\n              }\n            })\n        }, modifiers.poll)\n      }\n    }\n    if (intersectionEvent && eventName === intersectionEvent) {\n      const _handler = handler\n      handler = () => {\n        // Remove after first call.\n        if (listenerOptions.once) {\n          intersectionDispatcher.remove(\n            element,\n            handler,\n          )\n        }\n\n        _handler()\n      }\n      intersectionDispatcher.add(\n        element,\n        intersectionDispatcher,\n      )\n    } else if (eventName === loadedEvent) {\n      handler()\n    } else {\n      element.addEventListener(\n        eventName,\n        handler,\n        listenerOptions,\n      )\n    }\n\n    attribute[FETCH] = {\n      buffer: [],\n      eventName,\n      handler,\n      target: element,\n      timeout: attribute[FETCH] ? attribute[FETCH].timeout : undefined,\n      value,\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Exit early if no listeners can be found.\n    if (!attribute[FETCH]) {\n      return\n    }\n\n    // Remove existing listener.\n    attribute[FETCH].target.removeEventListener(\n      attribute[FETCH].eventName,\n      attribute[FETCH].handler,\n    )\n    if (intersectionEvent && intersectionDispatcher) {\n      intersectionDispatcher\n        .remove(\n          attribute[FETCH].target,\n          attribute[FETCH].handler,\n        )\n    }\n    // Clear any ongoing timeouts.\n    if (attribute[FETCH].timeout) {\n      clearTimeout(attribute[FETCH].timeout)\n    }\n\n    hideIndicator(\n      component,\n      attribute,\n    )\n\n    // Delete directive data.\n    delete attribute[FETCH]\n  },\n})\n",
    "export default class IntersectionDispatcher {\n  /**\n   * Create observer instance.\n   * @param {object} options Intersection observer options.\n   */\n  constructor(\n    options = null,\n  ) {\n    // Store data per element.\n    const items = new WeakMap()\n\n    /**\n     * Intersection observer handler.\n     * @param {Array<IntersectionObserverEntry>} entries Intersection observer entries.\n     */\n    const intersect = (\n      entries,\n    ) => {\n      // Invoke callbacks of each entry.\n      for (const entry of entries) {\n        for (const callback of items.get(entry.target)) {\n          callback(entry)\n        }\n      }\n    }\n\n    // Create intersection observer.\n    const observer = new window.IntersectionObserver(intersect, options)\n\n    /**\n     * Add element to observe.\n     * @param {HTMLElement} element Element to observer.\n     * @param {Function} callback Callback to call on intersection change.\n     */\n    this.add = (\n      element,\n      callback,\n    ) => {\n      // Add callback to list.\n      if (!items.has(element)) {\n        items.set(element, [])\n      }\n      items.get(element).push(callback)\n\n      // Start observing element.\n      observer.observe(element)\n    }\n\n    /**\n     * Remove element from observing.\n     * @param {HTMLElement} element Element that is observed.\n     * @param {Function} callback Callback that is called on intersection change.\n     */\n    this.remove = (\n      element,\n      callback,\n    ) => {\n      // Remove callback from list.\n      if (!items.has(element)) {\n        return\n      }\n      const list = items.get(element)\n      const index = list.indexOf(callback)\n      if (index >= 0) {\n        list.splice(index, 1)\n      }\n\n      // Check if there are no more callbacks.\n      if (list.length === 0) {\n        // Remove element from callbacks list.\n        items.delete(element)\n\n        // Stop observing element.\n        observer.unobserve(element)\n      }\n    }\n  }\n}\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport createFetchContext from './contexts/fetch.js'\nimport createFetchDirective from './directives/fetch.js'\nimport IntersectionDispatcher from '@doars/common/src/polyfills/IntersectionDispatcher.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    fetchContextName: '$fetch',\n    fetchDirectiveEvaluate: true,\n    fetchDirectiveName: 'fetch',\n    fetchOptions: {},\n\n    intersectionEvent: 'intersect',\n    intersectionRoot: null,\n    intersectionMargin: '0px',\n    intersectionThreshold: 0,\n\n    loadedEvent: 'load',\n  }, options)\n  if (options.defaultInit) {\n    Object.assign(options.fetchOptions, options.defaultInit)\n  }\n\n  // Set private variables.\n  let isEnabled = false\n\n  // Setup observer.\n  const intersectionDispatcher = (\n    options.intersectionEvent\n      ? new IntersectionDispatcher({\n        root: options.intersectionRoot\n          ? options.intersectionRoot\n          : library.getOptions().root,\n        rootMargin: options.intersectionMargin,\n        threshold: options.intersectionThreshold,\n      })\n      : null\n  )\n\n  // Store contexts and directives.\n  const fetchContext = createFetchContext(options),\n    fetchDirective = createFetchDirective(options, intersectionDispatcher)\n\n  const onEnable = (\n  ) => {\n    // Create and add contexts and directives.\n    library.addContexts(0, fetchContext)\n    library.addDirectives(-1, fetchDirective)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(fetchContext)\n    library.removeDirective(fetchDirective)\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"
  ],
  "mappings": "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",
  "debugId": "5FAECEA81A2A7B9F64756E2164756E21",
  "names": []
}