{
  "version": 3,
  "sources": ["../../common/src/utilities/Fetch.js", "../../common/src/utilities/Cache.js", "../../common/src/utilities/Object.js", "../src/contexts/fetch.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/String.js", "../../common/src/utilities/Attribute.js", "../../common/src/utilities/Transition.js", "../../common/src/utilities/Indicator.js", "../../common/src/utilities/Morph.js", "../../common/src/utilities/Promise.js", "../../common/src/utilities/Script.js", "../src/utilities/Xml.js", "../src/directives/fetch.js", "../src/DoarsFetch.js"],
  "sourcesContent": ["/**\n * Convert response to a desired type.\n * @param {Response} response The response to parse.\n * @param {string} type Simplified type name the data should be converted to.\n * @returns {Promise<any>} Resulting data.\n */\nexport const parseResponse = (\n  response,\n  type,\n) => {\n  let promise\n  switch (String.prototype.toLowerCase.call(type)) {\n    default:\n      console.warn('Unknown response type \"' + type + '\" used when using the $fetch context.')\n      break\n\n    case 'arraybuffer':\n      promise = response.arrayBuffer()\n      break\n\n    case 'blob':\n      promise = response.blob()\n      break\n\n    case 'formdata':\n      promise = response.formData()\n      break\n\n    case 'json':\n      promise = response.json()\n      break\n\n    // HTML and xml need to be converted to text before being able to be parsed.\n    case 'element':\n    case 'html':\n    case 'svg':\n    case 'text':\n    case 'xml':\n      promise = response.text()\n      break\n  }\n\n  if (!promise) {\n    return null\n  }\n\n  return promise\n    .then((\n      response,\n    ) => {\n      switch (type) {\n        // Convert from html to HTMLElement inside a document fragment.\n        case 'element':\n          const template = document.createElement('template')\n          template.innerHTML = response\n          response = template.content.childNodes[0]\n          break\n\n        // Parse some values via the DOM parser.\n        case 'html':\n          response = (new DOMParser()).parseFromString(response, 'text/html')\n          break\n        case 'svg':\n          response = (new DOMParser()).parseFromString(response, 'image/svg+xml')\n          break\n        case 'xml':\n          response = (new DOMParser()).parseFromString(response, 'application/xml')\n          break\n      }\n\n      return response\n    })\n}\n\n/**\n * Try and get the mime type of the response.\n * @param {Response} response Response to try and get the type from.\n * @param {Request} request Request the response originates from.\n * @returns {string} mime type.\n */\nexport const responseType = (\n  response,\n  request = null,\n) => {\n  // Check content type header.\n  let contentType = response.headers.get('Content-Type')\n  if (contentType) {\n    contentType = String.prototype.toLowerCase.call(contentType).split(';')[0]\n    const result = simplifyType(contentType.trim())\n    if (result) {\n      return result\n    }\n  }\n\n  // Check url extension.\n  let extension = response.url.split('.')\n  if (extension) {\n    extension = extension[extension.length - 1]\n    switch (extension) {\n      case 'htm':\n      case 'html':\n        return 'html'\n\n      case 'json':\n        return 'json'\n\n      case 'svg':\n        return 'svg'\n\n      case 'txt':\n        return 'text'\n\n      case 'xml':\n        return 'xml'\n    }\n  }\n\n  // Check accept type header.\n  if (request) {\n    let acceptTypes = request.headers.Accept\n    if (acceptTypes) {\n      acceptTypes = String.prototype.toLowerCase.call(acceptTypes).split(',')\n      for (let acceptType of acceptTypes) {\n        acceptType = acceptType.split(';')[0].trim()\n        const result = simplifyType(acceptType)\n        if (result) {\n          return result\n        }\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Simplify the mime type to single word.\n * @param {string} mimeType Mime type to simplify.\n * @returns {string} Simplified type.\n */\nexport const simplifyType = (\n  mimeType,\n) => {\n  switch (mimeType) {\n    case 'text/html':\n      return 'html'\n\n    case 'text/json':\n    case 'application/json':\n    case 'application/ld+json':\n    case 'application/vnd.api+json':\n      return 'json'\n\n    case 'image/svg+xml':\n      return 'svg'\n\n    case 'text/plain':\n      return 'text'\n\n    case 'application/xml':\n    case 'text/xml':\n      return 'xml'\n  }\n}\n\nexport default {\n  parseResponse,\n  responseType,\n  simplifyType,\n}\n", "// Raises targets to:\n//   chrome49\n//   edge16\n//   firefox39\n//   ios11.2\n//   safari11.1\n\n// Import utilities.\nimport {\n  parseResponse,\n  responseType,\n} from './Fetch.js'\n\nconst HEADER_DATE = 'Date'\nconst HEADER_CACHE_CONTROL = 'Cache-Control'\n\nconst CACHE_CLEAN_INTERVAL = 5 * 60 * 1e3 // Every 5 minutes.\nconst CACHE_INVALIDATION_CLAUSES = [\n  'no-cache',\n  'must-revalidate',\n  'no-store',\n]\nconst CACHE_NAME = 'doars'\n\nlet cacheCleanCounter = 0\nlet cacheCleanInterval = null\nconst cacheListeners = {}\n\nexport const validCacheFromHeaders = (\n  headers,\n) => {\n  if (\n    !headers.has(HEADER_DATE) ||\n    !headers.has(HEADER_CACHE_CONTROL)\n  ) {\n    return false\n  }\n  const cacheDate = new Date(headers.get(HEADER_DATE))\n  const currentDate = new Date()\n\n  // Exit early if the cached date is in the future.\n  if (cacheDate > currentDate) {\n    return false\n  }\n\n  // Get max age of the cached item.\n  const cacheControl = (headers.get(HEADER_CACHE_CONTROL)).split(',')\n  let cacheMaxAge = 0\n  for (const cacheControlItem of cacheControl) {\n    if (cacheControlItem.trim().startsWith('max-age=')) {\n      cacheMaxAge = parseInt(cacheControlItem.split('=')[1].trim(), 10)\n    }\n    if (cacheControlItem.trim().startsWith('s-maxage=')) {\n      cacheMaxAge = parseInt(cacheControlItem.split('=')[1].trim(), 10)\n      break // Break since max-age should not overwrite this.\n    }\n  }\n  // Exit early on invalid max ages.\n  if (cacheMaxAge <= 0) {\n    return false\n  }\n\n  // Calculate expiration date.\n  const expireDate = new Date(cacheDate.getTime() + (cacheMaxAge * 1e3))\n  return expireDate >= currentDate\n}\n\n/**\n *\n * @param {string} url Fetch URL.\n * @param {Request} options Fetch options.\n * @param {string} returnType Simplified type name the data should be converted to.\n * @returns {Promise<any>} Resulting data.\n */\nexport const getFromCache = (\n  url,\n  options,\n  returnType,\n) => new Promise((\n  resolve,\n  reject,\n) => {\n  if (!options.method || String.prototype.toUpperCase.call(options.method) === 'GET') {\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        cache.match(url)\n          .then(cachedResponse => {\n            if (cachedResponse) {\n              if (validCacheFromHeaders(cachedResponse.headers)\n              ) {\n                // Automatically base return type on header.\n                if (returnType === 'auto') {\n                  returnType = responseType(cachedResponse, options)\n                }\n                // Parse response based on return type.\n                if (returnType) {\n                  cachedResponse = parseResponse(cachedResponse, returnType)\n                }\n                cachedResponse\n                  .then((cachedResponseValue) => {\n                    resolve({\n                      headers: cachedResponse.headers,\n                      value: cachedResponseValue,\n                    })\n                  })\n                return\n              }\n              cache.delete(url)\n            }\n\n            // Check if the request is already being fetched. If so listen for the results on that.\n            if (Object.prototype.hasOwnProperty.call(cacheListeners, url.location)) {\n              cacheListeners[url.location].push({\n                resolve,\n                reject,\n              })\n              return\n            } else {\n              cacheListeners[url.location] = []\n            }\n\n            fetch(url, options)\n              .then((response) => {\n                if (\n                  response.status < 200 ||\n                  response.status >= 500\n                ) {\n                  const listeners = cacheListeners[url.location]\n                  delete cacheListeners[url.location]\n\n                  reject(response)\n\n                  // Reject other listeners as well.\n                  for (const listener of listeners) {\n                    listener.reject(response)\n                  }\n                  return\n                }\n\n                // Check if the request can be cached.\n                let allowCache = true\n                if (response.headers.has(HEADER_CACHE_CONTROL)) {\n                  const cacheControl = response.headers.get(HEADER_CACHE_CONTROL).split(',')\n                  let maxAge = 0\n                  for (const cacheControlItem of cacheControl) {\n                    const cacheClause = cacheControlItem.trim()\n\n                    if (CACHE_INVALIDATION_CLAUSES.indexOf(cacheClause) >= 0) {\n                      allowCache = false\n                      break\n                    }\n\n                    if (cacheClause.startsWith('s-maxage=')) {\n                      maxAge = parseInt(cacheClause.split('=')[1].trim(), 10)\n                      if (maxAge <= 0) {\n                        allowCache = false\n                        break\n                      }\n                    }\n\n                    if (\n                      cacheClause.startsWith('max-age=') &&\n                      maxAge <= 0 // Prevent override of s-maxage.\n                    ) {\n                      maxAge = parseInt(cacheClause.split('=')[1].trim(), 10)\n                      if (maxAge <= 0) {\n                        allowCache = false\n                        break\n                      }\n                    }\n                  }\n                }\n\n                // Update cache.\n                if (allowCache) {\n                  cache.put(url, response.clone())\n                } else {\n                  cache.delete(url)\n                }\n\n                // Automatically base return type on header.\n                if (returnType === 'auto') {\n                  returnType = responseType(response, options)\n                }\n                // Parse response based on return type.\n                if (returnType) {\n                  response = parseResponse(response, returnType)\n                }\n                response\n                  .then((responseValue) => {\n                    // Add response to cache.\n                    const result = {\n                      headers: response.headers,\n                      value: responseValue,\n                    }\n\n                    // Get other listeners.\n                    const listeners = cacheListeners[url.location]\n                    delete cacheListeners[url.location]\n\n                    // Resolve promise.\n                    resolve(result)\n\n                    // Inform listeners of update.\n                    if (listeners) {\n                      for (const listener of listeners) {\n                        listener.resolve(result)\n                      }\n                    }\n                  })\n                  .catch((error) => {\n                    // Get other listeners.\n                    const listeners = cacheListeners[url.location]\n                    delete cacheListeners[url.location]\n\n                    // Reject promise.\n                    reject(error)\n\n                    // Inform listeners of update.\n                    if (listeners) {\n                      for (const listener of listeners) {\n                        listener.reject(error)\n                      }\n                    }\n                  })\n              })\n              .catch((error) => {\n                // Get other listeners.\n                const listeners = cacheListeners[url.location]\n                delete cacheListeners[url.location]\n\n                // Reject promise.\n                reject(error)\n\n                // Inform listeners of update.\n                if (listeners) {\n                  for (const listener of listeners) {\n                    listener.reject(error)\n                  }\n                }\n              })\n          })\n          .catch(reject)\n      })\n      .catch(reject)\n    return\n  }\n\n  fetch(url, options)\n    .then((response) => {\n      if (\n        response.status < 200 ||\n        response.status >= 500\n      ) {\n        const listeners = cacheListeners[url.location]\n        delete cacheListeners[url.location]\n\n        reject(response)\n\n        // Reject other listeners as well.\n        for (const listener of listeners) {\n          listener.reject(response)\n        }\n        return\n      }\n\n      // Automatically base return type on header.\n      if (returnType === 'auto') {\n        returnType = responseType(response, options)\n      }\n      // Parse response based on return type.\n      if (returnType) {\n        response = parseResponse(response, returnType)\n      }\n      response\n        .then((responseValue) => {\n          // Add response to cache.\n          const result = {\n            headers: response.headers,\n            value: responseValue,\n          }\n\n          // Get other listeners.\n          const listeners = cacheListeners[url.location]\n          delete cacheListeners[url.location]\n\n          // Resolve promise.\n          resolve(result)\n\n          // Inform listeners of update.\n          if (listeners) {\n            for (const listener of listeners) {\n              listener.resolve(result)\n            }\n          }\n        })\n        .catch((error) => {\n          // Get other listeners.\n          const listeners = cacheListeners[url.location]\n          delete cacheListeners[url.location]\n\n          // Reject promise.\n          reject(error)\n\n          // Inform listeners of update.\n          if (listeners) {\n            for (const listener of listeners) {\n              listener.reject(error)\n            }\n          }\n        })\n    })\n    .catch((error) => {\n      // Get other listeners.\n      const listeners = cacheListeners[url.location]\n      delete cacheListeners[url.location]\n\n      // Reject promise.\n      reject(error)\n\n      // Inform listeners of update.\n      if (listeners) {\n        for (const listener of listeners) {\n          listener.reject(error)\n        }\n      }\n    })\n})\n\nexport const removeFromCache = (\n  url,\n) => caches.open(CACHE_NAME)\n  .then(cache => {\n    cache.delete(url)\n  })\n  .catch()\n\nexport const startCacheCleaner = (\n) => {\n  // Exit early if a cache clearer is already set.\n  if (cacheCleanCounter > 0) {\n    cacheCleanCounter++\n    return\n  }\n\n  // Every x amount of seconds remove stale items from the cache, therefore reducing the memory footprint of the plugin.\n  cacheCleanInterval = setInterval(() => {\n    caches.open(CACHE_NAME)\n      .then(cache => {\n        cache.keys()\n          .then(cacheKeys => {\n            for (const cacheKey of cacheKeys) {\n              cache.match(cacheKey)\n                .then(cachedResponse => {\n                  if (!validCacheFromHeaders(cachedResponse.headers)) {\n                    cache.delete(cacheKey)\n                  }\n                })\n            }\n          })\n      })\n  }, CACHE_CLEAN_INTERVAL)\n}\n\nexport const stopCacheCleaner = (\n) => {\n  cacheCleanCounter--\n  if (\n    cacheCleanCounter <= 0 &&\n    cacheCleanInterval\n  ) {\n    clearInterval(cacheCleanInterval)\n  }\n}\n\nexport default {\n  getFromCache,\n  removeFromCache,\n  startCacheCleaner,\n  stopCacheCleaner,\n  validCacheFromHeaders,\n}\n", "/**\n * Deeply assign a series of objects properties together.\n * @param {object} target Target object to merge to.\n * @param {...object} sources Objects to merge into the target.\n * @returns {object} Merged resulting object.\n */\nexport const deepAssign = (\n  target,\n  ...sources\n) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {object} object Object to get from.\n * @param  {Array<string>} path Path to value.\n * @returns {any} value at path.\n */\nexport const getDeeply = (\n  object,\n  path,\n) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {any} value Value of unknown type.\n * @returns {boolean} Whether the value is an object.\n */\nexport const isObject = (\n  value,\n) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {object} object Object to set on.\n * @param {Array<string>} path Path to value.\n * @param {any} value Value to set.\n */\nexport const setDeeply = (\n  object,\n  path,\n  value,\n) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n", "// Import utilities.\nimport {\n  getFromCache,\n} from '@doars/common/src/utilities/Cache.js'\nimport {\n  parseResponse,\n  responseType,\n} from '@doars/common/src/utilities/Fetch.js'\nimport { deepAssign } from '@doars/common/src/utilities/Object.js'\n\nexport default ({\n  fetchContextName,\n  fetchOptions,\n}) => ({\n  name: fetchContextName,\n\n  create: (\n  ) => {\n    return {\n      value: (\n        url,\n        options = null,\n      ) => {\n        // Apply default options to init.\n        if (fetchOptions) {\n          options = deepAssign({}, fetchOptions, options)\n        }\n\n        // Extract optional return type.\n        let returnType = options.returnType ? options.returnType : null\n        delete options.returnType\n\n        // Perform and process fetch request.\n        if (\n          !options.method ||\n          String.prototype.toUpperCase.call(options.method) === 'GET'\n        ) {\n          return getFromCache(\n            url,\n            options,\n            responseType,\n          )\n            .then((result) => {\n              if (result && result.value) {\n                return result.value\n              }\n            })\n        } else {\n          return fetch(\n            url,\n            options,\n          )\n            .then((\n              response,\n            ) => {\n              // Automatically base return type on header.\n              if (returnType === 'auto') {\n                returnType = responseType(response, options)\n              }\n              // Parse response based on return type.\n              if (returnType) {\n                response = parseResponse(response, returnType)\n              }\n              return response\n            })\n        }\n      },\n    }\n  },\n})\n", "/**\n * Convert string to HTML element.\n * @param {string} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const stringStart = string.substring(0, 15).toLowerCase()\n  const isDocument = (\n    stringStart.startsWith('<!doctype html>') ||\n    stringStart.startsWith('<html>')\n  )\n  if (isDocument) {\n    const html = document.createElement('html')\n    html.innerHTML = string\n    return html\n  }\n\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after().\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (\n  reference,\n  node,\n) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Inserts an element before the reference element,\n * @param {HTMLElement} reference Node to insert before.\n * @param {Node} node Node to insert.\n */\nexport const insertBefore = (\n  reference,\n  node,\n) => {\n  reference.parentNode.insertBefore(reference, node)\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMLElement} a A node.\n * @param {HTMLElement} b Another node.\n * @returns {boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (a.isSameNode && a.isSameNode(b)) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * @callback WalkIterate Returns a new child element or null when all items have been iterated on.\n * @returns {HTMLElement|null}\n */\n\n/**\n * @callback WalkFilter Filter function that takes in an element and return true if the element needs to be walked and false when it needs to be skipped.\n * @param {HTMLElement} element Element to decide on.\n * @returns {boolean}\n */\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {WalkFilter} filter Filter function, return false to skip element.\n * @returns {WalkIterate} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  element,\n  filter,\n) => {\n  let index = -1\n  /** @type {null|WalkIterate} */\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n", "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {string} text String to escape.\n * @returns {string} Escaped string.\n */\nexport const escapeHtml = (\n  text,\n) => {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\\\'/g, '\\\\\\'')\n    .replace(/\\\\\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n}\n\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {string} text String to modify.\n * @returns {string} Converted string.\n */\nexport const kebabToCamel = (\n  text,\n) => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase())\n}\n\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<string>} modifiers List of modifiers to parse.\n * @returns {object} Parsed modifiers.\n */\nexport const parseAttributeModifiers = (\n  modifiers,\n) => {\n  const result = {}\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-')\n\n    // If no hyphen then set the modifiers to true.\n    if (hyphenIndex < 0) {\n      result[modifier] = true\n      continue\n    }\n\n    // If it starts with hyphen then set the modifier to false.\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false\n      continue\n    }\n\n    // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n    const key = modifier.substring(0, hyphenIndex)\n    let value = modifier.substring(hyphenIndex + 1)\n\n    let tmpValue = value\n\n    // Try to remove time suffixes.\n    let type\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2)\n    } else if (value.endsWith('s')) {\n      type = 's'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('m')) {\n      type = 'm'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('h')) {\n      type = 'h'\n      tmpValue = value.substring(-1)\n    }\n\n    // Try to parse the value as a number.\n    tmpValue = Number.parseInt(tmpValue)\n    if (!isNaN(tmpValue)) {\n      value = tmpValue\n\n      // Convert to milliseconds if given in a different format.\n      switch (type) {\n        case 'h':\n          value *= 60\n        case 'm':\n          value *= 60\n        case 's':\n          value *= 1000\n          break\n      }\n    }\n\n    // Store modifier data.\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {string} prefix Directive prefix.\n * @param {string} name Name to parse.\n * @returns {Array<string> | undefined} list of segments.\n */\nexport const parseAttributeName = (\n  prefix,\n  name,\n) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'))\n  if (!name) {\n    return\n  }\n  // Deconstruct match.\n  let [full, directive, keyRaw, modifiers] = name // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n  keyRaw = keyRaw !== '' ? keyRaw : null\n  const key = keyRaw ? kebabToCamel(keyRaw) : null\n  // Ensure modifiers is and array.\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []\n  // Return result a single array.\n  return [directive, keyRaw, key, modifiers]\n}\n\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n * @param {string} expression For expression to parse.\n * @returns {object | undefined} Iterable type and variables.\n */\nexport const parseForExpression = (\n  expression,\n) => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i)\n  if (!match) {\n    return\n  }\n\n  // Remove parenthesis.\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, '')\n  // Parse for variables.\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i)\n  if (!variables) {\n    return\n  }\n  variables.shift()\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables], // Convert it to an array instead of a regular expression match.\n  }\n}\n\n/**\n * Parse selector to an attributes object.\n * @param {string} selector Selector to parse.\n * @returns {object | undefined} Attributes. Do note the class property is a list of strings not a single string.\n */\nexport const parseSelector = (\n  selector,\n) => {\n  // Convert to array.\n  if (typeof (selector) === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/)\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.')\n    return\n  }\n\n  const attributes = {}\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim()\n\n    // Base what to do of the leading character.\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1)\n        break\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1)\n        // Add to classlist.\n        if (!attributes.class) {\n          attributes.class = []\n        }\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment)\n        }\n        break\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i) // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n        attributes[key] = value\n        break\n    }\n  }\n  return attributes\n}\n\nexport default {\n  escapeHtml,\n  kebabToCamel,\n  parseAttributeModifiers,\n  parseAttributeName,\n  parseForExpression,\n  parseSelector,\n}\n", "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "// Import utilities.\nimport { parseSelector } from './String.js'\nimport { addAttributes, removeAttributes } from './Attribute.js'\n\n// Transition name.\nconst TRANSITION_NAME = '-transition:'\n\n/**\n * @callback TransitionEnd\n */\n\n/**\n * Transition an element.\n * @param {string} type Type of transition, for example 'in' and 'out'.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transition = (\n  type,\n  libraryOptions,\n  element,\n  callback = null,\n) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback()\n    }\n    return\n  }\n\n  // Transition attribute name.\n  const transitionDirectiveName = libraryOptions.prefix + TRANSITION_NAME + type\n\n  // Setup dispatcher function.\n  const dispatchEvent = (phase) => {\n    element.dispatchEvent(\n      new CustomEvent('transition-' + phase),\n    )\n    element.dispatchEvent(\n      new CustomEvent('transition-' + type + '-' + phase),\n    )\n  }\n\n  // Declare variables for later.\n  let name, value, timeout, requestFrame\n  let isDone = false\n  const selectors = {}\n\n  // Process transition during attribute.\n  name = transitionDirectiveName\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.during = parseSelector(value)\n    addAttributes(element, selectors.during)\n  }\n\n  // Process transition from attribute.\n  name = transitionDirectiveName + '.from'\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.from = parseSelector(value)\n    addAttributes(element, selectors.from)\n  }\n\n  // Dispatch transition event.\n  dispatchEvent('start')\n\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null\n\n    // If cancelled then stop immediately.\n    if (isDone) {\n      return\n    }\n\n    // Remove from selector.\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    }\n\n    // Process transition to attribute.\n    name = transitionDirectiveName + '.to'\n    value = element.getAttribute(name)\n    // Parse and apply returned selector.\n    if (value) {\n      selectors.to = parseSelector(value)\n      addAttributes(element, selectors.to)\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n      return\n    }\n\n    // Get computes style.\n    const styles = getComputedStyle(element)\n\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null\n\n      // If cancelled then stop immediately.\n      if (isDone) {\n        return\n      }\n\n      // Remove during selector.\n      if (selectors.during) {\n        removeAttributes(element, selectors.during)\n        selectors.during = undefined\n      }\n\n      // Remove to selector.\n      if (selectors.to) {\n        removeAttributes(element, selectors.to)\n        selectors.to = undefined\n      }\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n    }, duration)\n  })\n\n  return (\n  ) => {\n    if (!isDone) {\n      return\n    }\n    isDone = true\n\n    // Remove applied selector.\n    if (selectors.during) {\n      removeAttributes(element, selectors.during)\n      selectors.during = undefined\n    }\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to)\n      selectors.to = undefined\n    }\n\n    // Clear request animation frame and timeout.\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame)\n      requestFrame = null\n    } else if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    // Dispatch end event.\n    dispatchEvent('end')\n    // Invoke callback.\n    if (callback) {\n      callback()\n    }\n  }\n}\n\n/**\n * Transition an element in.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionIn = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('in', libraryOptions, element, callback)\n}\n\n/**\n * Transition an element out.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionOut = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('out', libraryOptions, element, callback)\n}\n\nexport default {\n  transition,\n  transitionIn,\n  transitionOut,\n}\n", "import { insertAfter } from './Element.js'\nimport {\n  transitionIn,\n  transitionOut,\n} from './Transition.js'\n\n/**\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').ProcessExpression} ProcessExpression\n */\n\n/**\n * Hides the indicator.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @returns {void}\n */\nexport const hideIndicator = (\n  component,\n  attribute,\n) => {\n  // Check if a indicator exists.\n  if (!attribute.indicator) {\n    return\n  }\n  // Check if not already transitioning out.\n  if (attribute.indicator.indicatorTransitionOut) {\n    return\n  }\n  // Check if a indicator element exists.\n  if (!attribute.indicator.indicatorElement) {\n    return\n  }\n\n  const libraryOptions = component.getLibrary().getOptions()\n\n  // Transition element in.\n  const indicatorElement = attribute.indicator.indicatorElement\n  attribute.indicator.indicatorTransitionIn =\n    transitionOut(libraryOptions, indicatorElement, () => {\n      if (indicatorElement) {\n        indicatorElement.remove()\n      }\n    })\n}\n\n/**\n * Shows the indicator.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {ProcessExpression} processExpression Function to process an expression with.\n * @returns {void}\n */\nexport const showIndicator = (\n  component,\n  attribute,\n  processExpression,\n) => {\n  const libraryOptions = component.getLibrary().getOptions()\n  const element = attribute.getElement()\n  const directive = attribute.getDirective()\n\n  const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.indicatorDirectiveName\n  if (!element.hasAttribute(attributeName)) {\n    return\n  }\n  let indicatorTemplate = null\n  if (libraryOptions.indicatorDirectiveEvaluate) {\n    indicatorTemplate = processExpression(\n      component,\n      attribute,\n      element.getAttribute(attributeName),\n    )\n  } else {\n    indicatorTemplate = element.getAttribute(attributeName)\n  }\n  if (!indicatorTemplate) {\n    return\n  }\n  if (typeof (indicatorTemplate) === 'string') {\n    indicatorTemplate = element.querySelector(indicatorTemplate)\n    if (!indicatorTemplate) {\n      return\n    }\n  }\n\n  // Check if placed on a template tag.\n  if (indicatorTemplate.tagName !== 'TEMPLATE') {\n    console.warn('Doars: `' + attributeName + '` must be placed on a `<template>`.')\n    return\n  }\n  if (indicatorTemplate.childCount > 1) {\n    console.warn('Doars: `' + attributeName + '` must have one child.')\n    return\n  }\n\n  // Cancel current transition.\n  if (attribute.indicator) {\n    if (attribute.indicator.indicatorTransitionOut) {\n      attribute.indicator.indicatorTransitionOut()\n      attribute.indicator.indicatorTransitionOut = null\n    } else if (attribute.indicator.indicatorElement) {\n      return\n    }\n  }\n\n  // Create new element from template.\n  let indicatorElement = document.importNode(indicatorTemplate.content, true)\n  // Add element after the template element.\n  insertAfter(indicatorTemplate, indicatorElement)\n  // Get HTMLElement reference instead of DocumentFragment.\n  indicatorElement = indicatorTemplate.nextElementSibling\n  attribute.indicator = {\n    indicatorElement,\n    // Transition element in.\n    indicatorTransitionIn: transitionIn(libraryOptions, indicatorElement),\n  }\n}\n\nexport default {\n  hideIndicator,\n  showIndicator,\n}\n", "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame,\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement | string} newTree The tree to change to.\n * @param {object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the initial value. Changing the \"value\" attribute without changing the \"value\" property will have no effect since it is only used to the set the initial value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n * @param {string} name Name of the attribute.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop.\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing.\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old.\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new.\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild)\n      offset++\n\n      // Both nodes are the same, morph.\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder.\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree.\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list.\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID.\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node.\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (\n  value,\n) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (\n  value,\n) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n", "import { walk } from './Element.js'\n\n/**\n * Re-adds a script to the document in order to trigger it again.\n * @param {HTMLElement} element Script to re-add to the DOM.\n * @returns {void}\n */\nconst _readdScript = (\n  element,\n) => {\n  // Check if element is a script without a source.\n  if (\n    element.tagName !== 'SCRIPT' ||\n    element.hasAttribute('src')\n  ) {\n    return false\n  }\n\n  // Set up new script with same content.\n  const newScript = document.createElement('script')\n  newScript.innerText = element.innerText\n\n  // Replace script in the document.\n  element.parentNode.insertBefore(\n    newScript,\n    element,\n  )\n  element.remove()\n  return true\n}\n\n/**\n * Checks the elements for scripts and re-adds these to the DOM.\n * @param  {...HTMLElement} elements Elements to check for scripts.\n * @returns {void}\n */\nexport const readdScripts = (\n  ...elements\n) => {\n  for (const element of elements) {\n    // Try to re-add element in case it is a script.\n    if (!_readdScript(element)) {\n      // Otherwise check its children.\n      const iterate = walk(element)\n      let maybeScript = null\n      while (maybeScript = iterate()) {\n        _readdScript(maybeScript)\n      }\n    }\n  }\n}\n\nexport default {\n  readdScripts,\n}\n", "/**\n * Convert a form data object to XML.\n * @param {FormData} formData Data to serialize.\n * @returns {string} Serialized form data.\n */\nexport const serializeFormData = (\n  formData,\n) => {\n  const xml = document.createElement('xml')\n\n  formData.forEach((value, key) => {\n    const element = document.createElement(key)\n    element.textContent = value\n    xml.appendChild(element)\n  })\n\n  const serializer = new XMLSerializer()\n  return serializer.serializeToString(xml)\n}\n\nexport default {\n  serializeFormData,\n}\n", "/**\n * @typedef {import('@doars/doars').default} Doars\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').Directive} Directive\n * @typedef {import('@doars/doars/src/Directive.js').DirectiveUtilities} DirectiveUtilities\n */\n\n// Import utilities.\nimport {\n  getFromCache,\n  startCacheCleaner,\n  stopCacheCleaner,\n} from '@doars/common/src/utilities/Cache.js'\nimport {\n  fromString as elementFromString,\n  insertAfter,\n  insertBefore,\n} from '@doars/common/src/utilities/Element'\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport {\n  hideIndicator,\n  showIndicator,\n} from '@doars/common/src/utilities/Indicator.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\nimport { isPromise } from '@doars/common/src/utilities/Promise'\nimport { readdScripts } from '@doars/common/src/utilities/Script'\n\nimport { serializeFormData } from '../utilities/Xml'\n\nconst FETCH = Symbol('FETCH')\n\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 5,\n}\n\n/**\n * @typedef DirectiveOptions\n * @type {object}\n * @property {object} fetchOptions Object of options given to the fetch method when submitting data.\n * @property {string} headerTitle Name of the header that can contain a new document title.\n */\n\n/**\n * @param {DirectiveOptions} options Options used for creating the directive.\n * @returns {Directive} Created fetch directive.\n */\nexport default ({\n  fetchOptions,\n  fetchDirectiveEvaluate,\n  fetchDirectiveName,\n}) => ({\n  name: fetchDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Destruct component.\n    const library = component.getLibrary()\n    const libraryOptions = library.getOptions()\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    const directive = attribute.getDirective()\n    const modifiers = attribute.getModifiers()\n    const value = attribute.getValue()\n\n    // Handle forms differently since the form values need to be used.\n    const isForm = element.tagName === 'FORM'\n    const isButton = element.tagName === 'BUTTON'\n\n    // Check if existing listener exists.\n    if (attribute[FETCH]) {\n      // Exit early if value has not changed.\n      if (attribute[FETCH].value === value) {\n        return\n      }\n\n      // Remove existing listener so we don't listen twice.\n      attribute[FETCH].target.removeEventListener(\n        attribute[FETCH].eventName,\n        attribute[FETCH].handler,\n      )\n\n      // Clear any ongoing timeouts.\n      if (attribute[FETCH].timeout) {\n        clearTimeout(attribute[FETCH].timeout)\n      }\n\n      // Delete directive data.\n      delete attribute[FETCH]\n    }\n\n    // Process modifiers.\n\n    let eventName = isForm ? 'submit' : 'click'\n    if (modifiers.on) {\n      eventName = modifiers.on\n    }\n    const encoding = (modifiers.encoding ? modifiers.encoding.toLowerCase() : 'urlencoded')\n    const method = (modifiers.method ? modifiers.method.toUpperCase() : 'GET')\n    const position = (modifiers.position ? modifiers.position.toLowerCase() : null)\n\n    // Set listener options.\n    const listenerOptions = {}\n    if (modifiers.capture) {\n      listenerOptions.capture = true\n    }\n    if (modifiers.once) {\n      listenerOptions.once = true\n    }\n    if (modifiers.passive && !modifiers.prevent) {\n      listenerOptions.passive = true\n    }\n\n    // Process execution modifiers.\n    let executionModifier = EXECUTION_MODIFIERS.NONE\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500\n      }\n    }\n\n    const fetchHeaders = {\n      [libraryOptions.prefix + '-' + libraryOptions.requestHeaderName]: directive,\n      Vary: libraryOptions.prefix + '-' + libraryOptions.requestHeaderName,\n    }\n\n    const dispatchEvent = (\n      suffix = '',\n      data = {},\n    ) => {\n      element.dispatchEvent(\n        new CustomEvent(\n          libraryOptions.prefix + '-' + directive + suffix,\n          {\n            detail: Object.assign({\n              attribute,\n              component,\n            }, data),\n          },\n        ),\n      )\n    }\n\n    /**\n     * Perform a request.\n     * @param {URL} url URL of the request to perform.\n     * @returns {void}\n     */\n    const requestHandler = (\n      url,\n    ) => {\n      /** @type {Request} */\n      const _fetchOptions = {\n        headers: {},\n      }\n\n      if (method) {\n        _fetchOptions.method = method\n      } else if (isForm && element.hasAttribute('method')) {\n        _fetchOptions.method = element.getAttribute('method').toUpperCase()\n      }\n\n      if (isForm) {\n        const formData = new FormData(element)\n        let _encoding = encoding\n        if (\n          !_encoding &&\n          element.hasAttribute('enctype')\n        ) {\n          _encoding = element.getAttribute('enctype').toLowerCase()\n        }\n        if (\n          _fetchOptions.method === 'HEAD' ||\n          _fetchOptions.method === 'GET'\n        ) {\n          _encoding = 'parameters'\n        }\n\n        switch (_encoding) {\n          case 'json':\n            _fetchOptions.headers['Content-Type'] = 'application/json; charset=UTF-8'\n            _fetchOptions.body = JSON.stringify(Object.fromEntries(formData))\n            break\n\n          case 'multipart':\n          case 'multipart/form-data':\n            _fetchOptions.headers['Content-Type'] = 'multipart/form-data'\n            _fetchOptions.body = formData\n            break\n\n          case 'parameters':\n            const parameters = new URLSearchParams(formData).toString()\n            for (const [parameterName, parameterValue] of parameters) {\n              url.searchParams.set(parameterName, parameterValue)\n            }\n            break\n\n          case 'urlencoded':\n          case 'application/x-www-form-urlencoded':\n            _fetchOptions.headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=UTF-8'\n            _fetchOptions.body = new URLSearchParams(formData).toString()\n            break\n\n          case 'xml':\n            _fetchOptions.headers['Content-Type'] = 'application/xml; charset=UTF-8'\n            _fetchOptions.body = serializeFormData(formData)\n            break\n\n          default:\n            console.warn('DoarsFetch: \"' + directive + '\" directive\\'s invalid encoding type \"' + _encoding + '\".')\n            break\n        }\n      }\n\n      dispatchEvent('-started', {\n        url,\n      })\n\n      getFromCache(\n        url,\n        Object.assign({}, fetchOptions, _fetchOptions, {\n          headers: Object.assign({}, _fetchOptions.headers, fetchHeaders),\n        }),\n      )\n        .then((result) => {\n          isLoading = false\n\n          // Decode string.\n          let html = result.value\n          if (modifiers.decode) {\n            html = decode(result.value)\n          }\n\n          /** @type {HTMLElement | null} */\n          let target = null\n          if (modifiers.document) {\n            target = document.documentElement\n          } else {\n            const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.targetDirectiveName\n            if (element.getAttribute(attributeName)) {\n              if (libraryOptions.targetDirectiveEvaluate) {\n                target = processExpression(\n                  component,\n                  attribute,\n                  element.getAttribute(attributeName),\n                )\n              } else {\n                target = element.getAttribute(attributeName)\n              }\n              if (target && typeof (target) === 'string') {\n                target = element.querySelector(target)\n              }\n            }\n            if (!target) {\n              target = element\n            }\n          }\n\n          // Update target.\n          if (position === 'append') {\n            const child = elementFromString(html)\n            target.appendChild(child)\n            if (libraryOptions.allowInlineScript || modifiers.script) {\n              readdScripts(child)\n            }\n          } else if (position === 'prepend') {\n            const child = elementFromString(html)\n            target.prepend(child)\n            if (libraryOptions.allowInlineScript || modifiers.script) {\n              readdScripts(child)\n            }\n          } else if (position === 'after') {\n            const child = elementFromString(html)\n            insertAfter(target, child)\n            if (libraryOptions.allowInlineScript || modifiers.script) {\n              readdScripts(child)\n            }\n          } else if (position === 'before') {\n            const child = elementFromString(html)\n            insertBefore(target, child)\n            if (libraryOptions.allowInlineScript || modifiers.script) {\n              readdScripts(child)\n            }\n          } else if (position === 'outer') {\n            if (modifiers.morph) {\n              morphTree(target, html)\n            } else if (target.outerHTML !== html) {\n              target.outerHTML = html\n              if (libraryOptions.allowInlineScript || modifiers.script) {\n                readdScripts(target)\n              }\n            }\n          } else if (modifiers.morph) {\n            // Ensure element only has one child.\n            if (target.children.length === 0) {\n              target.appendChild(document.createElement('div'))\n            } else if (target.children.length > 1) {\n              for (let i = target.children.length - 1; i >= 1; i--) {\n                target.children[i].remove()\n              }\n            }\n\n            // Morph first child to given target tree.\n            const root = morphTree(target.children[0], html)\n            if (!target.children[0].isSameNode(root)) {\n              target.children[0].remove()\n              target.appendChild(root)\n            }\n          } else if (target.innerHTML !== html) {\n            target.innerHTML = html\n            if (libraryOptions.allowInlineScript || modifiers.script) {\n              readdScripts(...target.children)\n            }\n          }\n\n          // Get new document link.\n          if (libraryOptions.redirectHeaderName && result.headers.has(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)) {\n            window.location.href = result.headers.get(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)\n            return\n          }\n\n          // Get new document title.\n          let documentTitle = ''\n          if (libraryOptions.titleHeaderName && result.headers.has(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)) {\n            documentTitle = result.headers.get(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)\n          }\n\n          // Update history api.\n          if (modifiers.document && modifiers.history) {\n            history.pushState({}, documentTitle, url)\n          }\n\n          // If document title was not updated via the history update, then set it now.\n          if (documentTitle && document.title !== documentTitle) {\n            document.title = documentTitle\n          }\n\n          hideIndicator(\n            component,\n            attribute,\n          )\n\n          dispatchEvent('-succeeded', {\n            url,\n          })\n        })\n        .catch(() => {\n          hideIndicator(\n            component,\n            attribute,\n          )\n\n          dispatchEvent('-failed', {\n            url,\n          })\n        })\n    }\n\n    let isLoading = false\n    /**\n     * Handles the interaction with a element containing the directive.\n     * @param {Event} event Document event to handle.\n     * @returns {void}\n     */\n    const handler = (\n      event,\n    ) => {\n      // Only fire when self is provided if the target is the element itself.\n      if (modifiers.self && event.target !== element) {\n        return\n      }\n\n      if (isForm && !element.reportValidity()) {\n        dispatchEvent('-invalid')\n        return\n      }\n\n      // Prevent the default event action.\n      if (\n        (isForm && eventName === 'submit') ||\n        (isButton && element.getAttribute('type', 'button') && eventName === 'click') ||\n        modifiers.prevent\n      ) {\n        event.preventDefault()\n      }\n      // Stop propagation if the stop modifier is present.\n      if (modifiers.stop) {\n        event.stopPropagation()\n      }\n\n      const execute = (\n      ) => {\n        let url = null\n        if (value && fetchDirectiveEvaluate) {\n          url = processExpression(\n            component,\n            attribute,\n            value,\n            {\n              $event: event,\n              $events: attribute[FETCH].buffer,\n            },\n          )\n        } else if (isForm && element.hasAttribute('action')) {\n          url = element.getAttribute('action')\n        }\n\n        // Reset the buffer.\n        attribute[FETCH].buffer = []\n\n        if (!url) {\n          return\n        }\n        isLoading = true\n\n        showIndicator(\n          component,\n          attribute,\n          processExpression,\n        )\n\n        if (isPromise(url)) {\n          url.then((url) => requestHandler(url))\n        } else {\n          requestHandler(url)\n        }\n      }\n\n      if (isLoading) {\n        return\n      }\n\n      // Store event in buffer.\n      attribute[FETCH].buffer.push(event)\n\n      // Check if we need to apply an execution modifier.\n      switch (executionModifier) {\n        case EXECUTION_MODIFIERS.BUFFER:\n          // Exit early if buffer is not full.\n          if (attribute[FETCH].buffer.length < modifiers.buffer) {\n            return\n          }\n\n          execute()\n          return\n\n        case EXECUTION_MODIFIERS.DEBOUNCE:\n          // Clear existing timeout.\n          if (attribute[FETCH].timeout) {\n            clearTimeout(attribute[FETCH].timeout)\n            attribute[FETCH].timeout = null\n          }\n\n          // Setup timeout and execute expression when it finishes.\n          attribute[FETCH].timeout = setTimeout(execute, modifiers.debounce)\n          return\n\n        case EXECUTION_MODIFIERS.THROTTLE:\n          // Get current time in milliseconds.\n          const nowThrottle = window.performance.now()\n\n          // Exit early if throttle time has not passed.\n          if (attribute[FETCH].lastExecution && nowThrottle - attribute[FETCH].lastExecution < modifiers.throttle) {\n            return\n          }\n\n          execute()\n\n          // Store new latest execution time.\n          attribute[FETCH].lastExecution = nowThrottle\n          return\n      }\n\n      // Otherwise execute expression immediately.\n      execute()\n    }\n\n    element.addEventListener(\n      eventName,\n      handler,\n      listenerOptions,\n    )\n\n    startCacheCleaner()\n\n    attribute[FETCH] = {\n      buffer: [],\n      eventName,\n      handler,\n      target: element,\n      timeout: attribute[FETCH] ? attribute[FETCH].timeout : undefined,\n      value,\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Exit early if no listeners can be found.\n    if (!attribute[FETCH]) {\n      return\n    }\n\n    stopCacheCleaner()\n\n    // Remove existing listener.\n    attribute[FETCH].target.removeEventListener(\n      attribute[FETCH].eventName,\n      attribute[FETCH].handler,\n    )\n    // Clear any ongoing timeouts.\n    if (attribute[FETCH].timeout) {\n      clearTimeout(attribute[FETCH].timeout)\n    }\n\n    hideIndicator(\n      component,\n      attribute,\n    )\n\n    // Delete directive data.\n    delete attribute[FETCH]\n  },\n})\n", "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport createFetchContext from './contexts/fetch.js'\nimport createFetchDirective from './directives/fetch.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    fetchContextName: '$fetch',\n    fetchDirectiveEvaluate: true,\n    fetchDirectiveName: 'fetch',\n    fetchOptions: {},\n  }, options)\n  if (options.defaultInit) {\n    Object.assign(options.fetchOptions, options.defaultInit)\n  }\n\n  // Set private variables.\n  let isEnabled = false\n  // Store contexts and directives.\n  const fetchContext = createFetchContext(options),\n    fetchDirective = createFetchDirective(options)\n\n  const onEnable = (\n  ) => {\n    // Create and add contexts and directives.\n    library.addContexts(0, fetchContext)\n    library.addDirectives(-1, fetchDirective)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(fetchContext)\n    library.removeDirective(fetchDirective)\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"],
  "mappings": "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",
  "names": ["parseResponse", "response", "type", "promise", "template", "responseType", "request", "contentType", "result", "simplifyType", "extension", "acceptTypes", "acceptType", "mimeType", "HEADER_DATE", "HEADER_CACHE_CONTROL", "CACHE_CLEAN_INTERVAL", "CACHE_INVALIDATION_CLAUSES", "CACHE_NAME", "cacheCleanCounter", "cacheCleanInterval", "cacheListeners", "validCacheFromHeaders", "headers", "cacheDate", "currentDate", "cacheControl", "cacheMaxAge", "cacheControlItem", "getFromCache", "url", "options", "returnType", "resolve", "reject", "cache", "cachedResponse", "responseType", "parseResponse", "cachedResponseValue", "response", "listeners", "listener", "allowCache", "maxAge", "cacheClause", "responseValue", "result", "error", "startCacheCleaner", "cacheCleanCounter", "cacheCleanInterval", "CACHE_NAME", "cache", "cacheKeys", "cacheKey", "cachedResponse", "validCacheFromHeaders", "CACHE_CLEAN_INTERVAL", "stopCacheCleaner", "deepAssign", "target", "sources", "source", "isObject", "key", "value", "isObject", "value", "fetch_default", "fetchContextName", "fetchOptions", "url", "options", "deepAssign", "returnType", "getFromCache", "responseType", "result", "response", "parseResponse", "fromString", "string", "stringStart", "html", "template", "insertAfter", "reference", "node", "insertBefore", "isSame", "a", "b", "walk", "element", "filter", "index", "iterator", "child", "DECODE_LOOKUP", "DECODE_REGEXP", "decode", "string", "DECODE_REGEXP", "character", "DECODE_LOOKUP", "parseSelector", "selector", "attributes", "selectorSegment", "full", "key", "value", "addAttributes", "element", "data", "name", "className", "copyAttributes", "existingNode", "newNode", "existingAttributes", "newAttributes", "attributeNamespaceURI", "attributeValue", "fromValue", "attributeName", "attribute", "i", "j", "removeAttributes", "TRANSITION_NAME", "transition", "type", "libraryOptions", "element", "callback", "transitionDirectiveName", "dispatchEvent", "phase", "name", "value", "timeout", "requestFrame", "isDone", "selectors", "parseSelector", "addAttributes", "removeAttributes", "styles", "duration", "transitionIn", "transitionOut", "hideIndicator", "component", "attribute", "libraryOptions", "indicatorElement", "transitionOut", "showIndicator", "processExpression", "element", "directive", "attributeName", "indicatorTemplate", "insertAfter", "transitionIn", "morphNode", "existingNode", "newNode", "nodeType", "nodeName", "copyAttributes", "_updateInput", "_updateAttribute", "_updateTextarea", "morphTree", "existingTree", "newTree", "options", "fromString", "_updateChildren", "_updateTree", "newValue", "existingValue", "name", "existingChild", "newChild", "morphed", "existingMatch", "offset", "i", "isSame", "j", "nativePromise", "isPromise", "value", "_readdScript", "element", "newScript", "readdScripts", "elements", "iterate", "walk", "maybeScript", "serializeFormData", "formData", "xml", "value", "key", "element", "FETCH", "EXECUTION_MODIFIERS", "fetch_default", "fetchOptions", "fetchDirectiveEvaluate", "fetchDirectiveName", "component", "attribute", "processExpression", "libraryOptions", "element", "directive", "modifiers", "value", "isForm", "isButton", "eventName", "encoding", "method", "position", "listenerOptions", "executionModifier", "fetchHeaders", "dispatchEvent", "suffix", "data", "requestHandler", "url", "_fetchOptions", "formData", "_encoding", "parameters", "parameterName", "parameterValue", "serializeFormData", "getFromCache", "result", "isLoading", "html", "decode", "target", "attributeName", "child", "fromString", "readdScripts", "insertAfter", "insertBefore", "morphTree", "i", "root", "documentTitle", "hideIndicator", "handler", "event", "execute", "showIndicator", "isPromise", "nowThrottle", "startCacheCleaner", "stopCacheCleaner", "DoarsFetch_default", "library", "options", "isEnabled", "fetchContext", "fetch_default", "fetchDirective", "onEnable", "onDisable"]
}
