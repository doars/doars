{
  "version": 3,
  "sources": ["../../common/src/utilities/Object.js", "../src/utilities/Fetch.js", "../src/factories/contexts/fetch.js", "../src/DoarsFetch.js"],
  "sourcesContent": ["/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (\n  target,\n  ...sources\n) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\nexport const getDeeply = (\n  object,\n  path,\n) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\nexport const isObject = (\n  value,\n) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\nexport const setDeeply = (\n  object,\n  path,\n  value,\n) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n", "export const parseResponse = (\n  response,\n  type,\n) => {\n  let promise\n  switch (String.prototype.toLowerCase.call(type)) {\n    default:\n      console.warn('Unknown response type \"' + type + '\" used when using the $fetch context.')\n      break\n\n    case 'arraybuffer':\n      promise = response.arrayBuffer()\n      break\n\n    case 'blob':\n      promise = response.blob()\n      break\n\n    case 'formdata':\n      promise = response.formData()\n      break\n\n    case 'json':\n      promise = response.json()\n      break\n\n    // HTML and xml need to be converted to text before being able to be parsed.\n    case 'element':\n    case 'html':\n    case 'svg':\n    case 'text':\n    case 'xml':\n      promise = response.text()\n      break\n  }\n\n  if (!promise) {\n    return null\n  }\n\n  return promise\n    .then((\n      response,\n    ) => {\n      switch (type) {\n        // Convert from html to HTMLElement inside a document fragment.\n        case 'element':\n          const template = document.createElement('template')\n          template.innerHTML = response\n          response = template.content.childNodes[0]\n          break\n\n        // Parse some values via the DOM parser.\n        case 'html':\n          response = (new DOMParser()).parseFromString(response, 'text/html')\n          break\n        case 'svg':\n          response = (new DOMParser()).parseFromString(response, 'image/svg+xml')\n          break\n        case 'xml':\n          response = (new DOMParser()).parseFromString(response, 'application/xml')\n          break\n      }\n\n      return response\n    })\n}\n\nexport const responseType = (\n  response,\n) => {\n  switch (String.prototype.toLowerCase(response.headers.get('content-type'))) {\n    case 'text/html':\n      return 'html'\n\n    case 'application/json':\n    case 'application/ld+json':\n    case 'application/vnd.api+json':\n      return 'json'\n\n    case 'image/svg+xml':\n      return 'svg'\n\n    case 'text/plain':\n      return 'text'\n\n    case 'application/xml':\n    case 'text/xml':\n      return 'xml'\n  }\n\n  return null\n}\n", "// Import utilities.\nimport { deepAssign } from '@doars/common/src/utilities/Object.js'\nimport { parseResponse, responseType } from '../../utilities/Fetch.js'\n\nexport default ({\n  fetchOptions,\n}) => ({\n  name: '$fetch',\n\n  create: (\n  ) => {\n    return {\n      value: (\n        url,\n        options = null,\n      ) => {\n        // Apply default options to init.\n        if (fetchOptions) {\n          options = deepAssign({}, fetchOptions, options)\n        }\n\n        // Extract optional return type.\n        let returnType = options.returnType ? options.returnType : null\n        delete options.returnType\n\n        // Perform and process fetch request.\n        return fetch(\n          url,\n          options,\n        )\n          .then((\n            response,\n          ) => {\n            // Automatically base return type on header.\n            if (returnType === 'auto' && response.headers.get('content-type')) {\n              returnType = responseType(response)\n            }\n\n            // Parse response based on return type.\n            if (returnType) {\n              response = parseResponse(response, returnType)\n            }\n\n            return response\n          })\n      },\n    }\n  },\n})\n", "// Import contexts.\nimport createFetchContext from './factories/contexts/fetch.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    fetchOptions: {},\n\n    encodingConverters: {\n      'application/json': () => { },\n      'application/x-www-form-urlencoded': () => { },\n      'multipart/formdata': () => { },\n    },\n  }, options)\n  if (options.defaultInit) {\n    Object.assign(options.fetchOptions, options.defaultInit)\n  }\n\n  // Set private variables.\n  let isEnabled = false\n  // Store contexts and directives.\n  let fetchContext\n\n  const onEnable = (\n  ) => {\n    // Create and add contexts and directives.\n    fetchContext = createFetchContext(options)\n    library.addContexts(0, fetchContext)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(fetchContext)\n    fetchContext = null\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"],
  "mappings": "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",
  "names": ["deepAssign", "target", "sources", "source", "isObject", "key", "value", "isObject", "value", "parseResponse", "response", "type", "promise", "template", "responseType", "fetch_default", "fetchOptions", "url", "options", "deepAssign", "returnType", "response", "responseType", "parseResponse", "DoarsFetch_default", "library", "options", "isEnabled", "fetchContext", "onEnable", "fetch_default", "onDisable"]
}
