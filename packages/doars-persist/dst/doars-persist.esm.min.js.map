{
  "version": 3,
  "sources": ["../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../../common/src/factories/createState.js", "../../common/src/factories/createStateContext.js", "../src/utilities/cookies.js", "../src/contexts/cookies.js", "../src/utilities/localStorage.js", "../src/contexts/localStorage.js", "../src/utilities/sessionStorage.js", "../src/contexts/sessionStorage.js", "../src/DoarsPersist.js"],
  "sourcesContent": [
    "/**\n * Function to call to revoke the proxy.\n * @callback RevocableProxyCallback\n */\n\n/**\n * @typedef RevocableProxy\n * @type {object}\n * @property {Proxy} proxy Proxy that will be revocable.\n * @property {RevocableProxyCallback} revoke Function to call to revoke the proxy.\n */\n\n/**\n * Function called when a proxy has been handled.\n * @callback ProxyHandlerCallback\n */\n\n/**\n * @typedef ProxyHandler\n * @type {object}\n * @property {?ProxyHandlerCallback} apply A trap method for a function call.\n * @property {?ProxyHandlerCallback} construct A trap for the `new` operator.\n * @property {?ProxyHandlerCallback} defineProperty A trap for `Object.defineProperty()`.\n * @property {?ProxyHandlerCallback} deleteProperty A trap for the `delete` operator.\n * @property {?ProxyHandlerCallback} get A trap for getting a property value.\n * @property {?ProxyHandlerCallback} getOwnPropertyDescriptor A trap for `Object.getOwnPropertyDescriptor()`.\n * @property {?ProxyHandlerCallback} getPrototypeOf A trap for the `[[GetPrototypeOf]]` internal method.\n * @property {?ProxyHandlerCallback} has A trap for the `in` operator.\n * @property {?ProxyHandlerCallback} isExtensible A trap for `Object.isExtensible()`.\n * @property {?ProxyHandlerCallback} ownKeys A trap for `Reflect.ownKeys()`.\n * @property {?ProxyHandlerCallback} preventExtensions A trap for `Object.preventExtensions()`.\n * @property {?ProxyHandlerCallback} set A trap for setting a property value.\n * @property {?ProxyHandlerCallback} setPrototypeOf A trap for `Object.setPrototypeOf()`.\n */\n\n// List of methods to revoke access to.\nconst PROXY_TRAPS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'has',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n * @param {object} target Object to proxy.\n * @param {ProxyHandler} handler Object of handler methods.\n * @returns {?RevocableProxy} Proxy object and revoke method.\n */\nexport default (\n  target,\n  handler,\n) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  /**\n   * Copy of allowed handlers with a revocable layer in between.\n   * @type {ProxyHandler}\n   */\n  const revocableHandler = {}\n  for (const key of PROXY_TRAPS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n",
    "/**\n * @typedef EventListenerOptions\n * @type {object}\n * @property {?boolean} once Whether to call the listener only once.\n */\n\n/**\n * @typedef DispatchEventOptions\n * @type {object}\n * @property {?boolean} reverse Whether to call the listeners in reverse order.\n */\n\nexport default class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor(\n  ) {\n    /**\n     * Object to store event listeners for the EventDispatcher class.\n     * @type {Record<string, Array<{callback: Function, options: EventListenerOptions }>>}\n     */\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {EventListenerOptions} options Callback options.\n     */\n    this.addEventListener = (\n      name,\n      callback,\n      options = null,\n    ) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (\n      name,\n      callback,\n    ) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {string} name Event name.\n     */\n    this.removeEventListeners = (\n      name,\n    ) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     */\n    this.removeAllEventListeners = (\n    ) => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {string} name Event name.\n     * @param {Array<any>} parameters Event parameters to pass through.\n     * @param {DispatchEventOptions} options Dispatch options.\n     */\n    this.dispatchEvent = (\n      name,\n      parameters,\n      options = null,\n    ) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n",
    "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n// Import event dispatcher.\nimport EventDispatcher from './EventDispatcher.js'\n\n/**\n * @typedef ProxyOptions\n * @type {object}\n * @property {?boolean} delete Whether to dispatch an event on delete.\n * @property {?boolean} get Whether to dispatch an event on get.\n * @property {?boolean} set Whether to dispatch an event on set.\n */\n\nexport default class ProxyDispatcher extends EventDispatcher {\n  /**\n   * Creates a proxy dispatcher instance.\n   * @param {ProxyOptions} options Options for proxy dispatcher.\n   */\n  constructor(\n    options = {},\n  ) {\n    super()\n\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true,\n    }, options)\n\n    // Setup WeakMap for keep track of created proxies.\n    const map = new WeakMap()\n\n    /**\n     * Add object to start keeping track of it.\n     * @param {object} target Object that is being kept track of.\n     * @param {Array<string>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n    this.add = (\n      target,\n      path = [],\n    ) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target)\n      }\n\n      // Recursively create proxies for each property.\n      for (const key in target) {\n        if (target[key] && typeof (target[key]) === 'object') {\n          target[key] = this.add(target[key], [...path, key])\n        }\n      }\n\n      // Create handler and add the handler for which a callback exits..\n      const handler = {}\n\n      if (options.delete) {\n        handler.deleteProperty = (\n          target,\n          key,\n        ) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true\n          }\n\n          // Remove proxy.\n          this.remove(target, key)\n\n          // Delete property.\n          const deleted = Reflect.deleteProperty(target, key)\n\n          // Dispatch delete event.\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]])\n          }\n\n          // Return deleted.\n          return deleted\n        }\n      }\n\n      if (options.get) {\n        handler.get = (\n          target,\n          key,\n          receiver,\n        ) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver])\n          }\n\n          // Return value from object.\n          return Reflect.get(target, key, receiver)\n        }\n      }\n\n      if (options.set) {\n        handler.set = (\n          target,\n          key,\n          value,\n          receiver,\n        ) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true\n          }\n\n          // Add proxy if value is an object.\n          if (value && typeof value === 'object') {\n            value = this.add(value, [...path, key])\n          }\n          // Store value.\n          target[key] = value\n\n          // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver])\n\n          // Return success.\n          return true\n        }\n      }\n\n      // Create proxy.\n      const revocable = RevocableProxy(target, handler)\n\n      // Store target at proxy.\n      map.set(revocable, target)\n\n      // Return proxy.\n      return revocable.proxy\n    }\n\n    /**\n     * Remove object from being kept track of.\n     * @param {object} target Object that is being kept track of.\n     */\n    this.remove = (\n      target,\n    ) => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return\n      }\n\n      const revocable = map.get(target)\n      map.delete(revocable)\n\n      // Recursively remove properties as well.\n      for (const property in revocable.proxy) {\n        if (typeof (revocable.proxy[property]) === 'object') {\n          this.remove(revocable.proxy[property])\n        }\n      }\n\n      // Revoke proxy.\n      revocable.revoke()\n    }\n  }\n}\n",
    "/**\n * @typedef {import('../events/ProxyDispatcher.js').ProxyDispatcher} ProxyDispatcher\n */\n\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n/**\n * Factory function to create a context for a state which dispatched update events when mutated.\n * @param {string} name Name of the state.\n * @param {string} id Identifier of the state.\n * @param {object} state Data of the state.\n * @param {ProxyDispatcher} proxy Dispatcher to pass events through.\n * @returns {object} Proxied state and destroy callback.\n */\nexport default (\n  name,\n  id,\n  state,\n  proxy,\n) => {\n  return (\n    component,\n    attribute,\n    update,\n  ) => {\n    // Create event handlers.\n    const onDelete = (\n      target,\n      path,\n    ) => update(id, name + '.' + path.join('.'))\n    const onGet = (\n      target,\n      path,\n    ) => attribute.accessed(id, name + '.' + path.join('.'))\n    const onSet = (\n      target,\n      path,\n    ) => update(id, name + '.' + path.join('.'))\n\n    // Add event listeners.\n    proxy.addEventListener('delete', onDelete)\n    proxy.addEventListener('get', onGet)\n    proxy.addEventListener('set', onSet)\n\n    // Wrap in a revocable proxy.\n    const revocable = RevocableProxy(state, {})\n\n    return {\n      value: revocable.proxy,\n\n      // Remove event listeners.\n      destroy: (\n      ) => {\n        proxy.removeEventListener('delete', onDelete)\n        proxy.removeEventListener('get', onGet)\n        proxy.removeEventListener('set', onSet)\n\n        // Revoke access to state.\n        revocable.revoke()\n      },\n    }\n  }\n}\n",
    "import createState from './createState.js'\n\n/**\n * @typedef {import('../events/ProxyDispatcher.js').default} ProxyDispatcher\n * @typedef {import('../polyfills/RevocableProxy.js').RevocableProxy} RevocableProxy\n */\n\n/**\n * Function called when the context needs to be destroyed.\n * @callback DestroyStateContext\n */\n\n/**\n * @typedef StateContext\n * @type {object}\n * @property {Proxy} value The proxy of the state to mutate.\n * @property {DestroyStateContext} destroy The proxy of the state.\n */\n\n/**\n * Factory function to create a context for a state which dispatched update events when mutated.\n * @param {string} name Name of the state.\n * @param {string} id Identifier of the state.\n * @param {object} state Data of the state.\n * @param {ProxyDispatcher} proxy Dispatcher to pass events through.\n * @param {boolean} deconstruct Whether to deconstruct the state or require the name prefix.\n * @returns {object} Proxied state and destroy callback.\n */\nexport default (\n  name,\n  id,\n  state,\n  proxy,\n  deconstruct,\n) => ({\n  deconstruct,\n\n  name,\n\n  create: createState(\n    name,\n    id,\n    state,\n    proxy,\n  ),\n})\n",
    "let _cache = null\n\nexport const getAll = (\n) => {\n  if (_cache === null) {\n    // Get and parse cookies.\n    _cache = Object.fromEntries(\n      document.cookie.split(/; */)\n        .map(cookie => {\n          const [key, ...value] = cookie.split('=')\n          return [key, decodeURIComponent(value.join('='))]\n        }),\n    )\n  }\n  return _cache\n}\n\nexport const set = (\n  name,\n  value = '',\n  days = 60,\n) => {\n  name = name.trim()\n\n  if (!value || value === '') {\n    // Set cookie in document as expired.\n    document.cookie = name + '=; Expires=Thu, 01 Jan 1970 00:00:01 GMT; Path=/; SameSite=Strict;'\n\n    // Delete from cache as well.\n    if (_cache !== null) {\n      // Ensure cache exists.\n      delete _cache[name]\n    }\n  } else {\n    // Set cookie in document.\n    let expires = ''\n    if (days) {\n      const date = new Date()\n      date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000))\n      expires = '; expires=' + date.toUTCString()\n    }\n    document.cookie = name + '=' + encodeURIComponent(value) + expires + '; Path=/; SameSite=Strict;'\n\n    // Ensure the cache is populated.\n    getAll()\n    // Set in cache as well.\n    _cache[name] = value\n  }\n}\n",
    "import ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\nimport createStateContext from '@doars/common/src/factories/createStateContext.js'\n\nimport {\n  getAll,\n  set,\n} from '../utilities/cookies.js'\n\nexport default ({\n  cookiesContextDeconstruct,\n  cookiesContextName,\n}) => {\n  // Setup proxy that updates to cookies.\n  const proxy = new ProxyDispatcher()\n  const onMutate = (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested cookies impossible tried to set \"' + path.join('.') + '\".')\n    }\n    set(path[0], target[path[0]])\n  }\n  proxy.addEventListener('delete', onMutate)\n  proxy.addEventListener('set', onMutate)\n\n  return createStateContext(\n    cookiesContextName,\n    Symbol('ID_COOKIES'),\n    proxy.add(getAll()),\n    proxy,\n    !!cookiesContextDeconstruct,\n  )\n}\n",
    "export const getAll = (\n) => {\n  const data = {}\n  const keys = Object.keys(localStorage)\n  for (let i = keys.length - 1; i >= 0; i--) {\n    data[keys[i]] = localStorage.getItem(keys[i])\n  }\n  return data\n}\n",
    "import ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\nimport createStateContext from '@doars/common/src/factories/createStateContext.js'\n\nimport { getAll } from '../utilities/localStorage.js'\n\nexport default ({\n  localStorageContextDeconstruct,\n  localStorageContextName,\n}) => {\n  // Setup proxy that updates to local storage.\n  const proxy = new ProxyDispatcher()\n  proxy.addEventListener('delete', (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested local storage impossible tried to set \"' + path.join('.') + '\".')\n    }\n    localStorage.removeItem(path[0])\n  })\n  proxy.addEventListener('set', (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested local storage impossible tried to set \"' + path.join('.') + '\".')\n    }\n    localStorage.setItem(path[0], target[path[0]])\n  })\n\n  return createStateContext(\n    localStorageContextName,\n    Symbol('ID_LOCAL_STORAGE'),\n    proxy.add(getAll()),\n    proxy,\n    !!localStorageContextDeconstruct,\n  )\n}\n",
    "export const getAll = (\n) => {\n  const data = {}\n  const keys = Object.keys(sessionStorage)\n  for (let i = keys.length - 1; i >= 0; i--) {\n    data[keys[i]] = sessionStorage.getItem(keys[i])\n  }\n  return data\n}\n",
    "import ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\nimport createStateContext from '@doars/common/src/factories/createStateContext.js'\n\nimport { getAll } from '../utilities/sessionStorage.js'\n\nexport default ({\n  sessionStorageContextDeconstruct,\n  sessionStorageContextName,\n}) => {\n  // Setup proxy that updates to local storage.\n  const proxy = new ProxyDispatcher()\n  proxy.addEventListener('delete', (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested local storage impossible tried to set \"' + path.join('.') + '\".')\n    }\n    sessionStorage.removeItem(path[0])\n  })\n  proxy.addEventListener('set', (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested local storage impossible tried to set \"' + path.join('.') + '\".')\n    }\n    sessionStorage.setItem(path[0], target[path[0]])\n  })\n\n  return createStateContext(\n    sessionStorageContextName,\n    Symbol('ID_LOCAL_STORAGE'),\n    proxy.add(getAll()),\n    proxy,\n    !!sessionStorageContextDeconstruct,\n  )\n}\n",
    "import createCookieContext from './contexts/cookies.js'\nimport createLocalStorageContext from './contexts/localStorage.js'\nimport createSessionStorageContext from './contexts/sessionStorage.js'\n\n/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    cookiesContextDeconstruct: false,\n    cookiesContextName: '$cookies',\n    localStorageContextDeconstruct: false,\n    localStorageContextName: '$localStorage',\n    sessionStorageContextDeconstruct: false,\n    sessionStorageContextName: '$sessionStorage',\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  let cookiesContext,\n    localStorageContext,\n    sessionStorageContext\n\n  const onEnable = (\n  ) => {\n    cookiesContext = createCookieContext(options)\n    localStorageContext = createLocalStorageContext(options)\n    sessionStorageContext = createSessionStorageContext(options)\n\n    // Get index of state and insert the context directly before it.\n    const existingContexts = library.getContexts()\n    let stateIndex = 0\n    for (let i = existingContexts.length - 1; i >= 0; i--) {\n      const context = existingContexts[i]\n      if (context.name === '$state') {\n        stateIndex = i\n        break\n      }\n    }\n    library.addContexts(\n      stateIndex,\n      cookiesContext,\n      localStorageContext,\n      sessionStorageContext,\n    )\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts.\n    library.removeContexts(\n      cookiesContext,\n      localStorageContext,\n      sessionStorageContext,\n    )\n    cookiesContext = null\n    localStorageContext = null\n    sessionStorageContext = null\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"
  ],
  "mappings": "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",
  "debugId": "36A60F83EE6B35D064756E2164756E21",
  "names": []
}