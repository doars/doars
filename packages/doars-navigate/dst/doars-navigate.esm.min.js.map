{
  "version": 3,
  "sources": ["../../common/src/utilities/Fetch.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Html.js", "../../common/src/utilities/String.js", "../../common/src/utilities/Attribute.js", "../../common/src/utilities/Transition.js", "../../common/src/utilities/Indicator.js", "../../common/src/utilities/Script.js", "../../common/src/utilities/Morph.js", "../src/directives/navigate.js", "../src/DoarsNavigate.js"],
  "sourcesContent": [
    "/**\n * Convert response to a desired type.\n * @param {Response} response The response to parse.\n * @param {string} type Simplified type name the data should be converted to.\n * @returns {Promise<any>} Resulting data.\n */\nexport const parseResponse = (\n  response,\n  type,\n) => {\n  let promise\n  switch (String.prototype.toLowerCase.call(type)) {\n    default:\n      console.warn('Unknown response type \"' + type + '\" used.')\n      break\n\n    case 'arraybuffer':\n      promise = response.arrayBuffer()\n      break\n\n    case 'blob':\n      promise = response.blob()\n      break\n\n    case 'formdata':\n      promise = response.formData()\n      break\n\n    case 'json':\n      promise = response.json()\n      break\n\n    // HTML and xml need to be converted to text before being able to be parsed.\n    case 'element': case 'html-partial':\n    case 'html':\n    case 'svg':\n    case 'text':\n    case 'xml':\n      promise = response.text()\n      break\n  }\n\n  if (!promise) {\n    return null\n  }\n\n  return promise\n    .then((\n      response,\n    ) => {\n      switch (type) {\n        // Convert from html to HTMLElement inside a document fragment.\n        case 'element': case 'html-partial':\n          const template = document.createElement('template')\n          template.innerHTML = response\n          response = template.content.childNodes[0]\n          break\n\n        // Parse some values via the DOM parser.\n        case 'html':\n          response = (new DOMParser()).parseFromString(response, 'text/html')\n          break\n        case 'svg':\n          response = (new DOMParser()).parseFromString(response, 'image/svg+xml')\n          break\n        case 'xml':\n          response = (new DOMParser()).parseFromString(response, 'application/xml')\n          break\n      }\n\n      return response\n    })\n}\n\n/**\n * Try and get the mime type of the response.\n * @param {Response} response Response to try and get the type from.\n * @param {Request} request Request the response originates from.\n * @returns {string} mime type.\n */\nexport const responseType = (\n  response,\n  request = null,\n) => {\n  // Check content type header.\n  let contentType = response.headers.get('Content-Type')\n  if (contentType) {\n    contentType = String.prototype.toLowerCase.call(contentType).split(';')[0]\n    const result = simplifyType(contentType.trim())\n    if (result) {\n      return result\n    }\n  }\n\n  // Check url extension.\n  let extension = response.url.split('.')\n  if (extension) {\n    extension = extension[extension.length - 1]\n    switch (extension) {\n      case 'htm':\n      case 'html':\n        return 'html'\n\n      case 'json':\n        return 'json'\n\n      case 'svg':\n        return 'svg'\n\n      case 'txt':\n        return 'text'\n\n      case 'xml':\n        return 'xml'\n    }\n  }\n\n  // Check accept type header.\n  if (request) {\n    let acceptTypes = request.headers.Accept\n    if (acceptTypes) {\n      acceptTypes = String.prototype.toLowerCase.call(acceptTypes).split(',')\n      for (let acceptType of acceptTypes) {\n        acceptType = acceptType.split(';')[0].trim()\n        const result = simplifyType(acceptType)\n        if (result) {\n          return result\n        }\n      }\n    }\n  }\n\n  return null\n}\n\n/**\n * Simplify the mime type to single word.\n * @param {string} mimeType Mime type to simplify.\n * @returns {string} Simplified type.\n */\nexport const simplifyType = (\n  mimeType,\n) => {\n  switch (mimeType) {\n    case 'text/html':\n      return 'html'\n\n    case 'text/html-partial':\n      return 'html-partial'\n\n    case 'text/json':\n    case 'application/json':\n    case 'application/ld+json':\n    case 'application/vnd.api+json':\n      return 'json'\n\n    case 'image/svg+xml':\n      return 'svg'\n\n    case 'text/plain':\n      return 'text'\n\n    case 'application/xml':\n    case 'text/xml':\n      return 'xml'\n  }\n}\n\n/**\n *\n * @param {string} url Fetch URL.\n * @param {Request} options Fetch options.\n * @param {string} returnType Simplified type name the data should be converted to.\n * @returns {Promise<any>} Resulting data.\n */\nexport const fetchAndParse = (\n  url,\n  options,\n  returnType,\n) => (new Promise((\n  resolve,\n  reject,\n) => {\n  fetch(url, options)\n    .then((response) => {\n      if (\n        response.status < 200\n        || response.status >= 500\n      ) {\n        reject(response)\n        return\n      }\n\n      // Automatically base return type on header.\n      if (\n        !returnType\n        || returnType === 'auto'\n      ) {\n        returnType = responseType(response, options)\n      }\n      // Parse response based on return type.\n      const responseParse = parseResponse(response, returnType)\n      if (!responseParse) {\n        throw new Error('No valid response returned.')\n      }\n      responseParse\n        .then(responseValue => {\n          response.value = responseValue\n          resolve(response)\n        })\n    })\n    .catch((error) => {\n      reject(error)\n    })\n}))\n\nexport default {\n  fetchAndParse,\n  parseResponse,\n  responseType,\n  simplifyType,\n}\n",
    "/**\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').ProcessExpression} ProcessExpression\n */\n\n/**\n * Convert string to HTML element.\n * @param {string} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const stringStart = string.substring(0, 15).toLowerCase()\n  if (\n    stringStart.startsWith('<!doctype html>') ||\n    stringStart.startsWith('<html>')\n  ) {\n    const html = document.createElement('html')\n    html.innerHTML = string\n    return html\n  }\n\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMLElement} a A node.\n * @param {HTMLElement} b Another node.\n * @returns {boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (\n    a.isSameNode &&\n    a.isSameNode(b)\n  ) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Select a section of the element.\n * @param {HTMLElement|string} node Element to select from.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {ProcessExpression} processExpression Function to process an expression with.\n * @returns {HTMLElement|string|null} The selection of the node based on the select directive, if a string was entered in to the function it will also be returned as a string.\n */\nexport const select = (\n  node,\n  component,\n  attribute,\n  processExpression,\n) => {\n  const libraryOptions = component.getLibrary().getOptions()\n  const element = attribute.getElement()\n  const directive = attribute.getDirective()\n\n  const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.selectFromElementDirectiveName\n  if (!element.hasAttribute(attributeName)) {\n    return node\n  }\n  let selector = null\n  if (libraryOptions.selectFromElementDirectiveEvaluate) {\n    selector = processExpression(\n      component,\n      attribute,\n      element.getAttribute(attributeName),\n    )\n    if (typeof (selector) !== 'string') {\n      console.warn('Doars: `' + attributeName + '` must return a string.')\n      return null\n    }\n  } else {\n    selector = element.getAttribute(attributeName)\n  }\n  if (selector) {\n    const asString = typeof (node) === 'string'\n    if (asString) {\n      node = fromString(node)\n    }\n\n    node = node.querySelector(selector)\n\n    if (\n      asString &&\n      node\n    ) {\n      return node.outerHTML\n    }\n  }\n  return node\n}\n\n/**\n * @callback WalkIterate Returns a new child element or null when all items have been iterated on.\n * @returns {HTMLElement|null}\n */\n\n/**\n * @callback WalkFilter Filter function that takes in an element and return true if the element needs to be walked and false when it needs to be skipped.\n * @param {HTMLElement} element Element to decide on.\n * @returns {boolean}\n */\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} node Element to walk over.\n * @param {WalkFilter} filter Filter function, return false to skip element.\n * @returns {WalkIterate} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  node,\n  filter,\n) => {\n  let index = -1\n  /** @type {null|WalkIterate} */\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (\n      index >= 0 &&\n      iterator\n    ) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= node.childElementCount) {\n        return null\n      }\n\n      child = node.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  isSame,\n  select,\n  walk,\n}\n",
    "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n",
    "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {string} text String to escape.\n * @returns {string} Escaped string.\n */\nexport const escapeHtml = (\n  text,\n) => {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\\\'/g, '\\\\\\'')\n    .replace(/\\\\\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n}\n\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {string} text String to modify.\n * @returns {string} Converted string.\n */\nexport const kebabToCamel = (\n  text,\n) => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase())\n}\n\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<string>} modifiers List of modifiers to parse.\n * @returns {object} Parsed modifiers.\n */\nexport const parseAttributeModifiers = (\n  modifiers,\n) => {\n  const result = {}\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-')\n\n    // If no hyphen then set the modifiers to true.\n    if (hyphenIndex < 0) {\n      result[modifier] = true\n      continue\n    }\n\n    // If it starts with hyphen then set the modifier to false.\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false\n      continue\n    }\n\n    // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n    const key = modifier.substring(0, hyphenIndex)\n    let value = modifier.substring(hyphenIndex + 1)\n\n    let tmpValue = value\n\n    // Try to remove time suffixes.\n    let type\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2)\n    } else if (value.endsWith('s')) {\n      type = 's'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('m')) {\n      type = 'm'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('h')) {\n      type = 'h'\n      tmpValue = value.substring(-1)\n    }\n\n    // Try to parse the value as a number.\n    tmpValue = Number.parseInt(tmpValue)\n    if (!isNaN(tmpValue)) {\n      value = tmpValue\n\n      // Convert to milliseconds if given in a different format.\n      switch (type) {\n        case 'h':\n          value *= 60\n        case 'm':\n          value *= 60\n        case 's':\n          value *= 1000\n          break\n      }\n    }\n\n    // Store modifier data.\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {string} prefix Directive prefix.\n * @param {string} name Name to parse.\n * @returns {Array<string> | undefined} list of segments.\n */\nexport const parseAttributeName = (\n  prefix,\n  name,\n) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'))\n  if (!name) {\n    return\n  }\n  // Deconstruct match.\n  let [full, directive, keyRaw, modifiers] = name // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n  keyRaw = keyRaw !== '' ? keyRaw : null\n  const key = keyRaw ? kebabToCamel(keyRaw) : null\n  // Ensure modifiers is and array.\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []\n  // Return result a single array.\n  return [directive, keyRaw, key, modifiers]\n}\n\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n * @param {string} expression For expression to parse.\n * @returns {object | undefined} Iterable type and variables.\n */\nexport const parseForExpression = (\n  expression,\n) => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i)\n  if (!match) {\n    return\n  }\n\n  // Remove parenthesis.\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, '')\n  // Parse for variables.\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i)\n  if (!variables) {\n    return\n  }\n  variables.shift()\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables], // Convert it to an array instead of a regular expression match.\n  }\n}\n\n/**\n * Parse selector to an attributes object.\n * @param {string} selector Selector to parse.\n * @returns {object | undefined} Attributes. Do note the class property is a list of strings not a single string.\n */\nexport const parseSelector = (\n  selector,\n) => {\n  // Convert to array.\n  if (typeof (selector) === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/)\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.')\n    return\n  }\n\n  const attributes = {}\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim()\n\n    // Base what to do of the leading character.\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1)\n        break\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1)\n        // Add to classlist.\n        if (!attributes.class) {\n          attributes.class = []\n        }\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment)\n        }\n        break\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i) // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n        attributes[key] = value\n        break\n    }\n  }\n  return attributes\n}\n\nexport default {\n  escapeHtml,\n  kebabToCamel,\n  parseAttributeModifiers,\n  parseAttributeName,\n  parseForExpression,\n  parseSelector,\n}\n",
    "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n",
    "// Import utilities.\nimport { parseSelector } from './String.js'\nimport { addAttributes, removeAttributes } from './Attribute.js'\n\n// Transition name.\nconst TRANSITION_NAME = '-transition:'\n\n/**\n * @callback TransitionEnd\n */\n\n/**\n * Transition an element.\n * @param {string} type Type of transition, for example 'in' and 'out'.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transition = (\n  type,\n  libraryOptions,\n  element,\n  callback = null,\n) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback()\n    }\n    return\n  }\n\n  // Transition attribute name.\n  const transitionDirectiveName = libraryOptions.prefix + TRANSITION_NAME + type\n\n  // Setup dispatcher function.\n  const dispatchEvent = (phase) => {\n    element.dispatchEvent(\n      new CustomEvent('transition-' + phase),\n    )\n    element.dispatchEvent(\n      new CustomEvent('transition-' + type + '-' + phase),\n    )\n  }\n\n  // Declare variables for later.\n  let name, value, timeout, requestFrame\n  let isDone = false\n  const selectors = {}\n\n  // Process transition during attribute.\n  name = transitionDirectiveName\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.during = parseSelector(value)\n    addAttributes(element, selectors.during)\n  }\n\n  // Process transition from attribute.\n  name = transitionDirectiveName + '.from'\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.from = parseSelector(value)\n    addAttributes(element, selectors.from)\n  }\n\n  // Dispatch transition event.\n  dispatchEvent('start')\n\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null\n\n    // If cancelled then stop immediately.\n    if (isDone) {\n      return\n    }\n\n    // Remove from selector.\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    }\n\n    // Process transition to attribute.\n    name = transitionDirectiveName + '.to'\n    value = element.getAttribute(name)\n    // Parse and apply returned selector.\n    if (value) {\n      selectors.to = parseSelector(value)\n      addAttributes(element, selectors.to)\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n      return\n    }\n\n    // Get computes style.\n    const styles = getComputedStyle(element)\n\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null\n\n      // If cancelled then stop immediately.\n      if (isDone) {\n        return\n      }\n\n      // Remove during selector.\n      if (selectors.during) {\n        removeAttributes(element, selectors.during)\n        selectors.during = undefined\n      }\n\n      // Remove to selector.\n      if (selectors.to) {\n        removeAttributes(element, selectors.to)\n        selectors.to = undefined\n      }\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n    }, duration)\n  })\n\n  return (\n  ) => {\n    if (!isDone) {\n      return\n    }\n    isDone = true\n\n    // Remove applied selector.\n    if (selectors.during) {\n      removeAttributes(element, selectors.during)\n      selectors.during = undefined\n    }\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to)\n      selectors.to = undefined\n    }\n\n    // Clear request animation frame and timeout.\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame)\n      requestFrame = null\n    } else if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    // Dispatch end event.\n    dispatchEvent('end')\n    // Invoke callback.\n    if (callback) {\n      callback()\n    }\n  }\n}\n\n/**\n * Transition an element in.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionIn = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('in', libraryOptions, element, callback)\n}\n\n/**\n * Transition an element out.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionOut = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('out', libraryOptions, element, callback)\n}\n\nexport default {\n  transition,\n  transitionIn,\n  transitionOut,\n}\n",
    "import {\n  transitionIn,\n  transitionOut,\n} from './Transition.js'\n\n/**\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').ProcessExpression} ProcessExpression\n */\n\n/**\n * Hides the indicator.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @returns {void}\n */\nexport const hideIndicator = (\n  component,\n  attribute,\n) => {\n  // Check if a indicator exists.\n  if (!attribute.indicator) {\n    return\n  }\n  // Check if not already transitioning out.\n  if (attribute.indicator.indicatorTransitionOut) {\n    return\n  }\n  // Check if a indicator element exists.\n  if (!attribute.indicator.indicatorElement) {\n    return\n  }\n\n  const libraryOptions = component.getLibrary().getOptions()\n\n  // Transition element in.\n  const indicatorElement = attribute.indicator.indicatorElement\n  attribute.indicator.indicatorTransitionIn =\n    transitionOut(libraryOptions, indicatorElement, () => {\n      if (indicatorElement) {\n        indicatorElement.remove()\n      }\n    })\n}\n\n/**\n * Shows the indicator.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {ProcessExpression} processExpression Function to process an expression with.\n * @returns {void}\n */\nexport const showIndicator = (\n  component,\n  attribute,\n  processExpression,\n) => {\n  const libraryOptions = component.getLibrary().getOptions()\n  const element = attribute.getElement()\n  const directive = attribute.getDirective()\n\n  const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.indicatorDirectiveName\n  if (!element.hasAttribute(attributeName)) {\n    return\n  }\n  let indicatorTemplate = null\n  if (libraryOptions.indicatorDirectiveEvaluate) {\n    indicatorTemplate = processExpression(\n      component,\n      attribute,\n      element.getAttribute(attributeName),\n    )\n  } else {\n    indicatorTemplate = element.getAttribute(attributeName)\n  }\n  if (!indicatorTemplate) {\n    return\n  }\n  if (typeof (indicatorTemplate) === 'string') {\n    indicatorTemplate = element.querySelector(indicatorTemplate)\n    if (!indicatorTemplate) {\n      return\n    }\n  }\n\n  // Check if placed on a template tag.\n  if (indicatorTemplate.tagName !== 'TEMPLATE') {\n    console.warn('Doars: `' + attributeName + '` must be placed on a `<template>`.')\n    return\n  }\n  if (indicatorTemplate.childCount > 1) {\n    console.warn('Doars: `' + attributeName + '` must have one child.')\n    return\n  }\n\n  // Cancel current transition.\n  if (attribute.indicator) {\n    if (attribute.indicator.indicatorTransitionOut) {\n      attribute.indicator.indicatorTransitionOut()\n      attribute.indicator.indicatorTransitionOut = null\n    } else if (attribute.indicator.indicatorElement) {\n      return\n    }\n  }\n\n  // Create new element from template.\n  const indicatorElement = document.importNode(indicatorTemplate.content, true).firstElementChild\n  // Add element after the template element.\n  indicatorTemplate.insertAdjacentElement('afterend', indicatorElement)\n  attribute.indicator = {\n    indicatorElement,\n    // Transition element in.\n    indicatorTransitionIn: transitionIn(libraryOptions, indicatorElement),\n  }\n}\n\nexport default {\n  hideIndicator,\n  showIndicator,\n}\n",
    "import { walk } from './Element.js'\n\n/**\n * Re-adds a script to the document in order to trigger it again.\n * @param {HTMLElement} element Script to re-add to the DOM.\n * @returns {void}\n */\nconst _readdScript = (\n  element,\n) => {\n  // Check if element is a script without a source.\n  if (\n    element.tagName !== 'SCRIPT' ||\n    element.hasAttribute('src')\n  ) {\n    return false\n  }\n\n  // Set up new script with same content.\n  const newScript = document.createElement('script')\n  newScript.innerText = element.innerText\n\n  // Replace script in the document.\n  element.parentNode.insertBefore(\n    newScript,\n    element,\n  )\n  element.remove()\n  return true\n}\n\n/**\n * Checks the elements for scripts and re-adds these to the DOM.\n * @param  {...HTMLElement} elements Elements to check for scripts.\n * @returns {void}\n */\nexport const readdScripts = (\n  ...elements\n) => {\n  for (const element of elements) {\n    // Try to re-add element in case it is a script.\n    if (!_readdScript(element)) {\n      // Otherwise check its children.\n      const iterate = walk(element)\n      let maybeScript = null\n      while (maybeScript = iterate()) {\n        _readdScript(maybeScript)\n      }\n    }\n  }\n}\n\nexport default {\n  readdScripts,\n}\n",
    "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame,\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement | string} newTree The tree to change to.\n * @param {object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the initial value. Changing the \"value\" attribute without changing the \"value\" property will have no effect since it is only used to the set the initial value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n * @param {string} name Name of the attribute.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop.\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing.\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old.\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new.\n    } else if (!existingChild) {\n      existingNode.append(newChild)\n      offset++\n\n      // Both nodes are the same, morph.\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder.\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree.\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list.\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID.\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node.\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n * @typedef {import('@doars/doars/src/Attribute.js').default} Attribute\n * @typedef {import('@doars/doars/src/Component.js').default} Component\n * @typedef {import('@doars/doars/src/Directive.js').Directive} Directive\n * @typedef {import('@doars/doars/src/Directive.js').DirectiveUtilities} DirectiveUtilities\n */\n\n// Import utilities.\nimport { fetchAndParse } from '@doars/common/src/utilities/Fetch.js'\nimport {\n  fromString as elementFromString,\n  select as selectFromElement,\n} from '@doars/common/src/utilities/Element'\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport {\n  hideIndicator,\n  showIndicator,\n} from '@doars/common/src/utilities/Indicator.js'\nimport { readdScripts } from '@doars/common/src/utilities/Script.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\n\nconst NAVIGATE = Symbol('NAVIGATE')\n\n/**\n * @typedef DirectiveOptions\n * @type {object}\n * @property {object} fetchOptions Object of options given to the fetch method when submitting data.\n * @property {string} intersectionMargin Margin of the intersection observer.\n * @property {number|Array<number>} intersectionThreshold Thresholds of the intersection observer.\n */\n\n/**\n * @param {DirectiveOptions} options Options used for creating the directive.\n * @returns {Directive} Created submit directive.\n */\nexport default ({\n  fetchOptions,\n  intersectionMargin,\n  intersectionThreshold,\n  navigateDirectiveName,\n}) => {\n  return {\n    name: navigateDirectiveName,\n\n    update: (\n      component,\n      attribute,\n      processExpression,\n    ) => {\n      const element = attribute.getElement()\n      if (element[NAVIGATE]) {\n        return\n      }\n\n      // Destruct component.\n      const library = component.getLibrary()\n      const libraryOptions = library.getOptions()\n\n      // Deconstruct attribute.\n      const directive = attribute.getDirective()\n      const modifiers = attribute.getModifiers()\n\n      // Process modifiers.\n\n      // Set listener options.\n      const listenerOptions = {}\n      if (modifiers.capture) {\n        listenerOptions.capture = true\n      }\n\n      const fetchHeaders = {\n        [libraryOptions.prefix + '-' + libraryOptions.requestHeaderName]: directive,\n        Vary: libraryOptions.prefix + '-' + libraryOptions.requestHeaderName,\n      }\n\n      const dispatchEvent = (\n        suffix = '',\n        data = {},\n      ) => {\n        element.dispatchEvent(\n          new CustomEvent(\n            libraryOptions.prefix + '-' + directive + suffix,\n            {\n              detail: Object.assign({\n                attribute,\n                component,\n              }, data),\n            },\n          ),\n        )\n      }\n\n      const loadFromUrl = (\n        url,\n      ) => {\n        attribute[NAVIGATE].url = url\n        const identifier = (new Date()).toISOString()\n        attribute[NAVIGATE].identifier = identifier\n\n        showIndicator(\n          component,\n          attribute,\n          processExpression,\n        )\n\n        // Dispatch navigation started event.\n        dispatchEvent('-started', {\n          url,\n        })\n\n        fetchAndParse(\n          url,\n          Object.assign({}, fetchOptions, {\n            headers: Object.assign({}, fetchOptions.headers, fetchHeaders),\n          }),\n          'text',\n        )\n          .then(response => {\n            // Validate that this is still the active request.\n            if (\n              !attribute[NAVIGATE].identifier\n              || attribute[NAVIGATE].identifier !== identifier\n            ) {\n              return\n            }\n\n            // Check if request was successful.\n            if (!response) {\n              hideIndicator(\n                component,\n                attribute,\n              )\n\n              delete attribute[NAVIGATE].url\n              delete attribute[NAVIGATE].identifier\n              return\n            }\n\n            // Decode string.\n            let html = response.value\n            if (modifiers.decode) {\n              html = decode(html)\n            }\n\n            let target = null\n            if (modifiers.document) {\n              target = document.documentElement\n            } else {\n              const attributeName = libraryOptions.prefix + '-' + directive + '-' + libraryOptions.targetDirectiveName\n              if (element.getAttribute(attributeName)) {\n                if (libraryOptions.targetDirectiveEvaluate) {\n                  target = processExpression(\n                    component,\n                    attribute,\n                    element.getAttribute(attributeName),\n                  )\n                } else {\n                  target = element.getAttribute(attributeName)\n                }\n                if (\n                  target\n                  && typeof (target) === 'string'\n                ) {\n                  target = element.querySelector(target)\n                }\n              }\n              if (!target) {\n                target = element\n              }\n            }\n\n            // Update target.\n            if (modifiers.morph) {\n              if (modifiers.outer) {\n                morphTree(\n                  target,\n                  selectFromElement(\n                    elementFromString(html),\n                    component,\n                    attribute,\n                    processExpression,\n                  ),\n                )\n              } else {\n                // Ensure element only has one child.\n                if (target.children.length === 0) {\n                  target.append(document.createElement('div'))\n                } else if (target.children.length > 1) {\n                  for (let i = target.children.length - 1; i >= 1; i--) {\n                    target.children[i].remove()\n                  }\n                }\n\n                // Morph first child to given target tree.\n                const root = morphTree(\n                  target.children[0],\n                  selectFromElement(\n                    elementFromString(html),\n                    component,\n                    attribute,\n                    processExpression,\n                  ),\n                )\n                if (!target.children[0].isSameNode(root)) {\n                  target.children[0].remove()\n                  target.append(root)\n                }\n              }\n            } else if (modifiers.outer) {\n              if (target.outerHTML !== html) {\n                target.outerHTML = selectFromElement(\n                  html,\n                  component,\n                  attribute,\n                  processExpression,\n                )\n                if (\n                  libraryOptions.allowInlineScript\n                  || modifiers.script\n                ) {\n                  readdScripts(target)\n                }\n              }\n            } else if (target.innerHTML !== html) {\n              target.innerHTML = selectFromElement(\n                html,\n                component,\n                attribute,\n                processExpression,\n              )\n              if (\n                libraryOptions.allowInlineScript\n                || modifiers.script\n              ) {\n                readdScripts(...target.children)\n              }\n            }\n\n            // Get new document link.\n            if (\n              libraryOptions.redirectHeaderName\n              && response.headers.has(libraryOptions.prefix + '-' + libraryOptions.redirectHeaderName)\n            ) {\n              window.location.href = response.headers.get(libraryOptions.prefix + '-' + libraryOptions.redirectHeaderName)\n              return\n            }\n\n            // Get new document title.\n            let documentTitle = ''\n            if (\n              libraryOptions.titleHeaderName\n              && response.headers.has(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)\n            ) {\n              documentTitle = response.headers.get(libraryOptions.prefix + '-' + libraryOptions.titleHeaderName)\n            }\n\n            // Update history api.\n            if (modifiers.history) {\n              history.pushState({}, documentTitle, url)\n            }\n\n            // If document title was not updated via the history update, then set it now.\n            if (\n              documentTitle\n              && document.title !== documentTitle\n            ) {\n              document.title = documentTitle\n            }\n\n            hideIndicator(\n              component,\n              attribute,\n            )\n\n            delete attribute[NAVIGATE].url\n            delete attribute[NAVIGATE].identifier\n\n            dispatchEvent('-succeeded', {\n              url,\n            })\n          })\n          .catch(() =>\n            dispatchEvent('-failed', {\n              url,\n            }),\n          )\n      }\n\n      const interactionHandler = (\n        event,\n      ) => {\n        const anchor = event.target.closest('a')\n        if (\n          !anchor\n          || !anchor.hasAttribute('href')\n        ) {\n          return\n        }\n        const href = anchor.getAttribute('href')\n        const url = new URL(href, window.location)\n\n        if (window.location.hostname !== url.hostname) {\n          return\n        }\n\n        // Exit early if the link is being loaded.\n        if (\n          attribute[NAVIGATE].url\n          && attribute[NAVIGATE].url.href === url.href\n        ) {\n          return\n        }\n\n        // Prevent default.\n        event.preventDefault()\n        if (modifiers.stop) {\n          event.stopPropagation()\n        }\n\n        loadFromUrl(url)\n      }\n      element.addEventListener(\n        'click',\n        interactionHandler,\n        listenerOptions,\n      )\n\n      // Listen to history api if it can target the whole page.\n      let historyHandler\n      if (modifiers.document && modifiers.history) {\n        historyHandler = (\n          event,\n        ) => {\n          const url = new URL(event.target.location)\n\n          // Exit early if the link is being loaded already.\n          if (\n            attribute[NAVIGATE].url\n            && attribute[NAVIGATE].url.href === url.href\n          ) {\n            return\n          }\n\n          loadFromUrl(url)\n        }\n        window.addEventListener(\n          'popstate',\n          historyHandler,\n          { passive: true },\n        )\n      }\n\n      let destroyPreloader\n      if (modifiers.preload === 'interact') {\n        const preloadHandler = (event) => {\n          const anchor = event.target.closest('a')\n          if (\n            !anchor\n            || !anchor.hasAttribute('href')\n          ) {\n            return\n          }\n          const url = new URL(\n            anchor.getAttribute('href'),\n            window.location,\n          )\n\n          // Dispatch navigation started event.\n          dispatchEvent('-started', {\n            url,\n          })\n\n          fetchAndParse(\n            url,\n            Object.assign({}, fetchOptions, {\n              headers: Object.assign({}, fetchOptions.headers, fetchHeaders),\n            }),\n            'text',\n          )\n        }\n        element.addEventListener(\n          'focusin',\n          preloadHandler,\n          Object.assign({ passive: true }, listenerOptions),\n        )\n        element.addEventListener(\n          'pointerenter',\n          preloadHandler,\n          Object.assign({ passive: true }, listenerOptions),\n        )\n\n        destroyPreloader = (\n        ) => {\n          element.removeEventListener(\n            'focusin',\n            attribute[NAVIGATE].preloadHandler,\n          )\n          element.removeEventListener(\n            'pointerenter',\n            attribute[NAVIGATE].preloadHandler,\n          )\n        }\n      } else if (modifiers.preload === 'intersect') {\n        const intersectionObserver = new IntersectionObserver(\n          (anchors) => {\n            for (const anchor of anchors) {\n              if (anchor.isIntersecting) {\n                const url = new URL(\n                  anchor.target.getAttribute('href'),\n                  window.location,\n                )\n\n                // Dispatch navigation started event.\n                dispatchEvent('-started', {\n                  url,\n                })\n\n                fetchAndParse(\n                  url,\n                  Object.assign({}, fetchOptions, {\n                    headers: Object.assign({}, fetchOptions.headers, fetchHeaders),\n                  }),\n                  'text',\n                )\n              }\n            }\n          },\n          {\n            root: null,\n            rootMargin: intersectionMargin,\n            threshold: intersectionThreshold,\n          },\n        )\n        const mutationObserver = new MutationObserver(\n          (mutations) => {\n            for (const mutation of mutations) {\n              if (mutation.type === 'attributes') {\n                if (\n                  mutation.attributeName === 'href'\n                  && mutation.target instanceof HTMLElement\n                  && mutation.target.tagName === 'A'\n                ) {\n                  // Start or stop observing the element if the href was added or removed.\n                  if (mutation.target.hasAttribute('href')) {\n                    intersectionObserver.observe(mutation.target)\n                  } else {\n                    intersectionObserver.unobserve(mutation.target)\n                  }\n                }\n              } else if (mutation.type === 'childList') {\n                for (const node of mutation.addedNodes) {\n                  if (\n                    node instanceof HTMLElement\n                    && node.tagName === 'A'\n                    && node.hasAttribute('href')\n                  ) {\n                    // Start observing the node.\n                    intersectionObserver.observe(node)\n                  }\n                }\n\n                // Stop observing removed nodes.\n                for (const node of mutation.removedNodes) {\n                  if (\n                    node instanceof HTMLElement\n                    && node.tagName === 'A'\n                    && node.hasAttribute('href')\n                  ) {\n                    intersectionObserver.unobserve(node)\n                  }\n                }\n              }\n            }\n          },\n        )\n\n        destroyPreloader = (\n        ) => {\n          mutationObserver.disconnect()\n          intersectionObserver.disconnect()\n        }\n\n        // Start observing existing anchor tags.\n        const anchors = element.querySelectorAll('a[href]')\n        for (const anchor of anchors) {\n          intersectionObserver.observe(anchor)\n        }\n\n        mutationObserver.observe(\n          element,\n          {\n            attributes: true,\n            childList: true,\n            subtree: true,\n          },\n        )\n      }\n\n      attribute[NAVIGATE] = {\n        element,\n        historyHandler,\n        loadHandler: interactionHandler,\n        destroyPreloader,\n      }\n    },\n\n    destroy: (\n      component,\n      attribute,\n    ) => {\n      // Exit early if no listeners can be found.\n      if (!attribute[NAVIGATE]) {\n        return\n      }\n\n      // Remove existing listener.\n      attribute[NAVIGATE].element.removeEventListener(\n        'click',\n        attribute[NAVIGATE].loadHandler,\n      )\n      if (attribute[NAVIGATE].historyHandler) {\n        window.removeEventListener(\n          'popstate',\n          attribute[NAVIGATE].historyHandler,\n        )\n      }\n      if (attribute[NAVIGATE].destroyPreloader) {\n        attribute[NAVIGATE].destroyPreloader()\n      }\n\n      hideIndicator(\n        component,\n        attribute,\n      )\n\n      // Delete directive data.\n      delete attribute[NAVIGATE]\n    },\n  }\n}\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport createNavigateDirective from './directives/navigate.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nconst DoarsNavigate = function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    fetchOptions: {},\n    intersectionMargin: '0px',\n    intersectionThreshold: 0,\n    navigateDirectiveName: 'navigate',\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  // Store contexts and directives.\n  const navigateDirective = createNavigateDirective(options)\n\n  const onEnable = (\n  ) => {\n    // Create and add contexts and directives.\n    library.addDirectives(-1, navigateDirective)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeDirective(navigateDirective)\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n\nexport default DoarsNavigate\n"
  ],
  "mappings": "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",
  "debugId": "116FF8E83F04BAA064756E2164756E21",
  "names": []
}