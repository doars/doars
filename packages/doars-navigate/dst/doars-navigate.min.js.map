{
  "version": 3,
  "sources": ["../../doars/src/symbols.js", "../../common/src/utilities/Attribute.js", "../../common/src/utilities/Element.js", "../../common/src/utilities/Promise.js", "../../common/src/utilities/Html.js", "../src/constants.js", "../src/symbols.js", "../../common/src/utilities/Morph.js", "../src/factories/directives/navigate.js", "../src/DoarsNavigate.js"],
  "sourcesContent": ["export const ATTRIBUTES = Symbol('ATTRIBUTES')\n\nexport const COMPONENT = Symbol('COMPONENT')\n\nexport const FOR = Symbol('FOR')\n\nexport const INITIALIZED = Symbol('INITIALIZED')\n\nexport const ON = Symbol('ON')\n\nexport const REFERENCES = Symbol('REFERENCES')\nexport const REFERENCES_CACHE = Symbol('REFERENCES_CACHE')\n\nexport const SYNC = Symbol('SYNC')\n", "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "/**\n * Convert string to HTML element.\n * @param {string} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (\n  string,\n) => {\n  const stringStart = string.substring(0, 15).toLowerCase()\n  const isDocument = (\n    stringStart.startsWith('<!doctype html>') ||\n    stringStart.startsWith('<html>')\n  )\n  if (isDocument) {\n    const html = document.createElement('html')\n    html.innerHTML = string\n    return html\n  }\n\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (\n  reference,\n  node,\n) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMLElement} a A node.\n * @param {HTMLElement} b Another node.\n * @returns {boolean} Whether the nodes are the same.\n */\nexport const isSame = (\n  a,\n  b,\n) => {\n  if (a.isSameNode && a.isSameNode(b)) {\n    return true\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  if (a.tagName === b.tagName) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (\n  element,\n  filter,\n) => {\n  let index = -1\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function /* A native object */)\n  .replace('Function', 'Promise') // Replace identifier.\n  .replace(/\\(.*\\)/, '()') // Remove possible FormalParameterList.\n\nexport const isNativePromise = (\n  value,\n) => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise\n}\n\nexport const isPromise = (\n  value,\n) => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]'\n}\n\nexport default {\n  isPromise,\n  isNativePromise,\n}\n", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"',\n}\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g\n\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;',\n}\nconst ENCODE_REGEXP = /[&<>'\"]/g\n\nexport const decode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(DECODE_REGEXP, (character) => {\n    return DECODE_LOOKUP[character]\n  })\n}\n\nexport const encode = (\n  string,\n) => {\n  if (typeof (string) !== 'string') {\n    return string\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, (character) => {\n    return ENCODE_LOOKUP[character]\n  })\n}\n\nexport default {\n  decode,\n  encode,\n}\n", "export const PRELOAD_INTERACT = 'interact'\nexport const PRELOAD_INTERSECT = 'intersect'\n", "export const NAVIGATE = Symbol('NAVIGATE')\n", "// Based on nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme) and morphdom, https://github.com/patrick-steele-idem/morphdom/tree/master#morphdom.\n\n// Import utilities.\nimport { copyAttributes } from './Attribute.js'\nimport {\n  fromString as elementFromString,\n  isSame as elementIsSame,\n} from './Element.js'\n\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nexport const morphNode = (\n  existingNode,\n  newNode,\n) => {\n  const nodeType = newNode.nodeType\n  const nodeName = newNode.nodeName\n\n  // Element node.\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode)\n  }\n\n  // Text node or comment node.\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue\n    }\n  }\n\n  // Some DOM nodes are weird.\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n  if (nodeName === 'INPUT') {\n    _updateInput(existingNode, newNode)\n  } else if (nodeName === 'OPTION') {\n    _updateAttribute(existingNode, newNode, 'selected')\n  } else if (nodeName === 'TEXTAREA') {\n    _updateTextarea(existingNode, newNode)\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement | string} newTree The tree to change to.\n * @param {object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\nexport const morphTree = (\n  existingTree,\n  newTree,\n  options,\n) => {\n  if (typeof (existingTree) !== 'object') {\n    throw new Error('Existing tree should be an object.')\n  }\n\n  if (typeof (newTree) === 'string') {\n    newTree = elementFromString(newTree)\n  } else if (typeof (newTree) !== 'object') {\n    throw new Error('New tree should be an object.')\n  }\n\n  // Check if outer or inner html should be updated. Always update children only if root node is a document fragment.\n  if ((options && options.childrenOnly) || newTree.nodeType === 11) {\n    _updateChildren(existingTree, newTree)\n    return existingTree\n  }\n\n  return _updateTree(existingTree, newTree)\n}\n\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateInput = (\n  existingNode,\n  newNode,\n) => {\n  // The \"value\" attribute is special for the <input> element since it sets the initial value. Changing the \"value\" attribute without changing the \"value\" property will have no effect since it is only used to the set the initial value. Similar for the \"checked\" attribute, and \"disabled\".\n\n  const newValue = newNode.value\n  const existingValue = existingNode.value\n\n  _updateAttribute(existingNode, newNode, 'checked')\n  _updateAttribute(existingNode, newNode, 'disabled')\n\n  // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate\n  }\n\n  // Persist file value since file inputs can not be changed programmatically\n  if (existingNode.type === 'file') {\n    return\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue)\n    existingNode.value = newValue\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = ''\n    existingNode.removeAttribute('value')\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value')\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue\n  }\n}\n\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\nconst _updateTextarea = (\n  existingNode,\n  newNode,\n) => {\n  const newValue = newNode.value\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    existingNode.firstChild.nodeValue = newValue\n  }\n}\n\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n * @param {string} name Name of the attribute.\n */\nconst _updateAttribute = (\n  existingNode,\n  newNode,\n  name,\n) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name]\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '')\n    } else {\n      existingNode.removeAttribute(name)\n    }\n  }\n}\n\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\nconst _updateTree = (\n  existingTree,\n  newTree,\n) => {\n  if (!existingTree) {\n    return newTree\n  }\n\n  if (!newTree) {\n    return null\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree\n  }\n\n  morphNode(existingTree, newTree)\n  _updateChildren(existingTree, newTree)\n\n  return existingTree\n}\n\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\nconst _updateChildren = (\n  existingNode,\n  newNode,\n) => {\n  let existingChild, newChild, morphed, existingMatch\n\n  // The offset is only ever increased, and used for [i - offset] in the loop.\n  let offset = 0\n\n  for (let i = 0; ; i++) {\n    existingChild = existingNode.childNodes[i]\n    newChild = newNode.childNodes[i - offset]\n\n    // Both nodes are empty, do nothing.\n    if (!existingChild && !newChild) {\n      break\n\n      // There is no new child, remove old.\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild)\n      i--\n\n      // There is no old child, add new.\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild)\n      offset++\n\n      // Both nodes are the same, morph.\n    } else if (elementIsSame(existingChild, newChild)) {\n      morphed = _updateTree(existingChild, newChild)\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild)\n        offset++\n      }\n\n      // Both nodes do not share an ID or a placeholder, try reorder.\n    } else {\n      existingMatch = null\n\n      // Try and find a similar node somewhere in the tree.\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (elementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j]\n          break\n        }\n      }\n\n      // If there was a node with the same ID or placeholder in the old list.\n      if (existingMatch) {\n        morphed = _updateTree(existingMatch, newChild)\n        if (morphed !== existingMatch) {\n          offset++\n        }\n        existingNode.insertBefore(morphed, existingChild)\n\n        // It is safe to morph two nodes in-place if neither has an ID.\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = _updateTree(existingChild, newChild)\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild)\n          offset++\n        }\n\n        // Insert the node at the index if we could not morph or find a matching node.\n      } else {\n        existingNode.insertBefore(newChild, existingChild)\n        offset++\n      }\n    }\n  }\n}\n\nexport default {\n  morphNode,\n  morphTree,\n}\n", "// Import constants.\nimport {\n  PRELOAD_INTERACT,\n  PRELOAD_INTERSECT,\n} from '../../constants.js'\n// Import symbols.\nimport { NAVIGATE } from '../../symbols.js'\n\n// Import utilities.\nimport { insertAfter } from '@doars/common/src/utilities/Element.js'\nimport { decode } from '@doars/common/src/utilities/Html.js'\nimport { morphTree } from '@doars/common/src/utilities/Morph.js'\n\n// Cannot be renamed...\nconst NAME_LOADER = '-loader'\nconst NAME_TARGET = '-target'\nconst HEADER_DATE = 'Date'\nconst HEADER_CACHE_CONTROL = 'Cache-Control'\nconst CACHE_INVALIDATION_CLAUSES = [\n  'no-cache',\n  'must-revalidate',\n  'no-store',\n]\n\nconst loaderAdd = (\n  attribute,\n  component,\n  libraryOptions,\n  processExpression,\n  transitionIn,\n) => {\n  const { prefix } = component.getLibrary().getOptions()\n  const element = attribute.getElement()\n  const directive = attribute.getDirective()\n\n  const attributeName = libraryOptions.prefix + '-' + directive + NAME_LOADER\n  if (!element.hasAttribute(attributeName)) {\n    return\n  }\n  let loaderTemplate = processExpression(\n    component,\n    attribute,\n    element.getAttribute(attributeName),\n  )\n  if (!loaderTemplate) {\n    return\n  }\n\n  if (typeof (loaderTemplate) === 'string') {\n    loaderTemplate = element.querySelector(loaderTemplate)\n  }\n\n  // Check if placed on a template tag.\n  if (loaderTemplate.tagName !== 'TEMPLATE') {\n    console.warn('Doars: `' + attributeName + '` directive must be placed on a `<template>` tag.')\n    return\n  }\n  if (loaderTemplate.childCount > 1) {\n    console.warn('Doars: `' + attributeName + '` directive must have a single child node.')\n    return\n  }\n\n  // Cancel current transition.\n  if (attribute[NAVIGATE].loaderTransitionOut) {\n    attribute[NAVIGATE].loaderTransitionOut()\n    attribute[NAVIGATE].loaderTransitionOut = null\n  } else if (attribute[NAVIGATE].loaderElement) {\n    return\n  }\n\n  // Create new element from template.\n  let loaderElement = document.importNode(loaderTemplate.content, true)\n  // Add element after the template element.\n  insertAfter(loaderTemplate, loaderElement)\n  // Get HTMLElement reference instead of DocumentFragment.\n  attribute[NAVIGATE].loaderElement = loaderElement = loaderTemplate.nextElementSibling\n\n  // Transition element in.\n  attribute[NAVIGATE].loaderTransitionIn = transitionIn(prefix, loaderElement)\n}\n\nconst loaderRemove = (\n  attribute,\n  component,\n  transitionOut,\n) => {\n  // Check if not already transitioning out and if a loader element exists.\n  if (\n    attribute[NAVIGATE].loaderTransitionOut ||\n    !attribute[NAVIGATE].loaderElement\n  ) {\n    return\n  }\n\n  // Transition element in.\n  const loaderElement = attribute[NAVIGATE].loaderElement\n  attribute[NAVIGATE].loaderTransitionIn =\n    transitionOut(\n      component.getLibrary().getOptions().prefix,\n      loaderElement,\n      () => {\n        if (loaderElement) {\n          loaderElement.remove()\n        }\n      },\n    )\n}\n\nconst validCacheFromHeaders = (\n  headers,\n  maxAge = null,\n) => {\n  if (\n    !headers.has(HEADER_DATE) ||\n    !headers.has(HEADER_CACHE_CONTROL)\n  ) {\n    return false\n  }\n  const cacheDate = new Date(headers.get(HEADER_DATE))\n  const currentDate = new Date()\n\n  // Exit early if the cached date is in the future.\n  if (cacheDate > currentDate) {\n    return false\n  }\n\n  if (maxAge) {\n    // Calculate expiration date.\n    const expireDate = new Date(cacheDate.getTime() + maxAge)\n    if (currentDate > expireDate) {\n      return false\n    }\n  }\n\n  // Get max age of the cached item.\n  const cacheControl = (headers.get(HEADER_CACHE_CONTROL)).split(',')\n  let cacheMaxAge = 0\n  for (const cacheControlItem of cacheControl) {\n    if (cacheControlItem.trim().startsWith('max-age=')) {\n      cacheMaxAge = parseInt(cacheControlItem.split('=')[1].trim(), 10)\n    }\n    if (cacheControlItem.trim().startsWith('s-maxage=')) {\n      cacheMaxAge = parseInt(cacheControlItem.split('=')[1].trim(), 10)\n      break // Break since max-age should not overwrite this.\n    }\n  }\n  // Exit early on invalid max ages.\n  if (cacheMaxAge <= 0) {\n    return false\n  }\n\n  // Calculate expiration date.\n  const expireDate = new Date(cacheDate.getTime() + (cacheMaxAge * 1e3))\n  return expireDate >= currentDate\n}\n\nlet clearCacheCounter = 0\nlet clearCacheInterval = null\n\nexport default (\n  options,\n) => {\n  let cache = {}\n  const setupCacheClearing = (\n  ) => {\n    // Exit early if a cache clearer is already set.\n    if (clearCacheCounter > 0) {\n      clearCacheCounter++\n      return\n    }\n\n    // Every x amount of seconds remove stale items from the cache, therefore reducing the memory footprint of the plugin.\n    clearCacheInterval = setInterval(\n      () => {\n        for (const location in cache) {\n          if (\n            !Object.hasOwnProperty.call(cache, location) ||\n            !cache.headers\n          ) {\n            continue\n          }\n          if (!validCacheFromHeaders(cache.headers, options.cacheMaxAge)) {\n            delete cache[location]\n          }\n        }\n      },\n      options.cacheInterval,\n    )\n  }\n  const getFromUrl = (\n    url,\n    dispatchEvent,\n    headers,\n  ) => {\n    return new Promise((resolve) => {\n      // Check if same website.\n      if (window.location.hostname !== url.hostname) {\n        resolve(null)\n      }\n\n      // Try and get item from cache.\n      if (Object.hasOwnProperty.call(cache, url.location)) {\n        if (\n          cache[url.location].headers &&\n          validCacheFromHeaders(cache[url.location].headers)\n        ) {\n          resolve(cache[url.location])\n          return\n        }\n\n        if (cache[url.location].listeners) {\n          cache[url.location].listeners.push(\n            () => {\n              resolve(cache[url.location])\n            },\n          )\n        } else {\n          cache[url.location] = {\n            listeners: [],\n          }\n        }\n      } else {\n        cache[url.location] = {\n          listeners: [],\n        }\n      }\n\n      // Dispatch navigation started event.\n      dispatchEvent('-started', {\n        url,\n      })\n\n      fetch(\n        url,\n        Object.assign({}, options.fetchOptions, {\n          headers: Object.assign({}, headers, options.fetchOptions.headers),\n        }),\n      ).then((response) => {\n        if (\n          response.status < 200 ||\n          response.status >= 500\n        ) {\n          // Dispatch navigation failed event.\n          dispatchEvent('-failed', {\n            response,\n            url,\n          })\n\n          resolve(null)\n          return\n        }\n\n        // Validate content type. Allow all but notify on invalid.\n        const contentType = response.headers.get('Content-Type')\n        if (!contentType.toLowerCase().startsWith('text/html')) {\n          console.warn('Returned response not of header type text/html, content type is \"' + contentType + '\".')\n        }\n\n        // Check if the request can be cached.\n        let allowCache = true\n        if (response.headers.has(HEADER_CACHE_CONTROL)) {\n          const cacheControl = response.headers.get(HEADER_CACHE_CONTROL).split(',')\n          let maxAge = 0\n          for (const cacheControlItem of cacheControl) {\n            const cacheClause = cacheControlItem.trim()\n\n            if (CACHE_INVALIDATION_CLAUSES.indexOf(cacheClause) >= 0) {\n              allowCache = false\n              break\n            }\n\n            if (cacheClause.startsWith('s-maxage=')) {\n              maxAge = parseInt(cacheClause.split('=')[1].trim(), 10)\n              if (maxAge <= 0) {\n                allowCache = false\n                break\n              }\n            }\n\n            if (\n              cacheClause.startsWith('max-age=') &&\n              maxAge <= 0 // Prevent override of s-maxage.\n            ) {\n              maxAge = parseInt(cacheClause.split('=')[1].trim(), 10)\n              if (maxAge <= 0) {\n                allowCache = false\n                break\n              }\n            }\n          }\n        }\n\n        response.text().then((html) => {\n          // Add response to cache.\n          const result = {\n            headers: response.headers,\n            html,\n          }\n\n          // Get listeners before updating the cache,\n          const listeners = cache[url.location].listeners\n\n          // Update cache.\n          if (allowCache) {\n            cache[url.location] = result\n            setupCacheClearing()\n          } else {\n            delete cache[url.location]\n          }\n\n          // Resolve promise.\n          resolve(result)\n\n          // Inform listeners of update.\n          if (listeners) {\n            for (const listener of listeners) {\n              listener()\n            }\n          }\n        })\n      })\n    })\n  }\n\n  return {\n    name: 'navigate',\n\n    update: (\n      component,\n      attribute, {\n        processExpression,\n        transitionIn,\n        transitionOut,\n      },\n    ) => {\n      const element = attribute.getElement()\n      if (element[NAVIGATE]) {\n        return\n      }\n\n      // Destruct component.\n      const library = component.getLibrary()\n      const libraryOptions = library.getOptions()\n\n      // Deconstruct attribute.\n      const directive = attribute.getDirective()\n      const modifiers = attribute.getModifiers()\n\n      // Process modifiers.\n\n      // Set listener options.\n      const listenerOptions = {}\n      if (modifiers.capture) {\n        listenerOptions.capture = true\n      }\n\n      const directiveHeader = libraryOptions.prefix + '-request'\n      const fetchHeaders = {\n        [directiveHeader]: directive,\n        Vary: directiveHeader,\n      }\n\n      const dispatchEvent = (\n        suffix = '',\n        data = {},\n      ) => {\n        element.dispatchEvent(\n          new CustomEvent(\n            libraryOptions.prefix + '-' + directive + suffix,\n            {\n              detail: Object.assign({\n                attribute,\n                component,\n              }, data),\n            },\n          ),\n        )\n      }\n\n      const loadFromUrl = (\n        url,\n      ) => {\n        attribute[NAVIGATE].url = url\n        const identifier = (new Date()).toISOString()\n        attribute[NAVIGATE].identifier = identifier\n\n        loaderAdd(\n          attribute,\n          component,\n          libraryOptions,\n          processExpression,\n          transitionIn,\n        )\n\n        getFromUrl(url, dispatchEvent, fetchHeaders).then((result) => {\n          // Validate that this is still the active request.\n          if (\n            !attribute[NAVIGATE].identifier ||\n            attribute[NAVIGATE].identifier !== identifier\n          ) {\n            return\n          }\n\n          // Check if request was successful.\n          if (!result) {\n            loaderRemove(\n              attribute,\n              component,\n              transitionOut,\n            )\n\n            delete attribute[NAVIGATE].url\n            delete attribute[NAVIGATE].identifier\n            return\n          }\n\n          // Decode string.\n          let html = result.html\n          if (modifiers.decode) {\n            html = decode(result.html)\n          }\n\n          let target = null\n          if (modifiers.document) {\n            target = document.documentElement\n          } else {\n            const attributeName = libraryOptions.prefix + '-' + directive + NAME_TARGET\n            if (element.hasAttribute(attributeName)) {\n              target = processExpression(\n                component,\n                attribute,\n                element.getAttribute(attributeName),\n              )\n              if (typeof (target) === 'string') {\n                target = element.querySelector(target)\n              }\n            }\n            if (!target) {\n              target = element\n            }\n          }\n\n          // Update target.\n          if (modifiers.morph) {\n            if (modifiers.outer) {\n              morphTree(target, html)\n            } else {\n              // Ensure element only has one child.\n              if (target.children.length === 0) {\n                target.appendChild(document.createElement('div'))\n              } else if (target.children.length > 1) {\n                for (let i = target.children.length - 1; i >= 1; i--) {\n                  target.children[i].remove()\n                }\n              }\n\n              // Morph first child to given target tree.\n              const root = morphTree(target.children[0], html)\n              if (!target.children[0].isSameNode(root)) {\n                target.children[0].remove()\n                target.appendChild(root)\n              }\n            }\n          } else if (modifiers.outer) {\n            target.outerHTML = html\n          } else {\n            target.innerHTML = html\n          }\n\n          // Get new document title.\n          let documentTitle = ''\n          if (options.headerTitle && result.headers.has(options.headerTitle)) {\n            documentTitle = result.headers.get(options.headerTitle)\n          }\n\n          // Update history api.\n          if (modifiers.document && modifiers.history) {\n            history.pushState({}, documentTitle, url)\n          }\n\n          // If document title was not updated via the history update, then set it now.\n          if (documentTitle && document.title !== documentTitle) {\n            document.title = documentTitle\n          }\n\n          loaderRemove(\n            attribute,\n            component,\n            transitionOut,\n          )\n\n          delete attribute[NAVIGATE].url\n          delete attribute[NAVIGATE].identifier\n\n          // Dispatch navigation loaded event.\n          dispatchEvent('-loaded', {\n            url,\n          })\n        })\n      }\n\n      const loadHandler = (\n        event,\n      ) => {\n        const anchor = event.target.closest('a')\n        if (!anchor || !anchor.hasAttribute('href')) {\n          return\n        }\n        const href = anchor.getAttribute('href')\n        const url = new URL(href, window.location)\n\n        // Check if same website.\n        if (window.location.hostname !== url.hostname) {\n          return\n        }\n\n        // Exit early if the link is being loaded.\n        if (\n          attribute[NAVIGATE].url &&\n          attribute[NAVIGATE].url.href === url.href\n        ) {\n          return\n        }\n\n        // Prevent default.\n        event.preventDefault()\n        if (modifiers.stop) {\n          event.stopPropagation()\n        }\n\n        loadFromUrl(url)\n      }\n      element.addEventListener(\n        'click',\n        loadHandler,\n        listenerOptions,\n      )\n\n      // Listen to history api if it can target the whole page.\n      let historyHandler\n      if (modifiers.document && modifiers.history) {\n        historyHandler = (\n          event,\n        ) => {\n          const url = new URL(event.target.location)\n\n          // Exit early if the link is being loaded already.\n          if (\n            attribute[NAVIGATE].url &&\n            attribute[NAVIGATE].url.href === url.href\n          ) {\n            return\n          }\n\n          loadFromUrl(url)\n        }\n        window.addEventListener(\n          'popstate',\n          historyHandler,\n          { passive: true },\n        )\n      }\n\n      let destroyPreloader\n      if (modifiers.preload === PRELOAD_INTERACT) {\n        const preloadHandler = (event) => {\n          const anchor = event.target.closest('a')\n          if (!anchor || !anchor.hasAttribute('href')) {\n            return\n          }\n          const href = anchor.getAttribute('href')\n          getFromUrl(new URL(href, window.location), dispatchEvent, fetchHeaders)\n        }\n        element.addEventListener(\n          'focusin',\n          preloadHandler,\n          Object.assign({ passive: true }, listenerOptions),\n        )\n        element.addEventListener(\n          'pointerenter',\n          preloadHandler,\n          Object.assign({ passive: true }, listenerOptions),\n        )\n\n        destroyPreloader = (\n        ) => {\n          element.removeEventListener(\n            'focusin',\n            attribute[NAVIGATE].preloadHandler,\n          )\n          element.removeEventListener(\n            'pointerenter',\n            attribute[NAVIGATE].preloadHandler,\n          )\n        }\n      } else if (modifiers.preload === PRELOAD_INTERSECT) {\n        const intersectionObserver = new IntersectionObserver(\n          (anchors) => {\n            for (const anchor of anchors) {\n              if (anchor.isIntersecting) {\n                getFromUrl(\n                  new URL(\n                    anchor.target.getAttribute('href'),\n                    window.location,\n                  ),\n                  dispatchEvent,\n                  fetchHeaders,\n                )\n              }\n            }\n          },\n          {\n            root: null,\n            rootMargin: options.intersectionMargin,\n            threshold: options.intersectionThreshold,\n          },\n        )\n        const mutationObserver = new MutationObserver(\n          (mutations) => {\n            for (const mutation of mutations) {\n              if (mutation.type === 'attributes') {\n                if (\n                  mutation.attributeName === 'href' &&\n                  mutation.target instanceof HTMLElement &&\n                  mutation.target.tagName === 'A'\n                ) {\n                  // Start or stop observing the element if the href was added or removed.\n                  if (mutation.target.hasAttribute('href')) {\n                    intersectionObserver.observe(mutation.target)\n                  } else {\n                    intersectionObserver.unobserve(mutation.target)\n                  }\n                }\n              } else if (mutation.type === 'childList') {\n                for (const node of mutation.addedNodes) {\n                  if (\n                    node instanceof HTMLElement &&\n                    node.tagName === 'A' &&\n                    node.hasAttribute('href')\n                  ) {\n                    // Start observing the node.\n                    intersectionObserver.observe(node)\n                  }\n                }\n\n                // Stop observing removed nodes.\n                for (const node of mutation.removedNodes) {\n                  if (\n                    node instanceof HTMLElement &&\n                    node.tagName === 'A' &&\n                    node.hasAttribute('href')\n                  ) {\n                    intersectionObserver.unobserve(node)\n                  }\n                }\n              }\n            }\n          },\n        )\n\n        destroyPreloader = (\n        ) => {\n          mutationObserver.disconnect()\n          intersectionObserver.disconnect()\n        }\n\n        // Start observing existing anchor tags.\n        const anchors = element.querySelectorAll('a[href]')\n        for (const anchor of anchors) {\n          intersectionObserver.observe(anchor)\n        }\n\n        mutationObserver.observe(\n          element,\n          {\n            attributes: true,\n            childList: true,\n            subtree: true,\n          },\n        )\n      }\n\n      attribute[NAVIGATE] = {\n        cache,\n        element,\n        historyHandler,\n        loadHandler,\n        destroyPreloader,\n      }\n    },\n\n    destroy: (\n      component,\n      attribute, {\n        transitionOut,\n      },\n    ) => {\n      // Exit early if no listeners can be found.\n      if (!attribute[NAVIGATE]) {\n        return\n      }\n\n      // Stop clear cache interval.\n      if (clearCacheCounter > 0) {\n        clearCacheCounter--\n        if (clearCacheCounter === 0 && clearCacheInterval) {\n          clearInterval(clearCacheInterval)\n          cache = {}\n        }\n      }\n\n      // Remove existing listener.\n      attribute[NAVIGATE].element.removeEventListener(\n        'click',\n        attribute[NAVIGATE].loadHandler,\n      )\n      if (attribute[NAVIGATE].historyHandler) {\n        window.removeEventListener(\n          'popstate',\n          attribute[NAVIGATE].historyHandler,\n        )\n      }\n      if (attribute[NAVIGATE].destroyPreloader) {\n        attribute[NAVIGATE].destroyPreloader()\n      }\n\n      loaderRemove(\n        attribute,\n        component,\n        transitionOut,\n      )\n\n      // Delete directive data.\n      delete attribute[NAVIGATE]\n    },\n  }\n}\n", "import Doars from '@doars/doars/src/Doars.js'\nimport createNavigateDirective from './factories/directives/navigate.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nconst DoarsNavigate = function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    cacheInterval: 60 * 1e3,\n    cacheMaxAge: 30 * 60 * 1e3,\n    fetchOptions: {},\n    headerTitle: null,\n    intersectionMargin: '0px',\n    intersectionThreshold: 0,\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  // Store contexts and directives.\n  let navigateDirective\n\n  const onEnable = (\n  ) => {\n    // Create and add contexts and directives.\n    navigateDirective = createNavigateDirective(options)\n    library.addDirectives(-1, navigateDirective)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeDirective(navigateDirective)\n    navigateDirective = null\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n\nexport default DoarsNavigate\n"],
  "mappings": "AAAO,IAAMA,EAAa,OAAO,YAAY,EAEhCC,EAAY,OAAO,WAAW,EAE9BC,EAAM,OAAO,KAAK,EAElBC,GAAc,OAAO,aAAa,EAElCC,GAAK,OAAO,IAAI,EAEhBC,EAAa,OAAO,YAAY,EAChCC,EAAmB,OAAO,kBAAkB,EAE5CC,GAAO,OAAO,MAAM,ECe1B,IAAMC,EAAiB,CAC5BC,EACAC,IACG,CACH,IAAMC,EAAqBF,EAAa,WAClCG,EAAgBF,EAAQ,WAC1BG,EAAwB,KACxBC,EAAiB,KACjBC,EAAY,KACZC,EAAgB,KAChBC,EAAY,KAEhB,QAASC,EAAIN,EAAc,OAAS,EAAGM,GAAK,EAAG,EAAEA,EAC/CD,EAAYL,EAAcM,CAAC,EAC3BF,EAAgBC,EAAU,KAC1BJ,EAAwBI,EAAU,aAClCH,EAAiBG,EAAU,MACvBJ,GACFG,EAAgBC,EAAU,WAAaD,EACvCD,EAAYN,EAAa,eAAeI,EAAuBG,CAAa,EACxED,IAAcD,GAChBL,EAAa,eAAeI,EAAuBG,EAAeF,CAAc,GAG7EL,EAAa,aAAaO,CAAa,GAG1CD,EAAYN,EAAa,aAAaO,CAAa,EAC/CD,IAAcD,IAEZA,IAAmB,QAAUA,IAAmB,YAClDL,EAAa,gBAAgBO,CAAa,EAE1CP,EAAa,aAAaO,EAAeF,CAAc,IAR3DL,EAAa,aAAaO,EAAeF,CAAc,EAiB7D,QAASK,EAAIR,EAAmB,OAAS,EAAGQ,GAAK,EAAG,EAAEA,EACpDF,EAAYN,EAAmBQ,CAAC,EAC5BF,EAAU,YAAc,KAC1BD,EAAgBC,EAAU,KAC1BJ,EAAwBI,EAAU,aAE9BJ,GACFG,EAAgBC,EAAU,WAAaD,EAClCN,EAAQ,eAAeG,EAAuBG,CAAa,GAC9DP,EAAa,kBAAkBI,EAAuBG,CAAa,GAGhEN,EAAQ,eAAe,KAAMM,CAAa,GAC7CP,EAAa,gBAAgBO,CAAa,EAKpD,ECnFO,IAAMI,EACXC,GACG,CACH,IAAMC,EAAcD,EAAO,UAAU,EAAG,EAAE,EAAE,YAAY,EAKxD,GAHEC,EAAY,WAAW,iBAAiB,GACxCA,EAAY,WAAW,QAAQ,EAEjB,CACd,IAAMC,EAAO,SAAS,cAAc,MAAM,EAC1C,OAAAA,EAAK,UAAYF,EACVE,CACT,CAEA,IAAMC,EAAW,SAAS,cAAc,UAAU,EAClD,OAAAA,EAAS,UAAYH,EACdG,EAAS,QAAQ,WAAW,CAAC,CACtC,EAOaC,EAAc,CACzBC,EACAC,IACG,CACCD,EAAU,YACZA,EAAU,WAAW,aAAaC,EAAMD,EAAU,WAAW,EAE7DA,EAAU,WAAW,YAAYC,CAAI,CAEzC,EAQaC,EAAS,CACpBC,EACAC,IAEID,EAAE,YAAcA,EAAE,WAAWC,CAAC,EACzB,GAGLD,EAAE,OAAS,EACNA,EAAE,YAAcC,EAAE,UAGvBD,EAAE,UAAYC,EAAE,QCzDtB,IAAMC,GAAgB,SAAS,UAAU,SAAS,KAAK,QAA8B,EAClF,QAAQ,WAAY,SAAS,EAC7B,QAAQ,SAAU,IAAI,ECHzB,IAAMC,GAAgB,CACpB,QAAS,IACT,QAAS,IACT,OAAQ,IACR,QAAS,IACT,OAAQ,IACR,QAAS,IACT,SAAU,IACV,QAAS,IACT,SAAU,IACV,QAAS,GACX,EACMC,GAAgB,iDAWf,IAAMC,EACXC,GAEI,OAAQA,GAAY,SACfA,EAGFA,EAAO,WAAWC,GAAgBC,GAChCC,GAAcD,CAAS,CAC/B,EChCI,IAAME,EAAmB,WACnBC,EAAoB,YCD1B,IAAMC,EAAW,OAAO,UAAU,ECclC,IAAMC,GAAY,CACvBC,EACAC,IACG,CACH,IAAMC,EAAWD,EAAQ,SACnBE,EAAWF,EAAQ,SAGrBC,IAAa,GACfE,EAAeJ,EAAcC,CAAO,GAIlCC,IAAa,GAAKA,IAAa,IAC7BF,EAAa,YAAcC,EAAQ,YACrCD,EAAa,UAAYC,EAAQ,WAMjCE,IAAa,QACfE,GAAaL,EAAcC,CAAO,EACzBE,IAAa,SACtBG,EAAiBN,EAAcC,EAAS,UAAU,EACzCE,IAAa,YACtBI,GAAgBP,EAAcC,CAAO,CAEzC,EASaO,EAAY,CACvBC,EACAC,EACAC,IACG,CACH,GAAI,OAAQF,GAAkB,SAC5B,MAAM,IAAI,MAAM,oCAAoC,EAGtD,GAAI,OAAQC,GAAa,SACvBA,EAAUE,EAAkBF,CAAO,UAC1B,OAAQA,GAAa,SAC9B,MAAM,IAAI,MAAM,+BAA+B,EAIjD,OAAKC,GAAWA,EAAQ,cAAiBD,EAAQ,WAAa,IAC5DG,EAAgBJ,EAAcC,CAAO,EAC9BD,GAGFK,EAAYL,EAAcC,CAAO,CAC1C,EAOML,GAAe,CACnBL,EACAC,IACG,CAGH,IAAMc,EAAWd,EAAQ,MACnBe,EAAgBhB,EAAa,MAEnCM,EAAiBN,EAAcC,EAAS,SAAS,EACjDK,EAAiBN,EAAcC,EAAS,UAAU,EAI9CD,EAAa,gBAAkBC,EAAQ,gBACzCD,EAAa,cAAgBC,EAAQ,eAInCD,EAAa,OAAS,SAItBgB,IAAkBD,IACpBf,EAAa,aAAa,QAASe,CAAQ,EAC3Cf,EAAa,MAAQe,GAGnBA,IAAa,SACff,EAAa,MAAQ,GACrBA,EAAa,gBAAgB,OAAO,GAGjCC,EAAQ,eAAe,KAAM,OAAO,EAE9BD,EAAa,OAAS,UAE/BA,EAAa,MAAQe,GAHrBf,EAAa,gBAAgB,OAAO,EAKxC,EAOMO,GAAkB,CACtBP,EACAC,IACG,CACH,IAAMc,EAAWd,EAAQ,MACrBD,EAAa,QAAUe,IACzBf,EAAa,MAAQe,GAGnBf,EAAa,YAAcA,EAAa,WAAW,YAAce,IACnEf,EAAa,WAAW,UAAYe,EAExC,EAQMT,EAAmB,CACvBN,EACAC,EACAgB,IACG,CACCjB,EAAaiB,CAAI,IAAMhB,EAAQgB,CAAI,IACrCjB,EAAaiB,CAAI,EAAIhB,EAAQgB,CAAI,EAC7BhB,EAAQgB,CAAI,EACdjB,EAAa,aAAaiB,EAAM,EAAE,EAElCjB,EAAa,gBAAgBiB,CAAI,EAGvC,EAQMH,EAAc,CAClBL,EACAC,IAEKD,EAIAC,EAIDD,EAAa,YAAcA,EAAa,WAAWC,CAAO,EACrDD,EAGLA,EAAa,UAAYC,EAAQ,QAC5BA,GAGTX,GAAUU,EAAcC,CAAO,EAC/BG,EAAgBJ,EAAcC,CAAO,EAE9BD,GAdE,KAJAC,EA0BLG,EAAkB,CACtBb,EACAC,IACG,CACH,IAAIiB,EAAeC,EAAUC,EAASC,EAGlCC,EAAS,EAEb,QAAS,EAAI,EACXJ,EAAgBlB,EAAa,WAAW,CAAC,EACzCmB,EAAWlB,EAAQ,WAAW,EAAIqB,CAAM,EAGpC,GAACJ,GAAiB,CAACC,GALP,IAST,GAAI,CAACA,EACVnB,EAAa,YAAYkB,CAAa,EACtC,YAGS,CAACA,EACVlB,EAAa,YAAYmB,CAAQ,EACjCG,YAGSC,EAAcL,EAAeC,CAAQ,EAC9CC,EAAUN,EAAYI,EAAeC,CAAQ,EACzCC,IAAYF,IACdlB,EAAa,aAAaoB,EAASF,CAAa,EAChDI,SAIG,CACLD,EAAgB,KAGhB,QAASG,EAAI,EAAGA,EAAIxB,EAAa,WAAW,OAAQwB,IAClD,GAAID,EAAcvB,EAAa,WAAWwB,CAAC,EAAGL,CAAQ,EAAG,CACvDE,EAAgBrB,EAAa,WAAWwB,CAAC,EACzC,KACF,CAIEH,GACFD,EAAUN,EAAYO,EAAeF,CAAQ,EACzCC,IAAYC,GACdC,IAEFtB,EAAa,aAAaoB,EAASF,CAAa,GAGvC,CAACC,EAAS,IAAM,CAACD,EAAc,IACxCE,EAAUN,EAAYI,EAAeC,CAAQ,EACzCC,IAAYF,IACdlB,EAAa,aAAaoB,EAASF,CAAa,EAChDI,OAKFtB,EAAa,aAAamB,EAAUD,CAAa,EACjDI,IAEJ,CAEJ,EC9PA,IAAMG,GAAc,UACdC,GAAc,UACdC,EAAc,OACdC,EAAuB,gBACvBC,GAA6B,CACjC,WACA,kBACA,UACF,EAEMC,GAAY,CAChBC,EACAC,EACAC,EACAC,EACAC,IACG,CACH,GAAM,CAAE,OAAAC,CAAO,EAAIJ,EAAU,WAAW,EAAE,WAAW,EAC/CK,EAAUN,EAAU,WAAW,EAC/BO,EAAYP,EAAU,aAAa,EAEnCQ,EAAgBN,EAAe,OAAS,IAAMK,EAAYb,GAChE,GAAI,CAACY,EAAQ,aAAaE,CAAa,EACrC,OAEF,IAAIC,EAAiBN,EACnBF,EACAD,EACAM,EAAQ,aAAaE,CAAa,CACpC,EAcA,GAbI,CAACC,IAID,OAAQA,GAAoB,WAC9BA,EAAiBH,EAAQ,cAAcG,CAAc,GAInDA,EAAe,UAAY,aAI3BA,EAAe,WAAa,EAE9B,OAIF,GAAIT,EAAUU,CAAQ,EAAE,oBACtBV,EAAUU,CAAQ,EAAE,oBAAoB,EACxCV,EAAUU,CAAQ,EAAE,oBAAsB,aACjCV,EAAUU,CAAQ,EAAE,cAC7B,OAIF,IAAIC,EAAgB,SAAS,WAAWF,EAAe,QAAS,EAAI,EAEpEG,EAAYH,EAAgBE,CAAa,EAEzCX,EAAUU,CAAQ,EAAE,cAAgBC,EAAgBF,EAAe,mBAGnET,EAAUU,CAAQ,EAAE,mBAAqBN,EAAaC,EAAQM,CAAa,CAC7E,EAEME,EAAe,CACnBb,EACAC,EACAa,IACG,CAEH,GACEd,EAAUU,CAAQ,EAAE,qBACpB,CAACV,EAAUU,CAAQ,EAAE,cAErB,OAIF,IAAMC,EAAgBX,EAAUU,CAAQ,EAAE,cAC1CV,EAAUU,CAAQ,EAAE,mBAClBI,EACEb,EAAU,WAAW,EAAE,WAAW,EAAE,OACpCU,EACA,IAAM,CACAA,GACFA,EAAc,OAAO,CAEzB,CACF,CACJ,EAEMI,GAAwB,CAC5BC,EACAC,EAAS,OACN,CACH,GACE,CAACD,EAAQ,IAAIpB,CAAW,GACxB,CAACoB,EAAQ,IAAInB,CAAoB,EAEjC,MAAO,GAET,IAAMqB,EAAY,IAAI,KAAKF,EAAQ,IAAIpB,CAAW,CAAC,EAC7CuB,EAAc,IAAI,KAGxB,GAAID,EAAYC,EACd,MAAO,GAGT,GAAIF,EAAQ,CAEV,IAAMG,EAAa,IAAI,KAAKF,EAAU,QAAQ,EAAID,CAAM,EACxD,GAAIE,EAAcC,EAChB,MAAO,EAEX,CAGA,IAAMC,EAAgBL,EAAQ,IAAInB,CAAoB,EAAG,MAAM,GAAG,EAC9DyB,EAAc,EAClB,QAAWC,KAAoBF,EAI7B,GAHIE,EAAiB,KAAK,EAAE,WAAW,UAAU,IAC/CD,EAAc,SAASC,EAAiB,MAAM,GAAG,EAAE,CAAC,EAAE,KAAK,EAAG,EAAE,GAE9DA,EAAiB,KAAK,EAAE,WAAW,WAAW,EAAG,CACnDD,EAAc,SAASC,EAAiB,MAAM,GAAG,EAAE,CAAC,EAAE,KAAK,EAAG,EAAE,EAChE,KACF,CAGF,OAAID,GAAe,EACV,GAIU,IAAI,KAAKJ,EAAU,QAAQ,EAAKI,EAAc,GAAI,GAChDH,CACvB,EAEIK,EAAoB,EACpBC,EAAqB,KAElBC,GACLC,GACG,CACH,IAAIC,EAAQ,CAAC,EACPC,EAAqB,IACtB,CAEH,GAAIL,EAAoB,EAAG,CACzBA,IACA,MACF,CAGAC,EAAqB,YACnB,IAAM,CACJ,QAAWK,KAAYF,EAEnB,CAAC,OAAO,eAAe,KAAKA,EAAOE,CAAQ,GAC3C,CAACF,EAAM,SAIJb,GAAsBa,EAAM,QAASD,EAAQ,WAAW,GAC3D,OAAOC,EAAME,CAAQ,CAG3B,EACAH,EAAQ,aACV,CACF,EACMI,EAAa,CACjBC,EACAC,EACAjB,IAEO,IAAI,QAASkB,GAAY,CAO9B,GALI,OAAO,SAAS,WAAaF,EAAI,UACnCE,EAAQ,IAAI,EAIV,OAAO,eAAe,KAAKN,EAAOI,EAAI,QAAQ,EAAG,CACnD,GACEJ,EAAMI,EAAI,QAAQ,EAAE,SACpBjB,GAAsBa,EAAMI,EAAI,QAAQ,EAAE,OAAO,EACjD,CACAE,EAAQN,EAAMI,EAAI,QAAQ,CAAC,EAC3B,MACF,CAEIJ,EAAMI,EAAI,QAAQ,EAAE,UACtBJ,EAAMI,EAAI,QAAQ,EAAE,UAAU,KAC5B,IAAM,CACJE,EAAQN,EAAMI,EAAI,QAAQ,CAAC,CAC7B,CACF,EAEAJ,EAAMI,EAAI,QAAQ,EAAI,CACpB,UAAW,CAAC,CACd,CAEJ,MACEJ,EAAMI,EAAI,QAAQ,EAAI,CACpB,UAAW,CAAC,CACd,EAIFC,EAAc,WAAY,CACxB,IAAAD,CACF,CAAC,EAED,MACEA,EACA,OAAO,OAAO,CAAC,EAAGL,EAAQ,aAAc,CACtC,QAAS,OAAO,OAAO,CAAC,EAAGX,EAASW,EAAQ,aAAa,OAAO,CAClE,CAAC,CACH,EAAE,KAAMQ,GAAa,CACnB,GACEA,EAAS,OAAS,KAClBA,EAAS,QAAU,IACnB,CAEAF,EAAc,UAAW,CACvB,SAAAE,EACA,IAAAH,CACF,CAAC,EAEDE,EAAQ,IAAI,EACZ,MACF,CAGoBC,EAAS,QAAQ,IAAI,cAAc,EACtC,YAAY,EAAE,WAAW,WAAW,EAKrD,IAAIC,EAAa,GACjB,GAAID,EAAS,QAAQ,IAAItC,CAAoB,EAAG,CAC9C,IAAMwB,EAAec,EAAS,QAAQ,IAAItC,CAAoB,EAAE,MAAM,GAAG,EACrEoB,EAAS,EACb,QAAWM,KAAoBF,EAAc,CAC3C,IAAMgB,EAAcd,EAAiB,KAAK,EAE1C,GAAIzB,GAA2B,QAAQuC,CAAW,GAAK,EAAG,CACxDD,EAAa,GACb,KACF,CAEA,GAAIC,EAAY,WAAW,WAAW,IACpCpB,EAAS,SAASoB,EAAY,MAAM,GAAG,EAAE,CAAC,EAAE,KAAK,EAAG,EAAE,EAClDpB,GAAU,GAAG,CACfmB,EAAa,GACb,KACF,CAGF,GACEC,EAAY,WAAW,UAAU,GACjCpB,GAAU,IAEVA,EAAS,SAASoB,EAAY,MAAM,GAAG,EAAE,CAAC,EAAE,KAAK,EAAG,EAAE,EAClDpB,GAAU,GAAG,CACfmB,EAAa,GACb,KACF,CAEJ,CACF,CAEAD,EAAS,KAAK,EAAE,KAAMG,GAAS,CAE7B,IAAMC,EAAS,CACb,QAASJ,EAAS,QAClB,KAAAG,CACF,EAGME,EAAYZ,EAAMI,EAAI,QAAQ,EAAE,UActC,GAXII,GACFR,EAAMI,EAAI,QAAQ,EAAIO,EACtBV,EAAmB,GAEnB,OAAOD,EAAMI,EAAI,QAAQ,EAI3BE,EAAQK,CAAM,EAGVC,EACF,QAAWC,KAAYD,EACrBC,EAAS,CAGf,CAAC,CACH,CAAC,CACH,CAAC,EAGH,MAAO,CACL,KAAM,WAEN,OAAQ,CACNxC,EACAD,EAAW,CACT,kBAAAG,EACA,aAAAC,EACA,cAAAU,CACF,IACG,CACH,IAAMR,EAAUN,EAAU,WAAW,EACrC,GAAIM,EAAQI,CAAQ,EAClB,OAKF,IAAMR,EADUD,EAAU,WAAW,EACN,WAAW,EAGpCM,EAAYP,EAAU,aAAa,EACnC0C,EAAY1C,EAAU,aAAa,EAKnC2C,EAAkB,CAAC,EACrBD,EAAU,UACZC,EAAgB,QAAU,IAG5B,IAAMC,EAAkB1C,EAAe,OAAS,WAC1C2C,EAAe,CACnB,CAACD,CAAe,EAAGrC,EACnB,KAAMqC,CACR,EAEMX,EAAgB,CACpBa,EAAS,GACTC,EAAO,CAAC,IACL,CACHzC,EAAQ,cACN,IAAI,YACFJ,EAAe,OAAS,IAAMK,EAAYuC,EAC1C,CACE,OAAQ,OAAO,OAAO,CACpB,UAAA9C,EACA,UAAAC,CACF,EAAG8C,CAAI,CACT,CACF,CACF,CACF,EAEMC,EACJhB,GACG,CACHhC,EAAUU,CAAQ,EAAE,IAAMsB,EAC1B,IAAMiB,EAAc,IAAI,KAAK,EAAG,YAAY,EAC5CjD,EAAUU,CAAQ,EAAE,WAAauC,EAEjClD,GACEC,EACAC,EACAC,EACAC,EACAC,CACF,EAEA2B,EAAWC,EAAKC,EAAeY,CAAY,EAAE,KAAMN,GAAW,CAE5D,GACE,CAACvC,EAAUU,CAAQ,EAAE,YACrBV,EAAUU,CAAQ,EAAE,aAAeuC,EAEnC,OAIF,GAAI,CAACV,EAAQ,CACX1B,EACEb,EACAC,EACAa,CACF,EAEA,OAAOd,EAAUU,CAAQ,EAAE,IAC3B,OAAOV,EAAUU,CAAQ,EAAE,WAC3B,MACF,CAGA,IAAI4B,EAAOC,EAAO,KACdG,EAAU,SACZJ,EAAOY,EAAOX,EAAO,IAAI,GAG3B,IAAIY,EAAS,KACb,GAAIT,EAAU,SACZS,EAAS,SAAS,oBACb,CACL,IAAM3C,EAAgBN,EAAe,OAAS,IAAMK,EAAYZ,GAC5DW,EAAQ,aAAaE,CAAa,IACpC2C,EAAShD,EACPF,EACAD,EACAM,EAAQ,aAAaE,CAAa,CACpC,EACI,OAAQ2C,GAAY,WACtBA,EAAS7C,EAAQ,cAAc6C,CAAM,IAGpCA,IACHA,EAAS7C,EAEb,CAGA,GAAIoC,EAAU,MACZ,GAAIA,EAAU,MACZU,EAAUD,EAAQb,CAAI,MACjB,CAEL,GAAIa,EAAO,SAAS,SAAW,EAC7BA,EAAO,YAAY,SAAS,cAAc,KAAK,CAAC,UACvCA,EAAO,SAAS,OAAS,EAClC,QAASE,EAAIF,EAAO,SAAS,OAAS,EAAGE,GAAK,EAAGA,IAC/CF,EAAO,SAASE,CAAC,EAAE,OAAO,EAK9B,IAAMC,EAAOF,EAAUD,EAAO,SAAS,CAAC,EAAGb,CAAI,EAC1Ca,EAAO,SAAS,CAAC,EAAE,WAAWG,CAAI,IACrCH,EAAO,SAAS,CAAC,EAAE,OAAO,EAC1BA,EAAO,YAAYG,CAAI,EAE3B,MACSZ,EAAU,MACnBS,EAAO,UAAYb,EAEnBa,EAAO,UAAYb,EAIrB,IAAIiB,EAAgB,GAChB5B,EAAQ,aAAeY,EAAO,QAAQ,IAAIZ,EAAQ,WAAW,IAC/D4B,EAAgBhB,EAAO,QAAQ,IAAIZ,EAAQ,WAAW,GAIpDe,EAAU,UAAYA,EAAU,SAClC,QAAQ,UAAU,CAAC,EAAGa,EAAevB,CAAG,EAItCuB,GAAiB,SAAS,QAAUA,IACtC,SAAS,MAAQA,GAGnB1C,EACEb,EACAC,EACAa,CACF,EAEA,OAAOd,EAAUU,CAAQ,EAAE,IAC3B,OAAOV,EAAUU,CAAQ,EAAE,WAG3BuB,EAAc,UAAW,CACvB,IAAAD,CACF,CAAC,CACH,CAAC,CACH,EAEMwB,EACJC,GACG,CACH,IAAMC,EAASD,EAAM,OAAO,QAAQ,GAAG,EACvC,GAAI,CAACC,GAAU,CAACA,EAAO,aAAa,MAAM,EACxC,OAEF,IAAMC,EAAOD,EAAO,aAAa,MAAM,EACjC1B,EAAM,IAAI,IAAI2B,EAAM,OAAO,QAAQ,EAGrC,OAAO,SAAS,WAAa3B,EAAI,WAMnChC,EAAUU,CAAQ,EAAE,KACpBV,EAAUU,CAAQ,EAAE,IAAI,OAASsB,EAAI,OAMvCyB,EAAM,eAAe,EACjBf,EAAU,MACZe,EAAM,gBAAgB,EAGxBT,EAAYhB,CAAG,GACjB,EACA1B,EAAQ,iBACN,QACAkD,EACAb,CACF,EAGA,IAAIiB,EACAlB,EAAU,UAAYA,EAAU,UAClCkB,EACEH,GACG,CACH,IAAMzB,EAAM,IAAI,IAAIyB,EAAM,OAAO,QAAQ,EAIvCzD,EAAUU,CAAQ,EAAE,KACpBV,EAAUU,CAAQ,EAAE,IAAI,OAASsB,EAAI,MAKvCgB,EAAYhB,CAAG,CACjB,EACA,OAAO,iBACL,WACA4B,EACA,CAAE,QAAS,EAAK,CAClB,GAGF,IAAIC,EACJ,GAAInB,EAAU,UAAYoB,EAAkB,CAC1C,IAAMC,EAAkBN,GAAU,CAChC,IAAMC,EAASD,EAAM,OAAO,QAAQ,GAAG,EACvC,GAAI,CAACC,GAAU,CAACA,EAAO,aAAa,MAAM,EACxC,OAEF,IAAMC,EAAOD,EAAO,aAAa,MAAM,EACvC3B,EAAW,IAAI,IAAI4B,EAAM,OAAO,QAAQ,EAAG1B,EAAeY,CAAY,CACxE,EACAvC,EAAQ,iBACN,UACAyD,EACA,OAAO,OAAO,CAAE,QAAS,EAAK,EAAGpB,CAAe,CAClD,EACArC,EAAQ,iBACN,eACAyD,EACA,OAAO,OAAO,CAAE,QAAS,EAAK,EAAGpB,CAAe,CAClD,EAEAkB,EAAmB,IACd,CACHvD,EAAQ,oBACN,UACAN,EAAUU,CAAQ,EAAE,cACtB,EACAJ,EAAQ,oBACN,eACAN,EAAUU,CAAQ,EAAE,cACtB,CACF,CACF,SAAWgC,EAAU,UAAYsB,EAAmB,CAClD,IAAMC,EAAuB,IAAI,qBAC9BC,GAAY,CACX,QAAWR,KAAUQ,EACfR,EAAO,gBACT3B,EACE,IAAI,IACF2B,EAAO,OAAO,aAAa,MAAM,EACjC,OAAO,QACT,EACAzB,EACAY,CACF,CAGN,EACA,CACE,KAAM,KACN,WAAYlB,EAAQ,mBACpB,UAAWA,EAAQ,qBACrB,CACF,EACMwC,EAAmB,IAAI,iBAC1BC,GAAc,CACb,QAAWC,KAAYD,EACrB,GAAIC,EAAS,OAAS,aAElBA,EAAS,gBAAkB,QAC3BA,EAAS,kBAAkB,aAC3BA,EAAS,OAAO,UAAY,MAGxBA,EAAS,OAAO,aAAa,MAAM,EACrCJ,EAAqB,QAAQI,EAAS,MAAM,EAE5CJ,EAAqB,UAAUI,EAAS,MAAM,WAGzCA,EAAS,OAAS,YAAa,CACxC,QAAWC,KAAQD,EAAS,WAExBC,aAAgB,aAChBA,EAAK,UAAY,KACjBA,EAAK,aAAa,MAAM,GAGxBL,EAAqB,QAAQK,CAAI,EAKrC,QAAWA,KAAQD,EAAS,aAExBC,aAAgB,aAChBA,EAAK,UAAY,KACjBA,EAAK,aAAa,MAAM,GAExBL,EAAqB,UAAUK,CAAI,CAGzC,CAEJ,CACF,EAEAT,EAAmB,IACd,CACHM,EAAiB,WAAW,EAC5BF,EAAqB,WAAW,CAClC,EAGA,IAAMC,EAAU5D,EAAQ,iBAAiB,SAAS,EAClD,QAAWoD,KAAUQ,EACnBD,EAAqB,QAAQP,CAAM,EAGrCS,EAAiB,QACf7D,EACA,CACE,WAAY,GACZ,UAAW,GACX,QAAS,EACX,CACF,CACF,CAEAN,EAAUU,CAAQ,EAAI,CACpB,MAAAkB,EACA,QAAAtB,EACA,eAAAsD,EACA,YAAAJ,EACA,iBAAAK,CACF,CACF,EAEA,QAAS,CACP5D,EACAD,EAAW,CACT,cAAAc,CACF,IACG,CAEEd,EAAUU,CAAQ,IAKnBc,EAAoB,IACtBA,IACIA,IAAsB,GAAKC,IAC7B,cAAcA,CAAkB,EAChCG,EAAQ,CAAC,IAKb5B,EAAUU,CAAQ,EAAE,QAAQ,oBAC1B,QACAV,EAAUU,CAAQ,EAAE,WACtB,EACIV,EAAUU,CAAQ,EAAE,gBACtB,OAAO,oBACL,WACAV,EAAUU,CAAQ,EAAE,cACtB,EAEEV,EAAUU,CAAQ,EAAE,kBACtBV,EAAUU,CAAQ,EAAE,iBAAiB,EAGvCG,EACEb,EACAC,EACAa,CACF,EAGA,OAAOd,EAAUU,CAAQ,EAC3B,CACF,CACF,ECxtBA,IAAM6D,GAAgB,SACpBC,EACAC,EAAU,KACV,CAEAA,EAAU,OAAO,OAAO,CACtB,cAAe,GAAK,IACpB,YAAa,GAAK,GAAK,IACvB,aAAc,CAAC,EACf,YAAa,KACb,mBAAoB,MACpB,sBAAuB,CACzB,EAAGA,CAAO,EAGV,IAAIC,EAAY,GAEZC,EAEEC,EAAW,IACZ,CAEHD,EAAoBE,GAAwBJ,CAAO,EACnDD,EAAQ,cAAc,GAAIG,CAAiB,CAC7C,EAEMG,EAAY,IACb,CAEHN,EAAQ,gBAAgBG,CAAiB,EACzCA,EAAoB,IACtB,EAEA,KAAK,QAAU,IACV,CAEC,CAACH,EAAQ,WAAW,GAAKE,IAC3BA,EAAY,GAGZF,EAAQ,oBAAoB,WAAYI,CAAQ,EAChDJ,EAAQ,oBAAoB,YAAaM,CAAS,EAEtD,EAEA,KAAK,OAAS,IACT,CACEJ,IACHA,EAAY,GAGZF,EAAQ,iBAAiB,WAAYI,CAAQ,EAC7CJ,EAAQ,iBAAiB,YAAaM,CAAS,EAEnD,EAGA,KAAK,OAAO,CACd,EAEOC,GAAQR",
  "names": ["ATTRIBUTES", "COMPONENT", "FOR", "INITIALIZED", "ON", "REFERENCES", "REFERENCES_CACHE", "SYNC", "copyAttributes", "existingNode", "newNode", "existingAttributes", "newAttributes", "attributeNamespaceURI", "attributeValue", "fromValue", "attributeName", "attribute", "i", "j", "fromString", "string", "stringStart", "html", "template", "insertAfter", "reference", "node", "isSame", "a", "b", "nativePromise", "DECODE_LOOKUP", "DECODE_REGEXP", "decode", "string", "DECODE_REGEXP", "character", "DECODE_LOOKUP", "PRELOAD_INTERACT", "PRELOAD_INTERSECT", "NAVIGATE", "morphNode", "existingNode", "newNode", "nodeType", "nodeName", "copyAttributes", "_updateInput", "_updateAttribute", "_updateTextarea", "morphTree", "existingTree", "newTree", "options", "fromString", "_updateChildren", "_updateTree", "newValue", "existingValue", "name", "existingChild", "newChild", "morphed", "existingMatch", "offset", "isSame", "j", "NAME_LOADER", "NAME_TARGET", "HEADER_DATE", "HEADER_CACHE_CONTROL", "CACHE_INVALIDATION_CLAUSES", "loaderAdd", "attribute", "component", "libraryOptions", "processExpression", "transitionIn", "prefix", "element", "directive", "attributeName", "loaderTemplate", "NAVIGATE", "loaderElement", "insertAfter", "loaderRemove", "transitionOut", "validCacheFromHeaders", "headers", "maxAge", "cacheDate", "currentDate", "expireDate", "cacheControl", "cacheMaxAge", "cacheControlItem", "clearCacheCounter", "clearCacheInterval", "navigate_default", "options", "cache", "setupCacheClearing", "location", "getFromUrl", "url", "dispatchEvent", "resolve", "response", "allowCache", "cacheClause", "html", "result", "listeners", "listener", "modifiers", "listenerOptions", "directiveHeader", "fetchHeaders", "suffix", "data", "loadFromUrl", "identifier", "decode", "target", "morphTree", "i", "root", "documentTitle", "loadHandler", "event", "anchor", "href", "historyHandler", "destroyPreloader", "PRELOAD_INTERACT", "preloadHandler", "PRELOAD_INTERSECT", "intersectionObserver", "anchors", "mutationObserver", "mutations", "mutation", "node", "DoarsNavigate", "library", "options", "isEnabled", "navigateDirective", "onEnable", "navigate_default", "onDisable", "DoarsNavigate_default"]
}
