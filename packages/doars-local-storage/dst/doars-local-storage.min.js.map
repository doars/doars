{
  "version": 3,
  "sources": ["../../common/src/factories/createStateContext.js", "../src/factories/contexts/localStorage.js", "../../common/src/polyfills/RevocableProxy.js", "../../common/src/events/EventDispatcher.js", "../../common/src/events/ProxyDispatcher.js", "../src/utilities/localStorage.js", "../src/DoarsLocalStorage.js"],
  "sourcesContent": ["export default (\n  name,\n  id,\n  state,\n  proxy,\n  deconstruct,\n) => ({\n  deconstruct,\n\n  name,\n\n  create: (\n    component,\n    attribute,\n    update, {\n      RevocableProxy,\n    },\n  ) => {\n    // Create event handlers.\n    const onDelete = (\n      target,\n      path,\n    ) => update(id, name + '.' + path.join('.'))\n    const onGet = (\n      target,\n      path,\n    ) => attribute.accessed(id, name + '.' + path.join('.'))\n    const onSet = (\n      target,\n      path,\n    ) => update(id, name + '.' + path.join('.'))\n\n    // Add event listeners.\n    proxy.addEventListener('delete', onDelete)\n    proxy.addEventListener('get', onGet)\n    proxy.addEventListener('set', onSet)\n\n    // Wrap in a revocable proxy.\n    const revocable = RevocableProxy(state, {})\n\n    return {\n      value: revocable.proxy,\n\n      // Remove event listeners.\n      destroy: (\n      ) => {\n        proxy.removeEventListener('delete', onDelete)\n        proxy.removeEventListener('get', onGet)\n        proxy.removeEventListener('set', onSet)\n\n        // Revoke access to state.\n        revocable.revoke()\n      },\n    }\n  },\n})\n", "import createStateContext from '@doars/common/src/factories/createStateContext.js'\n\nexport default (\n  id,\n  state,\n  proxy,\n  deconstruct,\n) => createStateContext(\n  '$localStorage',\n  id,\n  state,\n  proxy,\n  deconstruct,\n)\n", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\nexport default (\n  target,\n  handler,\n) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  const revocableHandler = {}\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('proxy revoked')\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n", "export default class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor(\n  ) {\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n    this.addEventListener = (\n      name,\n      callback,\n      options = null,\n    ) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (\n      name,\n      callback,\n    ) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n    this.removeEventListeners = (\n      name,\n    ) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n    this.removeAllEventListeners = (\n    ) => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n    this.dispatchEvent = (\n      name,\n      parameters,\n      options = null,\n    ) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'\n\n// Import event dispatcher.\nimport EventDispatcher from './EventDispatcher.js'\n\nexport default class ProxyDispatcher extends EventDispatcher {\n  constructor(\n    options = {},\n  ) {\n    super()\n\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true,\n    }, options)\n\n    // Setup WeakMap for keep track of created proxies.\n    const map = new WeakMap()\n\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n    this.add = (\n      target,\n      path = [],\n    ) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target)\n      }\n\n      // Recursively create proxies for each property.\n      for (const key in target) {\n        if (target[key] && typeof (target[key]) === 'object') {\n          target[key] = this.add(target[key], [...path, key])\n        }\n      }\n\n      // Create handler and add the handler for which a callback exits..\n      const handler = {}\n\n      if (options.delete) {\n        handler.deleteProperty = (\n          target,\n          key,\n        ) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true\n          }\n\n          // Remove proxy.\n          this.remove(target, key)\n\n          // Delete property.\n          const deleted = Reflect.deleteProperty(target, key)\n\n          // Dispatch delete event.\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]])\n          }\n\n          // Return deleted.\n          return deleted\n        }\n      }\n\n      if (options.get) {\n        handler.get = (\n          target,\n          key,\n          receiver,\n        ) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver])\n          }\n\n          // Return value from object.\n          return Reflect.get(target, key, receiver)\n        }\n      }\n\n      if (options.set) {\n        handler.set = (\n          target,\n          key,\n          value,\n          receiver,\n        ) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true\n          }\n\n          // Add proxy if value is an object.\n          if (value && typeof value === 'object') {\n            value = this.add(value, [...path, key])\n          }\n          // Store value.\n          target[key] = value\n\n          // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver])\n\n          // Return success.\n          return true\n        }\n      }\n\n      // Create proxy.\n      const revocable = RevocableProxy(target, handler)\n\n      // Store target at proxy.\n      map.set(revocable, target)\n\n      // Return proxy.\n      return revocable.proxy\n    }\n\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n    this.remove = (\n      target,\n    ) => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return\n      }\n\n      const revocable = map.get(target)\n      map.delete(revocable)\n\n      // Recursively remove properties as well.\n      for (const property in revocable.proxy) {\n        if (typeof (revocable.proxy[property]) === 'object') {\n          this.remove(revocable.proxy[property])\n        }\n      }\n\n      // Revoke proxy.\n      revocable.revoke()\n    }\n  }\n}\n", "export const getAll = (\n) => {\n  const data = {}\n  const keys = Object.keys(localStorage)\n  for (let i = keys.length - 1; i >= 0; i--) {\n    data[keys[i]] = localStorage.getItem(keys[i])\n  }\n  return data\n}\n", "// Import contexts.\nimport createContextLocalStorage from './factories/contexts/localStorage.js'\n\n// Import proxy dispatcher.\nimport ProxyDispatcher from '@doars/common/src/events/ProxyDispatcher.js'\n\nimport { getAll } from './utilities/localStorage.js'\n\nconst id = Symbol('ID_LOCAL_STORAGE')\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = Object.assign({\n    deconstruct: false,\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  let context, data, proxy, state\n\n  const onDelete = (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested local storage impossible tried to set \"' + path.join('.') + '\".')\n    }\n    localStorage.removeItem(path[0])\n  }\n  const onSet = (target, path) => {\n    if (path.length > 1) {\n      console.warn('Nested local storage impossible tried to set \"' + path.join('.') + '\".')\n    }\n    localStorage.setItem(path[0], target[path[0]])\n  }\n\n  const onEnable = (\n  ) => {\n    // Create proxy.\n    data = getAll()\n    proxy = new ProxyDispatcher()\n    state = proxy.add(data)\n\n    // Add event listeners.\n    proxy.addEventListener('delete', onDelete)\n    proxy.addEventListener('set', onSet)\n\n    // Create contexts.\n    context = createContextLocalStorage(id, state, proxy, !!options.deconstruct)\n    // Get index of state and insert the context directly before it.\n    const existingContexts = library.getContexts()\n    let stateIndex = 0\n    for (let i = existingContexts.length - 1; i >= 0; i--) {\n      const context = existingContexts[i]\n      if (context.name === '$state') {\n        stateIndex = i\n        break\n      }\n    }\n    library.addContexts(stateIndex, context)\n  }\n\n  const onDisable = (\n  ) => {\n    // Remove contexts.\n    library.removeContexts(context)\n\n    // Remove event listeners.\n    proxy.removeEventListener('delete', onDelete)\n    proxy.removeEventListener('set', onSet)\n\n    // Reset references.\n    state = null\n    proxy.remove(data)\n    proxy = null\n    data = null\n    context = null\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"],
  "mappings": "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",
  "names": ["createStateContext_default", "name", "id", "state", "proxy", "deconstruct", "component", "attribute", "update", "RevocableProxy", "onDelete", "target", "path", "onGet", "onSet", "revocable", "localStorage_default", "id", "state", "proxy", "deconstruct", "createStateContext_default", "REFLECTION_METHODS", "RevocableProxy_default", "target", "handler", "revoked", "revocableHandler", "key", "parameters", "EventDispatcher", "events", "name", "callback", "options", "eventData", "index", "parameters", "event", "ProxyDispatcher", "EventDispatcher", "options", "map", "target", "path", "key", "handler", "deleted", "receiver", "value", "revocable", "RevocableProxy_default", "property", "getAll", "data", "keys", "i", "id", "DoarsLocalStorage_default", "library", "options", "isEnabled", "context", "data", "proxy", "state", "onDelete", "target", "path", "onSet", "onEnable", "getAll", "ProxyDispatcher", "localStorage_default", "existingContexts", "stateIndex", "i", "onDisable"]
}
