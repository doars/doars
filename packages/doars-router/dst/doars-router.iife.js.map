{
  "version": 3,
  "sources": ["../../common/src/polyfills/RevocableProxy.js", "../src/symbols.js", "../src/utilities/closestRouter.js", "../src/contexts/router.js", "../../../node_modules/path-to-regexp/src/index.ts", "../../common/src/events/EventDispatcher.js", "../src/Router.js", "../src/factories/directives/router.js", "../../common/src/utilities/Element.js", "../src/directives/route.js", "../src/directives/routeTo.js", "../../common/src/utilities/Object.js", "../src/DoarsRouter.js", "../src/DoarsRouter.iife.js"],
  "sourcesContent": ["// List of methods to revoke access to.\nconst REFLECTION_METHODS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\nexport default (target, handler) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  const revocableHandler = {}\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy')\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n", "export const ROUTE_TO = Symbol('ROUTE_TO')\n\nexport const ROUTER = Symbol('ROUTER')\n\nexport const ROUTE = Symbol('ROUTE')\n", "// Import symbols.\nimport { ROUTER } from '../symbols.js'\n\n/**\n * Get closest router in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Router} Closest router.\n */\nconst closestRouter = (element) => {\n  if (!element.parentElement) {\n    return\n  }\n  element = element.parentElement\n\n  if (element[ROUTER]) {\n    return element[ROUTER]\n  }\n\n  return closestRouter(element)\n}\n\nexport default closestRouter\n", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n\n// Import symbol.\nimport { ROUTER } from '../symbols'\n\n// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\n\nexport default {\n  name: '$router',\n\n  create: (component, attribute) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    let router = null\n    const revocable = RevocableProxy({}, {\n      get: (target, propertyKey, receiver) => {\n        // Get closest router from hierarchy.\n        if (router === null) {\n          if (element[ROUTER]) {\n            router = element[ROUTER]\n          } else {\n            router = closestRouter(element)\n          }\n\n          // Set router to false so we don't look twice.\n          if (!router) {\n            router = false\n          }\n        }\n\n        // Mark as router accessed.\n        attribute.accessed(router.getId(), '')\n\n        if (!router) {\n          return\n        }\n\n        // Return router property.\n        return Reflect.get(router, propertyKey, receiver)\n      },\n    })\n\n    return {\n      value: revocable.proxy,\n\n      destroy: () => {\n        revocable.revoke()\n      },\n    }\n  },\n}\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n    this.removeEventListeners = (name) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n\nexport default EventDispatcher\n", "// Import external modules.\nimport { pathToRegexp } from 'path-to-regexp'\n\n// Import event dispatcher.\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'\n\nclass Router extends EventDispatcher {\n  constructor(options = {}) {\n    super()\n\n    // Create id.\n    const id = Symbol('ID_ROUTER')\n\n    // Overwrite default with given options.\n    options = Object.assign({\n      basePath: '',\n      path: null,\n      pathToRegexp: {},\n      updateHistory: false,\n    }, options)\n\n    let path = options.path\n    let route = null\n    let routes = {}\n\n    // Listen for history state changes.\n    const handleHistory = () => {\n      this.setPath(window.location.pathname)\n    }\n    if (options.updateHistory) {\n      window.addEventListener('popstate', handleHistory)\n    }\n\n    /**\n     * Update route.\n     * @param {String} url URL.\n     * @param {String} _path Path.\n     * @param {String} _route Route.\n     */\n    const updateRoute = (url, newPath, newRoute) => {\n      // Update stored data.\n      path = newPath\n      route = newRoute\n\n      // Update page history if the option is set.\n      if (options.updateHistory) {\n        // Construct url.\n        const _url = url.includes(options.basePath) ? url : options.basePath + url\n        // Check if url is not current url.\n        if (_url !== window.location.pathname) {\n          // Add path to history.\n          window.history.pushState(null, window.document.title, _url)\n        }\n      }\n\n      // Dispatch event on router.\n      this.dispatchEvent('changed', [this, route, path])\n    }\n\n    /**\n     * Get router id.\n     * @returns {Symbol} Unique identifier.\n     */\n    this.getId = () => {\n      return id\n    }\n\n    /**\n     * Get current path.\n     * @returns {String} path.\n     */\n    this.getPath = () => {\n      return path\n    }\n\n    /**\n     * Get current route.\n     * @returns {String} Route.\n     */\n    this.getRoute = () => {\n      return route\n    }\n\n    /**\n     * Get observed routes.\n     * @returns {Array<String>} List of routers.\n     */\n    this.getRoutes = () => {\n      return Object.keys(routes)\n    }\n\n    /**\n     * Destroy router instance.\n     */\n    this.destroy = () => {\n      // Stop listening to state changes.\n      if (options.updateHistory) {\n        window.removeEventListener('popstate', handleHistory)\n      }\n\n      options = null\n      path = null\n      route = null\n      routes = null\n\n      // Dispatch add event.\n      this.dispatchEvent('destroyed', [this])\n\n      // Remove all listeners.\n      this.removeAllEventListeners()\n    }\n\n    /**\n     * Add route.\n     * @param {String} _route Route pattern.\n     */\n    this.addRoute = (_route) => {\n      // Convert path to regexp and store it in routes.\n      routes[_route] = pathToRegexp(_route, [], options.pathToRegexp)\n\n      // Dispatch add event.\n      this.dispatchEvent('added', [this, _route])\n\n      if (path) {\n        // Remove base url, if present.\n        const _path = path.replace(options.basePath, '')\n        // Check if current route is.\n        if (routes[_route].test(_path)) {\n          updateRoute(path, _path, _route)\n        }\n      }\n    }\n\n    /**\n     * Remove route.\n     * @param {String} _route Route pattern.\n     */\n    this.removeRoute = (_route) => {\n      // Delete route.\n      delete routes[_route]\n\n      // Dispatch removed event.\n      this.dispatchEvent('removed', [this, _route])\n\n      if (route === _route) {\n        // Set current route as none.\n        path = null\n        route = null\n\n        // Dispatch changed event.\n        this.dispatchEvent('changed', [this, route, path])\n      }\n    }\n\n    /**\n     * Set current route.\n     * @param {String} url URL path.\n     */\n    this.setPath = (url) => {\n      // Remove base url, if present.\n      const newPath = url.replace(options.basePath, '')\n      if (path === newPath) {\n        return\n      }\n\n      // Find matching routes.\n      let newRoute = null\n      for (const _route in routes) {\n        // Test route.\n        if (routes[_route].test(newPath)) {\n          newRoute = _route\n          break\n        }\n      }\n\n      // Update route.\n      updateRoute(url, newPath, newRoute)\n    }\n  }\n}\n\nexport default Router\n", "// Import router.\nimport Router from '../../Router.js'\n\n// Import symbols.\nimport { ROUTER } from '../../symbols.js'\n\nexport default (routerOptions) => {\n  return {\n    name: 'router',\n\n    update: (component, attribute, { processExpression }) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement()\n\n      // Get router.\n      let router = element[ROUTER]\n      if (!router) {\n        // Construct options.\n        const options = Object.assign({}, routerOptions, processExpression(component, attribute.clone(), attribute.getValue()))\n        // Create router\n        router = element[ROUTER] = new Router(options)\n      }\n    },\n\n    destroy: (component, attribute) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement()\n\n      // Get router.\n      const router = element[ROUTER]\n      if (!router) {\n        return\n      }\n\n      // Remove router reference.\n      delete element[ROUTER]\n\n      // Deconstruct router.\n      const id = router.getId()\n\n      // Destroy router.\n      router.destroy()\n\n      // Deconstruct component.\n      const library = component.getLibrary()\n\n      // Trigger update due to changed router.\n      library.update([{ id, path: '' }])\n    },\n  }\n}\n", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = (string) => {\n  const template = document.createElement('template')\n  template.innerHTML = string\n  return template.content.childNodes[0]\n}\n\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling)\n  } else {\n    reference.parentNode.appendChild(node)\n  }\n}\n\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b)\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false\n  }\n\n  if (a.type === 3) { // Text node.\n    return a.nodeValue === b.nodeValue\n  }\n\n  return false\n}\n\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\nexport const walk = (element, filter) => {\n  let index = -1\n  let iterator = null\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator()\n      if (child) {\n        return child\n      }\n    }\n\n    // Get next child that passes the filter.\n    let child = null\n    do {\n      index++\n      if (index >= element.childElementCount) {\n        return null\n      }\n\n      child = element.children[index]\n    } while (!filter(child))\n\n    // Setup iterator for child.\n    if (child.childElementCount) {\n      iterator = walk(child, filter)\n    }\n\n    // Return the child.\n    return child\n  }\n}\n\nexport default {\n  fromString,\n  insertAfter,\n  isSame,\n  walk,\n}\n", "// Import symbols.\nimport { ROUTE } from '../symbols.js'\n\n// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\nimport { insertAfter } from '@doars/common/src/utilities/Element.js'\n\nexport default {\n  name: 'route',\n\n  update: (component, attribute, { transitionIn, transitionOut }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    let router\n    const setup = () => {\n      // Stop listening to router and remove it.\n      if (router && attribute[ROUTE]) {\n        router.removeEventListener('changed', attribute[ROUTE].handler)\n        router.removeEventListener('destroyed', attribute[ROUTE].setup)\n\n        delete attribute[ROUTE]\n      }\n\n      // Get closest router in parent nodes.\n      router = closestRouter(element)\n      if (!router) {\n        console.warn('DoarsRouter: Router not found for route.')\n        return\n      }\n\n      // Setup route data.\n      attribute[ROUTE] = {\n        setup,\n      }\n\n      // Deconstruct attribute.\n      const value = attribute.getValue()\n\n      // Add route to router.\n      router.addRoute(value)\n\n      // Handle router changes.\n      const handleChange = (router, route) => {\n        if (route !== value) {\n          if (element.tagName === 'TEMPLATE') {\n            if (attribute[ROUTE] && attribute[ROUTE].element) {\n              // Transition out.\n              const routeElement = attribute[ROUTE].element\n              transitionOut(component, routeElement, () => {\n                // Remove node.\n                routeElement.remove()\n                attribute[ROUTE].element = undefined\n              })\n            }\n          } else {\n            // Transition out and set display none.\n            transitionOut(component, element, () => {\n              element.style.display = 'none'\n            })\n          }\n        } else if (element.tagName === 'TEMPLATE') {\n          // Create new element from template.\n          const templateInstance = document.importNode(element.content, true)\n          // Add element after the template element.\n          insertAfter(element, templateInstance)\n          // Get HTMLElement reference instead of DocumentFragment.\n          attribute[ROUTE].element = element.nextSibling\n\n          // Transition in.\n          transitionIn(component, attribute[ROUTE].element)\n        } else {\n          // Remove display none.\n          element.style.display = null\n\n          // Transition in.\n          transitionIn(component, element)\n        }\n      }\n      attribute[ROUTE].handler = handleChange\n\n      // Listen to router changes and perform initial run.\n      router.addEventListener('changed', handleChange)\n      handleChange(router, router.getRoute())\n\n      // If the router is destroyed look for another\n      router.addEventListener('destroyed', setup)\n    }\n\n    // Perform initial setup.\n    setup()\n  },\n\n  destroy: (component, attribute, { transitionOut }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    if (element.tagName === 'TEMPLATE') {\n      if (attribute[ROUTE] && attribute[ROUTE].element) {\n        // Transition out.\n        const routeElement = attribute[ROUTE].element\n        transitionOut(component, routeElement, () => {\n          // Remove node.\n          routeElement.remove()\n          attribute[ROUTE].element = undefined\n        })\n      }\n    } else {\n      // Transition out and set display none.\n      transitionOut(component, element, () => {\n        element.style.display = 'none'\n      })\n    }\n\n    // Get closest router in parent nodes.\n    const router = closestRouter(element)\n    if (!router) {\n      return\n    }\n\n    // Remove router listeners.\n    if (attribute[ROUTE]) {\n      router.removeEventListener('destroyed', attribute[ROUTE].setup)\n      if (attribute[ROUTE].handler) {\n        router.removeEventListener('change', attribute[ROUTE].handler)\n      }\n    }\n  },\n}\n", "// Import symbols.\nimport { ROUTE_TO } from '../symbols.js'\n\n// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\n\nconst CLICK = 'click'\n\nexport default {\n  name: 'route-to',\n\n  update: (component, attribute) => {\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n    const value = attribute.getValue()\n\n    // Check for existing data.\n    if (attribute[ROUTE_TO]) {\n      // Exit early if listener has not changed.\n      if (attribute[ROUTE_TO].value === value) {\n        return\n      }\n\n      // Remove existing listeners so we don't listen twice.\n      attribute[ROUTE_TO].target.removeEventListener(CLICK, attribute[ROUTE_TO].handler)\n    }\n\n    const handler = (event) => {\n      if (modifiers.self && event.target !== element) {\n        return\n      }\n\n      if (modifiers.prevent) {\n        event.preventDefault()\n      }\n      if (modifiers.stop) {\n        event.stopPropagation()\n      }\n\n      const router = closestRouter(element)\n      if (!router) {\n        return\n      }\n\n      router.setPath(value)\n    }\n\n    // Listen to click and keyboard events.\n    element.addEventListener(CLICK, handler)\n\n    // Store listener data on the component.\n    attribute[ROUTE_TO] = {\n      handler,\n      value,\n    }\n  },\n\n  destroy: (component, attribute) => {\n    if (!attribute[ROUTE_TO]) {\n      return\n    }\n\n    const element = attribute.getElement()\n\n    element.removeEventListener(CLICK, attribute[ROUTE_TO].handler)\n\n    delete attribute[ROUTE_TO]\n  },\n}\n", "/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (target, ...sources) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\nexport const getDeeply = (object, path) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\nexport const isObject = (value) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\nexport const setDeeply = (object, path, value) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n", "// Import contexts.\nimport contextRouter from './contexts/router.js'\n\n// Import directives.\nimport createDirectiveRouter from './factories/directives/router.js'\nimport directiveRoute from './directives/route.js'\nimport directiveRouteTo from './directives/routeTo.js'\n\n// Import utilities.\nimport { deepAssign } from '@doars/common/src/utilities/Object.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null\n) {\n  // Clone options.\n  options = deepAssign({}, options)\n\n  // Set private variables.\n  let isEnabled = false\n  let directiveRouter\n\n  const onEnable = function () {\n    // Add contexts and directives.\n    library.addContexts(0, contextRouter)\n    directiveRouter = createDirectiveRouter(options)\n    library.addDirectives(-1, directiveRouter, directiveRoute, directiveRouteTo)\n  }\n  const onDisable = function () {\n    // Remove contexts and directives.\n    library.removeContexts(contextRouter)\n    library.removeDirectives(directiveRouter, directiveRoute, directiveRouteTo)\n    directiveRouter = null\n  }\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n", "import DoarsRouter from './DoarsRouter.js'\n\nwindow.DoarsRouter = DoarsRouter\n"],
  "mappings": "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",
  "names": ["value", "_a", "result", "router_default", "router", "router_default"]
}
