{
  "version": 3,
  "sources": ["../../common/src/utilities/Object.js", "../../common/src/polyfills/RevocableProxy.js", "../src/symbols.js", "../../../node_modules/.bun/path-to-regexp@6.3.0/node_modules/path-to-regexp/dist.es2015/index.js", "../../common/src/events/EventDispatcher.js", "../src/Router.js", "../src/utilities/closestRouter.js", "../src/contexts/router.js", "../../common/src/utilities/String.js", "../../common/src/utilities/Attribute.js", "../../common/src/utilities/Transition.js", "../src/directives/route.js", "../src/directives/router.js", "../src/directives/routeTo.js", "../src/DoarsRouter.js", "../src/DoarsRouter.iife.js"],
  "sourcesContent": [
    "/**\n * Deeply assign a series of objects properties together.\n * @param {object} target Target object to merge to.\n * @param {...object} sources Objects to merge into the target.\n * @returns {object} Merged resulting object.\n */\nexport const deepAssign = (\n  target,\n  ...sources\n) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {object} object Object to get from.\n * @param  {Array<string>} path Path to value.\n * @returns {any} value at path.\n */\nexport const getDeeply = (\n  object,\n  path,\n) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {any} value Value of unknown type.\n * @returns {boolean} Whether the value is an object.\n */\nexport const isObject = (\n  value,\n) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {object} object Object to set on.\n * @param {Array<string>} path Path to value.\n * @param {any} value Value to set.\n */\nexport const setDeeply = (\n  object,\n  path,\n  value,\n) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n",
    "/**\n * Function to call to revoke the proxy.\n * @callback RevocableProxyCallback\n */\n\n/**\n * @typedef RevocableProxy\n * @type {object}\n * @property {Proxy} proxy Proxy that will be revocable.\n * @property {RevocableProxyCallback} revoke Function to call to revoke the proxy.\n */\n\n/**\n * Function called when a proxy has been handled.\n * @callback ProxyHandlerCallback\n */\n\n/**\n * @typedef ProxyHandler\n * @type {object}\n * @property {?ProxyHandlerCallback} apply A trap method for a function call.\n * @property {?ProxyHandlerCallback} construct A trap for the `new` operator.\n * @property {?ProxyHandlerCallback} defineProperty A trap for `Object.defineProperty()`.\n * @property {?ProxyHandlerCallback} deleteProperty A trap for the `delete` operator.\n * @property {?ProxyHandlerCallback} get A trap for getting a property value.\n * @property {?ProxyHandlerCallback} getOwnPropertyDescriptor A trap for `Object.getOwnPropertyDescriptor()`.\n * @property {?ProxyHandlerCallback} getPrototypeOf A trap for the `[[GetPrototypeOf]]` internal method.\n * @property {?ProxyHandlerCallback} has A trap for the `in` operator.\n * @property {?ProxyHandlerCallback} isExtensible A trap for `Object.isExtensible()`.\n * @property {?ProxyHandlerCallback} ownKeys A trap for `Reflect.ownKeys()`.\n * @property {?ProxyHandlerCallback} preventExtensions A trap for `Object.preventExtensions()`.\n * @property {?ProxyHandlerCallback} set A trap for setting a property value.\n * @property {?ProxyHandlerCallback} setPrototypeOf A trap for `Object.setPrototypeOf()`.\n */\n\n// List of methods to revoke access to.\nconst PROXY_TRAPS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'has',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n * @param {object} target Object to proxy.\n * @param {ProxyHandler} handler Object of handler methods.\n * @returns {?RevocableProxy} Proxy object and revoke method.\n */\nexport default (\n  target,\n  handler,\n) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  /**\n   * Copy of allowed handlers with a revocable layer in between.\n   * @type {ProxyHandler}\n   */\n  const revocableHandler = {}\n  for (const key of PROXY_TRAPS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n",
    "export const ROUTER = Symbol('ROUTER')\n",
    "/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n    var tokens = [];\n    var i = 0;\n    while (i < str.length) {\n        var char = str[i];\n        if (char === \"*\" || char === \"+\" || char === \"?\") {\n            tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"\\\\\") {\n            tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n            continue;\n        }\n        if (char === \"{\") {\n            tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \"}\") {\n            tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n            continue;\n        }\n        if (char === \":\") {\n            var name = \"\";\n            var j = i + 1;\n            while (j < str.length) {\n                var code = str.charCodeAt(j);\n                if (\n                // `0-9`\n                (code >= 48 && code <= 57) ||\n                    // `A-Z`\n                    (code >= 65 && code <= 90) ||\n                    // `a-z`\n                    (code >= 97 && code <= 122) ||\n                    // `_`\n                    code === 95) {\n                    name += str[j++];\n                    continue;\n                }\n                break;\n            }\n            if (!name)\n                throw new TypeError(\"Missing parameter name at \".concat(i));\n            tokens.push({ type: \"NAME\", index: i, value: name });\n            i = j;\n            continue;\n        }\n        if (char === \"(\") {\n            var count = 1;\n            var pattern = \"\";\n            var j = i + 1;\n            if (str[j] === \"?\") {\n                throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n            }\n            while (j < str.length) {\n                if (str[j] === \"\\\\\") {\n                    pattern += str[j++] + str[j++];\n                    continue;\n                }\n                if (str[j] === \")\") {\n                    count--;\n                    if (count === 0) {\n                        j++;\n                        break;\n                    }\n                }\n                else if (str[j] === \"(\") {\n                    count++;\n                    if (str[j + 1] !== \"?\") {\n                        throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n                    }\n                }\n                pattern += str[j++];\n            }\n            if (count)\n                throw new TypeError(\"Unbalanced pattern at \".concat(i));\n            if (!pattern)\n                throw new TypeError(\"Missing pattern at \".concat(i));\n            tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n            i = j;\n            continue;\n        }\n        tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n    }\n    tokens.push({ type: \"END\", index: i, value: \"\" });\n    return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str, options) {\n    if (options === void 0) { options = {}; }\n    var tokens = lexer(str);\n    var _a = options.prefixes, prefixes = _a === void 0 ? \"./\" : _a, _b = options.delimiter, delimiter = _b === void 0 ? \"/#?\" : _b;\n    var result = [];\n    var key = 0;\n    var i = 0;\n    var path = \"\";\n    var tryConsume = function (type) {\n        if (i < tokens.length && tokens[i].type === type)\n            return tokens[i++].value;\n    };\n    var mustConsume = function (type) {\n        var value = tryConsume(type);\n        if (value !== undefined)\n            return value;\n        var _a = tokens[i], nextType = _a.type, index = _a.index;\n        throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n    };\n    var consumeText = function () {\n        var result = \"\";\n        var value;\n        while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n            result += value;\n        }\n        return result;\n    };\n    var isSafe = function (value) {\n        for (var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++) {\n            var char = delimiter_1[_i];\n            if (value.indexOf(char) > -1)\n                return true;\n        }\n        return false;\n    };\n    var safePattern = function (prefix) {\n        var prev = result[result.length - 1];\n        var prevText = prefix || (prev && typeof prev === \"string\" ? prev : \"\");\n        if (prev && !prevText) {\n            throw new TypeError(\"Must have text between two parameters, missing text after \\\"\".concat(prev.name, \"\\\"\"));\n        }\n        if (!prevText || isSafe(prevText))\n            return \"[^\".concat(escapeString(delimiter), \"]+?\");\n        return \"(?:(?!\".concat(escapeString(prevText), \")[^\").concat(escapeString(delimiter), \"])+?\");\n    };\n    while (i < tokens.length) {\n        var char = tryConsume(\"CHAR\");\n        var name = tryConsume(\"NAME\");\n        var pattern = tryConsume(\"PATTERN\");\n        if (name || pattern) {\n            var prefix = char || \"\";\n            if (prefixes.indexOf(prefix) === -1) {\n                path += prefix;\n                prefix = \"\";\n            }\n            if (path) {\n                result.push(path);\n                path = \"\";\n            }\n            result.push({\n                name: name || key++,\n                prefix: prefix,\n                suffix: \"\",\n                pattern: pattern || safePattern(prefix),\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        var value = char || tryConsume(\"ESCAPED_CHAR\");\n        if (value) {\n            path += value;\n            continue;\n        }\n        if (path) {\n            result.push(path);\n            path = \"\";\n        }\n        var open = tryConsume(\"OPEN\");\n        if (open) {\n            var prefix = consumeText();\n            var name_1 = tryConsume(\"NAME\") || \"\";\n            var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n            var suffix = consumeText();\n            mustConsume(\"CLOSE\");\n            result.push({\n                name: name_1 || (pattern_1 ? key++ : \"\"),\n                pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,\n                prefix: prefix,\n                suffix: suffix,\n                modifier: tryConsume(\"MODIFIER\") || \"\",\n            });\n            continue;\n        }\n        mustConsume(\"END\");\n    }\n    return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile(str, options) {\n    return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction(tokens, options) {\n    if (options === void 0) { options = {}; }\n    var reFlags = flags(options);\n    var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;\n    // Compile all the tokens into regexps.\n    var matches = tokens.map(function (token) {\n        if (typeof token === \"object\") {\n            return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n        }\n    });\n    return function (data) {\n        var path = \"\";\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (typeof token === \"string\") {\n                path += token;\n                continue;\n            }\n            var value = data ? data[token.name] : undefined;\n            var optional = token.modifier === \"?\" || token.modifier === \"*\";\n            var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n            if (Array.isArray(value)) {\n                if (!repeat) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n                }\n                if (value.length === 0) {\n                    if (optional)\n                        continue;\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n                }\n                for (var j = 0; j < value.length; j++) {\n                    var segment = encode(value[j], token);\n                    if (validate && !matches[i].test(segment)) {\n                        throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                    }\n                    path += token.prefix + segment + token.suffix;\n                }\n                continue;\n            }\n            if (typeof value === \"string\" || typeof value === \"number\") {\n                var segment = encode(String(value), token);\n                if (validate && !matches[i].test(segment)) {\n                    throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n                }\n                path += token.prefix + segment + token.suffix;\n                continue;\n            }\n            if (optional)\n                continue;\n            var typeOfMessage = repeat ? \"an array\" : \"a string\";\n            throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n        }\n        return path;\n    };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match(str, options) {\n    var keys = [];\n    var re = pathToRegexp(str, keys, options);\n    return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction(re, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.decode, decode = _a === void 0 ? function (x) { return x; } : _a;\n    return function (pathname) {\n        var m = re.exec(pathname);\n        if (!m)\n            return false;\n        var path = m[0], index = m.index;\n        var params = Object.create(null);\n        var _loop_1 = function (i) {\n            if (m[i] === undefined)\n                return \"continue\";\n            var key = keys[i - 1];\n            if (key.modifier === \"*\" || key.modifier === \"+\") {\n                params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n                    return decode(value, key);\n                });\n            }\n            else {\n                params[key.name] = decode(m[i], key);\n            }\n        };\n        for (var i = 1; i < m.length; i++) {\n            _loop_1(i);\n        }\n        return { path: path, index: index, params: params };\n    };\n}\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str) {\n    return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options) {\n    return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path, keys) {\n    if (!keys)\n        return path;\n    var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n    var index = 0;\n    var execResult = groupsRegex.exec(path.source);\n    while (execResult) {\n        keys.push({\n            // Use parenthesized substring match if available, index otherwise\n            name: execResult[1] || index++,\n            prefix: \"\",\n            suffix: \"\",\n            modifier: \"\",\n            pattern: \"\",\n        });\n        execResult = groupsRegex.exec(path.source);\n    }\n    return path;\n}\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(paths, keys, options) {\n    var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });\n    return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(path, keys, options) {\n    return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(tokens, keys, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d, _e = options.delimiter, delimiter = _e === void 0 ? \"/#?\" : _e, _f = options.endsWith, endsWith = _f === void 0 ? \"\" : _f;\n    var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n    var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n    var route = start ? \"^\" : \"\";\n    // Iterate over the tokens and create our regexp string.\n    for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n        var token = tokens_1[_i];\n        if (typeof token === \"string\") {\n            route += escapeString(encode(token));\n        }\n        else {\n            var prefix = escapeString(encode(token.prefix));\n            var suffix = escapeString(encode(token.suffix));\n            if (token.pattern) {\n                if (keys)\n                    keys.push(token);\n                if (prefix || suffix) {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        var mod = token.modifier === \"*\" ? \"?\" : \"\";\n                        route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n                    }\n                    else {\n                        route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n                    }\n                }\n                else {\n                    if (token.modifier === \"+\" || token.modifier === \"*\") {\n                        throw new TypeError(\"Can not repeat \\\"\".concat(token.name, \"\\\" without a prefix and suffix\"));\n                    }\n                    route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n                }\n            }\n            else {\n                route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n            }\n        }\n    }\n    if (end) {\n        if (!strict)\n            route += \"\".concat(delimiterRe, \"?\");\n        route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n    }\n    else {\n        var endToken = tokens[tokens.length - 1];\n        var isEndDelimited = typeof endToken === \"string\"\n            ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n            : endToken === undefined;\n        if (!strict) {\n            route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n        }\n        if (!isEndDelimited) {\n            route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n        }\n    }\n    return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path, keys, options) {\n    if (path instanceof RegExp)\n        return regexpToRegexp(path, keys);\n    if (Array.isArray(path))\n        return arrayToRegexp(path, keys, options);\n    return stringToRegexp(path, keys, options);\n}\n//# sourceMappingURL=index.js.map",
    "/**\n * @typedef EventListenerOptions\n * @type {object}\n * @property {?boolean} once Whether to call the listener only once.\n */\n\n/**\n * @typedef DispatchEventOptions\n * @type {object}\n * @property {?boolean} reverse Whether to call the listeners in reverse order.\n */\n\nexport default class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor(\n  ) {\n    /**\n     * Object to store event listeners for the EventDispatcher class.\n     * @type {Record<string, Array<{callback: Function, options: EventListenerOptions }>>}\n     */\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {EventListenerOptions} options Callback options.\n     */\n    this.addEventListener = (\n      name,\n      callback,\n      options = null,\n    ) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (\n      name,\n      callback,\n    ) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {string} name Event name.\n     */\n    this.removeEventListeners = (\n      name,\n    ) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     */\n    this.removeAllEventListeners = (\n    ) => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {string} name Event name.\n     * @param {Array<any>} parameters Event parameters to pass through.\n     * @param {DispatchEventOptions} options Dispatch options.\n     */\n    this.dispatchEvent = (\n      name,\n      parameters,\n      options = null,\n    ) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n",
    "// Import external modules.\nimport { pathToRegexp } from 'path-to-regexp'\n\n// Import event dispatcher.\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'\n\nexport default class Router extends EventDispatcher {\n  /**\n   * @param {object} options Router options.\n   * - {string} basePath = '' - Base path of the routes.\n   * - {string} path = '' - Initial active path.\n   * - {object} pathToRegexp = {} - Path-to-RegExp options used for parsing route paths.\n   * - {boolean} updateHistory = false - Whether to update the [History API](https://developer.mozilla.org/docs/Web/API/History_API).\n   */\n  constructor(\n    options = {},\n  ) {\n    super()\n\n    // Create id.\n    const id = Symbol('ID_ROUTER')\n\n    // Overwrite default with given options.\n    options = Object.assign({\n      basePath: '',\n      path: null,\n      pathToRegexp: {},\n      updateHistory: false,\n    }, options)\n\n    let path = options.path\n    let route = null\n    let routes = {}\n\n    // Listen for history state changes.\n    const handleHistory = (\n    ) => {\n      this.setPath(window.location.pathname)\n    }\n    if (options.updateHistory) {\n      window.addEventListener('popstate', handleHistory)\n    }\n\n    /**\n     * Update route.\n     * @param {string} url The base URL to update.\n     * @param {string} newPath The new path to update to.\n     * @param {string} newRoute The new route to update to.\n     */\n    const updateRoute = (\n      url,\n      newPath,\n      newRoute,\n    ) => {\n      // Update stored data.\n      path = newPath\n      route = newRoute\n\n      // Update page history if the option is set.\n      if (options.updateHistory) {\n        // Construct url.\n        const _url = url.includes(options.basePath) ? url : options.basePath + url\n        // Check if url is not current url.\n        if (_url !== window.location.pathname) {\n          // Add path to history.\n          window.history.pushState(null, window.document.title, _url)\n        }\n      }\n\n      // Dispatch event on router.\n      this.dispatchEvent('changed', [this, route, path])\n    }\n\n    /**\n     * Get router id.\n     * @returns {symbol} Unique identifier.\n     */\n    this.getId = (\n    ) => {\n      return id\n    }\n\n    /**\n     * Get current path.\n     * @returns {string} path.\n     */\n    this.getPath = (\n    ) => {\n      return path\n    }\n\n    /**\n     * Get current route.\n     * @returns {string} Route.\n     */\n    this.getRoute = (\n    ) => {\n      return route\n    }\n\n    /**\n     * Get observed routes.\n     * @returns {Array<string>} List of routers.\n     */\n    this.getRoutes = (\n    ) => {\n      return Object.keys(routes)\n    }\n\n    /**\n     * Destroy router instance.\n     */\n    this.destroy = (\n    ) => {\n      // Stop listening to state changes.\n      if (options.updateHistory) {\n        window.removeEventListener('popstate', handleHistory)\n      }\n\n      options = null\n      path = null\n      route = null\n      routes = null\n\n      // Dispatch add event.\n      this.dispatchEvent('destroyed', [this])\n\n      // Remove all listeners.\n      this.removeAllEventListeners()\n    }\n\n    /**\n     * Add route.\n     * @param {string} _route Route pattern.\n     */\n    this.addRoute = (\n      _route,\n    ) => {\n      // Convert path to regexp and store it in routes.\n      routes[_route] = pathToRegexp(_route, [], options.pathToRegexp)\n\n      // Dispatch add event.\n      this.dispatchEvent('added', [this, _route])\n\n      if (path) {\n        // Remove base url, if present.\n        const _path = path.replace(options.basePath, '')\n        // Check if current route is.\n        if (routes[_route].test(_path)) {\n          updateRoute(path, _path, _route)\n        }\n      }\n    }\n\n    /**\n     * Remove route.\n     * @param {string} _route Route pattern.\n     */\n    this.removeRoute = (\n      _route,\n    ) => {\n      // Delete route.\n      delete routes[_route]\n\n      // Dispatch removed event.\n      this.dispatchEvent('removed', [this, _route])\n\n      if (route === _route) {\n        // Set current route as none.\n        path = null\n        route = null\n\n        // Dispatch changed event.\n        this.dispatchEvent('changed', [this, route, path])\n      }\n    }\n\n    /**\n     * Set current route.\n     * @param {string} url URL path.\n     */\n    this.setPath = (\n      url,\n    ) => {\n      // Remove base url, if present.\n      const newPath = url.replace(options.basePath, '')\n      if (path === newPath) {\n        return\n      }\n\n      // Find matching routes.\n      let newRoute = null\n      for (const _route in routes) {\n        // Test route.\n        if (routes[_route].test(newPath)) {\n          newRoute = _route\n          break\n        }\n      }\n\n      // Update route.\n      updateRoute(url, newPath, newRoute)\n    }\n  }\n}\n",
    "// Import symbols.\nimport { ROUTER } from '../symbols.js'\nimport Router from '../Router.js'\n\n/**\n * Get closest router in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Router | undefined} Closest router.\n */\nconst closestRouter = (\n  element,\n) => {\n  if (element.parentElement) {\n    element = element.parentElement\n\n    if (element[ROUTER]) {\n      /** @type {Router} */\n      return element[ROUTER]\n    }\n\n    return closestRouter(element)\n  }\n}\n\nexport default closestRouter\n",
    "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n\n// Import symbol.\nimport { ROUTER } from '../symbols'\n\n// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\n\nexport default ({\n  routerContextName,\n}) => ({\n  name: routerContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    let router = null\n    const revocable = RevocableProxy({}, {\n      get: (\n        target,\n        propertyKey,\n        receiver,\n      ) => {\n        // Get closest router from hierarchy.\n        if (router === null) {\n          if (element[ROUTER]) {\n            router = element[ROUTER]\n          } else {\n            router = closestRouter(element)\n          }\n\n          // Set router to false so we don't look twice.\n          if (!router) {\n            router = false\n          }\n        }\n\n        // Mark as router accessed.\n        attribute.accessed(router.getId(), '')\n\n        if (!router) {\n          return\n        }\n\n        // Return router property.\n        return Reflect.get(router, propertyKey, receiver)\n      },\n    })\n\n    return {\n      value: revocable.proxy,\n\n      destroy: (\n      ) => {\n        revocable.revoke()\n      },\n    }\n  },\n})\n",
    "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {string} text String to escape.\n * @returns {string} Escaped string.\n */\nexport const escapeHtml = (\n  text,\n) => {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\\\'/g, '\\\\\\'')\n    .replace(/\\\\\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n}\n\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {string} text String to modify.\n * @returns {string} Converted string.\n */\nexport const kebabToCamel = (\n  text,\n) => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase())\n}\n\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<string>} modifiers List of modifiers to parse.\n * @returns {object} Parsed modifiers.\n */\nexport const parseAttributeModifiers = (\n  modifiers,\n) => {\n  const result = {}\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-')\n\n    // If no hyphen then set the modifiers to true.\n    if (hyphenIndex < 0) {\n      result[modifier] = true\n      continue\n    }\n\n    // If it starts with hyphen then set the modifier to false.\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false\n      continue\n    }\n\n    // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n    const key = modifier.substring(0, hyphenIndex)\n    let value = modifier.substring(hyphenIndex + 1)\n\n    let tmpValue = value\n\n    // Try to remove time suffixes.\n    let type\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2)\n    } else if (value.endsWith('s')) {\n      type = 's'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('m')) {\n      type = 'm'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('h')) {\n      type = 'h'\n      tmpValue = value.substring(-1)\n    }\n\n    // Try to parse the value as a number.\n    tmpValue = Number.parseInt(tmpValue)\n    if (!isNaN(tmpValue)) {\n      value = tmpValue\n\n      // Convert to milliseconds if given in a different format.\n      switch (type) {\n        case 'h':\n          value *= 60\n        case 'm':\n          value *= 60\n        case 's':\n          value *= 1000\n          break\n      }\n    }\n\n    // Store modifier data.\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {string} prefix Directive prefix.\n * @param {string} name Name to parse.\n * @returns {Array<string> | undefined} list of segments.\n */\nexport const parseAttributeName = (\n  prefix,\n  name,\n) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'))\n  if (!name) {\n    return\n  }\n  // Deconstruct match.\n  let [full, directive, keyRaw, modifiers] = name // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n  keyRaw = keyRaw !== '' ? keyRaw : null\n  const key = keyRaw ? kebabToCamel(keyRaw) : null\n  // Ensure modifiers is and array.\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []\n  // Return result a single array.\n  return [directive, keyRaw, key, modifiers]\n}\n\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n * @param {string} expression For expression to parse.\n * @returns {object | undefined} Iterable type and variables.\n */\nexport const parseForExpression = (\n  expression,\n) => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i)\n  if (!match) {\n    return\n  }\n\n  // Remove parenthesis.\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, '')\n  // Parse for variables.\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i)\n  if (!variables) {\n    return\n  }\n  variables.shift()\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables], // Convert it to an array instead of a regular expression match.\n  }\n}\n\n/**\n * Parse selector to an attributes object.\n * @param {string} selector Selector to parse.\n * @returns {object | undefined} Attributes. Do note the class property is a list of strings not a single string.\n */\nexport const parseSelector = (\n  selector,\n) => {\n  // Convert to array.\n  if (typeof (selector) === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/)\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.')\n    return\n  }\n\n  const attributes = {}\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim()\n\n    // Base what to do of the leading character.\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1)\n        break\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1)\n        // Add to classlist.\n        if (!attributes.class) {\n          attributes.class = []\n        }\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment)\n        }\n        break\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i) // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n        attributes[key] = value\n        break\n    }\n  }\n  return attributes\n}\n\nexport default {\n  escapeHtml,\n  kebabToCamel,\n  parseAttributeModifiers,\n  parseAttributeName,\n  parseForExpression,\n  parseSelector,\n}\n",
    "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n",
    "// Import utilities.\nimport { parseSelector } from './String.js'\nimport { addAttributes, removeAttributes } from './Attribute.js'\n\n// Transition name.\nconst TRANSITION_NAME = '-transition:'\n\n/**\n * @callback TransitionEnd\n */\n\n/**\n * Transition an element.\n * @param {string} type Type of transition, for example 'in' and 'out'.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transition = (\n  type,\n  libraryOptions,\n  element,\n  callback = null,\n) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback()\n    }\n    return\n  }\n\n  // Transition attribute name.\n  const transitionDirectiveName = libraryOptions.prefix + TRANSITION_NAME + type\n\n  // Setup dispatcher function.\n  const dispatchEvent = (phase) => {\n    element.dispatchEvent(\n      new CustomEvent('transition-' + phase),\n    )\n    element.dispatchEvent(\n      new CustomEvent('transition-' + type + '-' + phase),\n    )\n  }\n\n  // Declare variables for later.\n  let name, value, timeout, requestFrame\n  let isDone = false\n  const selectors = {}\n\n  // Process transition during attribute.\n  name = transitionDirectiveName\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.during = parseSelector(value)\n    addAttributes(element, selectors.during)\n  }\n\n  // Process transition from attribute.\n  name = transitionDirectiveName + '.from'\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.from = parseSelector(value)\n    addAttributes(element, selectors.from)\n  }\n\n  // Dispatch transition event.\n  dispatchEvent('start')\n\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null\n\n    // If cancelled then stop immediately.\n    if (isDone) {\n      return\n    }\n\n    // Remove from selector.\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    }\n\n    // Process transition to attribute.\n    name = transitionDirectiveName + '.to'\n    value = element.getAttribute(name)\n    // Parse and apply returned selector.\n    if (value) {\n      selectors.to = parseSelector(value)\n      addAttributes(element, selectors.to)\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n      return\n    }\n\n    // Get computes style.\n    const styles = getComputedStyle(element)\n\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null\n\n      // If cancelled then stop immediately.\n      if (isDone) {\n        return\n      }\n\n      // Remove during selector.\n      if (selectors.during) {\n        removeAttributes(element, selectors.during)\n        selectors.during = undefined\n      }\n\n      // Remove to selector.\n      if (selectors.to) {\n        removeAttributes(element, selectors.to)\n        selectors.to = undefined\n      }\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n    }, duration)\n  })\n\n  return (\n  ) => {\n    if (!isDone) {\n      return\n    }\n    isDone = true\n\n    // Remove applied selector.\n    if (selectors.during) {\n      removeAttributes(element, selectors.during)\n      selectors.during = undefined\n    }\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to)\n      selectors.to = undefined\n    }\n\n    // Clear request animation frame and timeout.\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame)\n      requestFrame = null\n    } else if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    // Dispatch end event.\n    dispatchEvent('end')\n    // Invoke callback.\n    if (callback) {\n      callback()\n    }\n  }\n}\n\n/**\n * Transition an element in.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionIn = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('in', libraryOptions, element, callback)\n}\n\n/**\n * Transition an element out.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionOut = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('out', libraryOptions, element, callback)\n}\n\nexport default {\n  transition,\n  transitionIn,\n  transitionOut,\n}\n",
    "// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\nimport {\n  transitionIn,\n  transitionOut,\n} from '@doars/common/src/utilities/Transition.js'\n\nconst ROUTE = Symbol('ROUTE')\n\nexport default ({\n  routeDirectiveName,\n}) => ({\n  name: routeDirectiveName,\n\n  update: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct component and attribute.\n    const libraryOptions = component.getLibrary().getOptions()\n    const element = attribute.getElement()\n\n    let router\n    const setup = (\n    ) => {\n      // Stop listening to router and remove it.\n      if (router && attribute[ROUTE]) {\n        router.removeEventListener('changed', attribute[ROUTE].handler)\n        router.removeEventListener('destroyed', attribute[ROUTE].setup)\n\n        delete attribute[ROUTE]\n      }\n\n      // Get closest router in parent nodes.\n      router = closestRouter(element)\n      if (!router) {\n        console.warn('DoarsRouter: Router not found for route.')\n        return\n      }\n\n      // Setup route data.\n      attribute[ROUTE] = {\n        setup,\n      }\n\n      // Deconstruct attribute.\n      const value = attribute.getValue()\n\n      // Add route to router.\n      router.addRoute(value)\n\n      // Handle router changes.\n      const handleChange = (\n        router,\n        route,\n      ) => {\n        if (route !== value) {\n          if (element.tagName === 'TEMPLATE') {\n            if (attribute[ROUTE] && attribute[ROUTE].element) {\n              // Transition out.\n              const routeElement = attribute[ROUTE].element\n              transitionOut(libraryOptions, routeElement, () => {\n                // Remove node.\n                routeElement.remove()\n                attribute[ROUTE].element = undefined\n              })\n            }\n          } else {\n            // Transition out and set display none.\n            transitionOut(libraryOptions, element, () => {\n              element.style.display = 'none'\n            })\n          }\n        } else if (element.tagName === 'TEMPLATE') {\n          // Create new element from template.\n          const newElement = document.importNode(element.content, true).firstElementChild\n          // Add element after the template element.\n          element.insertAdjacentElement('afterend', newElement)\n          attribute[ROUTE].element = element\n\n          // Transition in.\n          transitionIn(libraryOptions, attribute[ROUTE].element)\n        } else {\n          // Remove display none.\n          element.style.display = null\n\n          // Transition in.\n          transitionIn(libraryOptions, element)\n        }\n      }\n      attribute[ROUTE].handler = handleChange\n\n      // Listen to router changes and perform initial run.\n      router.addEventListener('changed', handleChange)\n      handleChange(router, router.getRoute())\n\n      // If the router is destroyed look for another\n      router.addEventListener('destroyed', setup)\n    }\n\n    // Perform initial setup.\n    setup()\n  },\n\n  destroy: (\n    component,\n    attribute, {\n      transitionOut,\n    },\n  ) => {\n    const libraryOptions = component.getLibrary().getOptions()\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    if (element.tagName === 'TEMPLATE') {\n      if (attribute[ROUTE] && attribute[ROUTE].element) {\n        // Transition out.\n        const routeElement = attribute[ROUTE].element\n        transitionOut(libraryOptions, routeElement, () => {\n          // Remove node.\n          routeElement.remove()\n          attribute[ROUTE].element = undefined\n        })\n      }\n    } else {\n      // Transition out and set display none.\n      transitionOut(libraryOptions, element, () => {\n        element.style.display = 'none'\n      })\n    }\n\n    // Get closest router in parent nodes.\n    const router = closestRouter(element)\n    if (!router) {\n      return\n    }\n\n    // Remove router listeners.\n    if (attribute[ROUTE]) {\n      router.removeEventListener('destroyed', attribute[ROUTE].setup)\n      if (attribute[ROUTE].handler) {\n        router.removeEventListener('change', attribute[ROUTE].handler)\n      }\n    }\n  },\n})\n",
    "// Import router.\nimport Router from '../Router.js'\n\n// Import symbols.\nimport { ROUTER } from '../symbols.js'\n\nexport default (\n  options,\n) => ({\n  name: options.routerDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Get router.\n    let router = element[ROUTER]\n    if (!router) {\n      // Create router\n      router = element[ROUTER] = new Router(\n        Object.assign(\n          {},\n          options,\n          processExpression(\n            component,\n            attribute,\n            attribute.getValue(),\n          ),\n        ),\n      )\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Get router.\n    const router = element[ROUTER]\n    if (!router) {\n      return\n    }\n\n    // Remove router reference.\n    delete element[ROUTER]\n\n    // Deconstruct router.\n    const id = router.getId()\n\n    // Destroy router.\n    router.destroy()\n\n    // Deconstruct component.\n    const library = component.getLibrary()\n\n    // Trigger update due to changed router.\n    library.update([{\n      id,\n      path: '',\n    }])\n  },\n})\n",
    "// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\n\nconst ROUTE_TO = Symbol('ROUTE_TO')\nconst CLICK = 'click'\n\nexport default ({\n  routeToDirectiveName,\n}) => ({\n  name: routeToDirectiveName,\n\n  update: (\n    component,\n    attribute,\n  ) => {\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n    const value = attribute.getValue()\n\n    // Check for existing data.\n    if (attribute[ROUTE_TO]) {\n      // Exit early if listener has not changed.\n      if (attribute[ROUTE_TO].value === value) {\n        return\n      }\n\n      // Remove existing listeners so we don't listen twice.\n      attribute[ROUTE_TO].target.removeEventListener(\n        CLICK,\n        attribute[ROUTE_TO].handler,\n      )\n    }\n\n    const handler = (event) => {\n      if (modifiers.self && event.target !== element) {\n        return\n      }\n\n      if (modifiers.prevent) {\n        event.preventDefault()\n      }\n      if (modifiers.stop) {\n        event.stopPropagation()\n      }\n\n      const router = closestRouter(element)\n      if (!router) {\n        return\n      }\n\n      router.setPath(value)\n    }\n\n    // Listen to click and keyboard events.\n    element.addEventListener(CLICK, handler)\n\n    // Store listener data on the component.\n    attribute[ROUTE_TO] = {\n      handler,\n      value,\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    if (!attribute[ROUTE_TO]) {\n      return\n    }\n\n    const element = attribute.getElement()\n\n    element.removeEventListener(CLICK, attribute[ROUTE_TO].handler)\n\n    delete attribute[ROUTE_TO]\n  },\n})\n",
    "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport { deepAssign } from '@doars/common/src/utilities/Object.js'\n\nimport createRouterContext from './contexts/router.js'\nimport createRouteDirective from './directives/route.js'\nimport createRouterDirective from './directives/router.js'\nimport createRouteToDirective from './directives/routeTo.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = deepAssign({\n    basePath: '',\n    path: '',\n    pathToRegexp: {},\n    updateHistory: false,\n\n    routerContextName: '$router',\n    routeDirectiveName: 'route',\n    routerDirectiveName: 'router',\n    routeToDirectiveName: 'route-to',\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  const routerContext = createRouterContext(options),\n    routeDirective = createRouteDirective(options),\n    routerDirective = createRouterDirective(options),\n    routeToDirective = createRouteToDirective(options)\n\n  const onEnable = (\n  ) => {\n    // Add contexts and directives.\n    library.addContexts(0, routerContext)\n    library.addDirectives(\n      -1,\n      routeDirective,\n      routerDirective,\n      routeToDirective,\n    )\n  }\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(routerContext)\n    library.removeDirectives(\n      routeDirective,\n      routerDirective,\n      routeToDirective,\n    )\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n",
    "import DoarsRouter from './DoarsRouter.js'\n\nwindow.DoarsRouter = DoarsRouter\n"
  ],
  "mappings": "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",
  "debugId": "5ECEFD3491740A0064756E2164756E21",
  "names": []
}