{
  "version": 3,
  "sources": ["../../common/src/polyfills/RevocableProxy.js", "../src/symbols.js", "../src/utilities/closestRouter.js", "../src/contexts/router.js", "../../../node_modules/path-to-regexp/dist.es2015/index.js", "../../common/src/events/EventDispatcher.js", "../src/Router.js", "../src/factories/directives/router.js", "../../common/src/utilities/Element.js", "../src/directives/route.js", "../src/directives/routeTo.js", "../../common/src/utilities/Object.js", "../src/DoarsRouter.js"],
  "sourcesContent": ["// List of methods to revoke access to.\nconst REFLECTION_METHODS = ['apply', 'construct', 'defineProperty', 'deleteProperty', 'get', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf'];\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\n\nexport default ((target, handler) => {\n  // Keep track of status.\n  let revoked = false; // Add revocable handlers for each given handlers.\n\n  const revocableHandler = {};\n\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy');\n        return;\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters);\n      }\n\n      return Reflect[key](...parameters);\n    };\n  } // Return proxy and revoke method.\n\n\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true;\n    }\n  };\n});", "export const ROUTE_TO = Symbol('ROUTE_TO');\nexport const ROUTER = Symbol('ROUTER');\nexport const ROUTE = Symbol('ROUTE');", "// Import symbols.\nimport { ROUTER } from '../symbols.js';\n/**\n * Get closest router in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Router} Closest router.\n */\n\nexport default (element => {\n  if (!element.parentElement) {\n    return;\n  }\n\n  element = element.parentElement;\n\n  if (element[ROUTER]) {\n    return element[ROUTER];\n  }\n\n  return closestRouter(element);\n});", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'; // Import symbol.\n\nimport { ROUTER } from '../symbols'; // Import utilities.\n\nimport closestRouter from '../utilities/closestRouter.js';\nexport default {\n  name: '$router',\n  create: (component, attribute) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    let router = null;\n    const revocable = RevocableProxy({}, {\n      get: (target, propertyKey, receiver) => {\n        // Get closest router from hierarchy.\n        if (router === null) {\n          if (element[ROUTER]) {\n            router = element[ROUTER];\n          } else {\n            router = closestRouter(element);\n          } // Set router to false so we don't look twice.\n\n\n          if (!router) {\n            router = false;\n          }\n        } // Mark as router accessed.\n\n\n        attribute.accessed(router.getId(), '');\n\n        if (!router) {\n          return;\n        } // Return router property.\n\n\n        return Reflect.get(router, propertyKey, receiver);\n      }\n    });\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        revocable.revoke();\n      }\n    };\n  }\n};", "/**\n * Tokenize input string.\n */\nfunction lexer(str) {\n  var tokens = [];\n  var i = 0;\n\n  while (i < str.length) {\n    var char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({\n        type: \"MODIFIER\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({\n        type: \"ESCAPED_CHAR\",\n        index: i++,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({\n        type: \"OPEN\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({\n        type: \"CLOSE\",\n        index: i,\n        value: str[i++]\n      });\n      continue;\n    }\n\n    if (char === \":\") {\n      var name = \"\";\n      var j = i + 1;\n\n      while (j < str.length) {\n        var code = str.charCodeAt(j);\n\n        if ( // `0-9`\n        code >= 48 && code <= 57 || // `A-Z`\n        code >= 65 && code <= 90 || // `a-z`\n        code >= 97 && code <= 122 || // `_`\n        code === 95) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(\"Missing parameter name at \".concat(i));\n      tokens.push({\n        type: \"NAME\",\n        index: i,\n        value: name\n      });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      var count = 1;\n      var pattern = \"\";\n      var j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(\"Pattern cannot start with \\\"?\\\" at \".concat(j));\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(\"Capturing groups are not allowed at \".concat(j));\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(\"Unbalanced pattern at \".concat(i));\n      if (!pattern) throw new TypeError(\"Missing pattern at \".concat(i));\n      tokens.push({\n        type: \"PATTERN\",\n        index: i,\n        value: pattern\n      });\n      i = j;\n      continue;\n    }\n\n    tokens.push({\n      type: \"CHAR\",\n      index: i,\n      value: str[i++]\n    });\n  }\n\n  tokens.push({\n    type: \"END\",\n    index: i,\n    value: \"\"\n  });\n  return tokens;\n}\n/**\n * Parse a string for the raw tokens.\n */\n\n\nexport function parse(str, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var tokens = lexer(str);\n  var _a = options.prefixes,\n      prefixes = _a === void 0 ? \"./\" : _a;\n  var defaultPattern = \"[^\".concat(escapeString(options.delimiter || \"/#?\"), \"]+?\");\n  var result = [];\n  var key = 0;\n  var i = 0;\n  var path = \"\";\n\n  var tryConsume = function (type) {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  var mustConsume = function (type) {\n    var value = tryConsume(type);\n    if (value !== undefined) return value;\n    var _a = tokens[i],\n        nextType = _a.type,\n        index = _a.index;\n    throw new TypeError(\"Unexpected \".concat(nextType, \" at \").concat(index, \", expected \").concat(type));\n  };\n\n  var consumeText = function () {\n    var result = \"\";\n    var value;\n\n    while (value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\")) {\n      result += value;\n    }\n\n    return result;\n  };\n\n  while (i < tokens.length) {\n    var char = tryConsume(\"CHAR\");\n    var name = tryConsume(\"NAME\");\n    var pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      var prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix: prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    var value = char || tryConsume(\"ESCAPED_CHAR\");\n\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    var open = tryConsume(\"OPEN\");\n\n    if (open) {\n      var prefix = consumeText();\n      var name_1 = tryConsume(\"NAME\") || \"\";\n      var pattern_1 = tryConsume(\"PATTERN\") || \"\";\n      var suffix = consumeText();\n      mustConsume(\"CLOSE\");\n      result.push({\n        name: name_1 || (pattern_1 ? key++ : \"\"),\n        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,\n        prefix: prefix,\n        suffix: suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\"\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n/**\n * Compile a string to a template function for the path.\n */\n\nexport function compile(str, options) {\n  return tokensToFunction(parse(str, options), options);\n}\n/**\n * Expose a method for transforming tokens into the path function.\n */\n\nexport function tokensToFunction(tokens, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var reFlags = flags(options);\n  var _a = options.encode,\n      encode = _a === void 0 ? function (x) {\n    return x;\n  } : _a,\n      _b = options.validate,\n      validate = _b === void 0 ? true : _b; // Compile all the tokens into regexps.\n\n  var matches = tokens.map(function (token) {\n    if (typeof token === \"object\") {\n      return new RegExp(\"^(?:\".concat(token.pattern, \")$\"), reFlags);\n    }\n  });\n  return function (data) {\n    var path = \"\";\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      var value = data ? data[token.name] : undefined;\n      var optional = token.modifier === \"?\" || token.modifier === \"*\";\n      var repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not repeat, but got an array\"));\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n          throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to not be empty\"));\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          var segment = encode(value[j], token);\n\n          if (validate && !matches[i].test(segment)) {\n            throw new TypeError(\"Expected all \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        var segment = encode(String(value), token);\n\n        if (validate && !matches[i].test(segment)) {\n          throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to match \\\"\").concat(token.pattern, \"\\\", but got \\\"\").concat(segment, \"\\\"\"));\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n      var typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(\"Expected \\\"\".concat(token.name, \"\\\" to be \").concat(typeOfMessage));\n    }\n\n    return path;\n  };\n}\n/**\n * Create path match function from `path-to-regexp` spec.\n */\n\nexport function match(str, options) {\n  var keys = [];\n  var re = pathToRegexp(str, keys, options);\n  return regexpToFunction(re, keys, options);\n}\n/**\n * Create a path match function from `path-to-regexp` output.\n */\n\nexport function regexpToFunction(re, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.decode,\n      decode = _a === void 0 ? function (x) {\n    return x;\n  } : _a;\n  return function (pathname) {\n    var m = re.exec(pathname);\n    if (!m) return false;\n    var path = m[0],\n        index = m.index;\n    var params = Object.create(null);\n\n    var _loop_1 = function (i) {\n      if (m[i] === undefined) return \"continue\";\n      var key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map(function (value) {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    };\n\n    for (var i = 1; i < m.length; i++) {\n      _loop_1(i);\n    }\n\n    return {\n      path: path,\n      index: index,\n      params: params\n    };\n  };\n}\n/**\n * Escape a regular expression string.\n */\n\nfunction escapeString(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n/**\n * Get the flags for a regexp from the options.\n */\n\n\nfunction flags(options) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n/**\n * Pull out keys from a regexp.\n */\n\n\nfunction regexpToRegexp(path, keys) {\n  if (!keys) return path;\n  var groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n  var index = 0;\n  var execResult = groupsRegex.exec(path.source);\n\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\"\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n/**\n * Transform an array into a regexp.\n */\n\n\nfunction arrayToRegexp(paths, keys, options) {\n  var parts = paths.map(function (path) {\n    return pathToRegexp(path, keys, options).source;\n  });\n  return new RegExp(\"(?:\".concat(parts.join(\"|\"), \")\"), flags(options));\n}\n/**\n * Create a path regexp from string input.\n */\n\n\nfunction stringToRegexp(path, keys, options) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\n\n\nexport function tokensToRegexp(tokens, keys, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _a = options.strict,\n      strict = _a === void 0 ? false : _a,\n      _b = options.start,\n      start = _b === void 0 ? true : _b,\n      _c = options.end,\n      end = _c === void 0 ? true : _c,\n      _d = options.encode,\n      encode = _d === void 0 ? function (x) {\n    return x;\n  } : _d,\n      _e = options.delimiter,\n      delimiter = _e === void 0 ? \"/#?\" : _e,\n      _f = options.endsWith,\n      endsWith = _f === void 0 ? \"\" : _f;\n  var endsWithRe = \"[\".concat(escapeString(endsWith), \"]|$\");\n  var delimiterRe = \"[\".concat(escapeString(delimiter), \"]\");\n  var route = start ? \"^\" : \"\"; // Iterate over the tokens and create our regexp string.\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      var prefix = escapeString(encode(token.prefix));\n      var suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            var mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += \"(?:\".concat(prefix, \"((?:\").concat(token.pattern, \")(?:\").concat(suffix).concat(prefix, \"(?:\").concat(token.pattern, \"))*)\").concat(suffix, \")\").concat(mod);\n          } else {\n            route += \"(?:\".concat(prefix, \"(\").concat(token.pattern, \")\").concat(suffix, \")\").concat(token.modifier);\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += \"((?:\".concat(token.pattern, \")\").concat(token.modifier, \")\");\n          } else {\n            route += \"(\".concat(token.pattern, \")\").concat(token.modifier);\n          }\n        }\n      } else {\n        route += \"(?:\".concat(prefix).concat(suffix, \")\").concat(token.modifier);\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += \"\".concat(delimiterRe, \"?\");\n    route += !options.endsWith ? \"$\" : \"(?=\".concat(endsWithRe, \")\");\n  } else {\n    var endToken = tokens[tokens.length - 1];\n    var isEndDelimited = typeof endToken === \"string\" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === undefined;\n\n    if (!strict) {\n      route += \"(?:\".concat(delimiterRe, \"(?=\").concat(endsWithRe, \"))?\");\n    }\n\n    if (!isEndDelimited) {\n      route += \"(?=\".concat(delimiterRe, \"|\").concat(endsWithRe, \")\");\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\n\nexport function pathToRegexp(path, keys, options) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {};\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = [];\n      } // Add to events.\n\n\n      events[name].push({\n        callback: callback,\n        options: options\n      });\n    };\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n\n\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return;\n      }\n\n      const eventData = events[name]; // Get index of callback in events.\n\n      let index = -1;\n\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return;\n      } // Remove item from events.\n\n\n      eventData.splice(index, 1); // Remove event if list is empty.\n\n      if (Object.keys(eventData).length === 0) {\n        delete events[name];\n      }\n    };\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeEventListeners = name => {\n      if (!name) {\n        return;\n      } // Remove all handlers with the event name.\n\n\n      delete events[name];\n    };\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {};\n    };\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n\n\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return;\n      } // Get events by trigger name.\n\n\n      const eventData = events[name]; // Dispatch a call to each event.\n\n      for (let i = 0; i < eventData.length; i++) {\n        const event = options && options.reverse ? eventData[eventData.length - (i + 1)] : eventData[i]; // If once is truthy then remove the callback.\n\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1);\n        } // Execute callback.\n\n\n        event.callback(...parameters);\n      }\n    };\n  }\n\n}\n\nexport default EventDispatcher;", "// Import external modules.\nimport { pathToRegexp } from 'path-to-regexp'; // Import event dispatcher.\n\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js';\n\nclass Router extends EventDispatcher {\n  constructor(options = {}) {\n    super(); // Create id.\n\n    const id = Symbol('ID_ROUTER'); // Overwrite default with given options.\n\n    options = Object.assign({\n      basePath: '',\n      path: null,\n      pathToRegexp: {},\n      updateHistory: false\n    }, options);\n    let path = options.path;\n    let route = null;\n    let routes = {}; // Listen for history state changes.\n\n    const handleHistory = () => {\n      this.setPath(window.location.pathname);\n    };\n\n    if (options.updateHistory) {\n      window.addEventListener('popstate', handleHistory);\n    }\n    /**\n     * Update route.\n     * @param {String} url URL.\n     * @param {String} _path Path.\n     * @param {String} _route Route.\n     */\n\n\n    const updateRoute = (url, newPath, newRoute) => {\n      // Update stored data.\n      path = newPath;\n      route = newRoute; // Update page history if the option is set.\n\n      if (options.updateHistory) {\n        // Construct url.\n        const _url = url.includes(options.basePath) ? url : options.basePath + url; // Check if url is not current url.\n\n\n        if (_url !== window.location.pathname) {\n          // Add path to history.\n          window.history.pushState(null, window.document.title, _url);\n        }\n      } // Dispatch event on router.\n\n\n      this.dispatchEvent('changed', [this, route, path]);\n    };\n    /**\n     * Get router id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get current path.\n     * @returns {String} path.\n     */\n\n\n    this.getPath = () => {\n      return path;\n    };\n    /**\n     * Get current route.\n     * @returns {String} Route.\n     */\n\n\n    this.getRoute = () => {\n      return route;\n    };\n    /**\n     * Get observed routes.\n     * @returns {Array<String>} List of routers.\n     */\n\n\n    this.getRoutes = () => {\n      return Object.keys(routes);\n    };\n    /**\n     * Destroy router instance.\n     */\n\n\n    this.destroy = () => {\n      // Stop listening to state changes.\n      if (options.updateHistory) {\n        window.removeEventListener('popstate', handleHistory);\n      }\n\n      options = null;\n      path = null;\n      route = null;\n      routes = null; // Dispatch add event.\n\n      this.dispatchEvent('destroyed', [this]); // Remove all listeners.\n\n      this.removeAllEventListeners();\n    };\n    /**\n     * Add route.\n     * @param {String} _route Route pattern.\n     */\n\n\n    this.addRoute = _route => {\n      // Convert path to regexp and store it in routes.\n      routes[_route] = pathToRegexp(_route, [], options.pathToRegexp); // Dispatch add event.\n\n      this.dispatchEvent('added', [this, _route]);\n\n      if (path) {\n        // Remove base url, if present.\n        const _path = path.replace(options.basePath, ''); // Check if current route is.\n\n\n        if (routes[_route].test(_path)) {\n          updateRoute(path, _path, _route);\n        }\n      }\n    };\n    /**\n     * Remove route.\n     * @param {String} _route Route pattern.\n     */\n\n\n    this.removeRoute = _route => {\n      // Delete route.\n      delete routes[_route]; // Dispatch removed event.\n\n      this.dispatchEvent('removed', [this, _route]);\n\n      if (route === _route) {\n        // Set current route as none.\n        path = null;\n        route = null; // Dispatch changed event.\n\n        this.dispatchEvent('changed', [this, route, path]);\n      }\n    };\n    /**\n     * Set current route.\n     * @param {String} url URL path.\n     */\n\n\n    this.setPath = url => {\n      // Remove base url, if present.\n      const newPath = url.replace(options.basePath, '');\n\n      if (path === newPath) {\n        return;\n      } // Find matching routes.\n\n\n      let newRoute = null;\n\n      for (const _route in routes) {\n        // Test route.\n        if (routes[_route].test(newPath)) {\n          newRoute = _route;\n          break;\n        }\n      } // Update route.\n\n\n      updateRoute(url, newPath, newRoute);\n    };\n  }\n\n}\n\nexport default Router;", "// Import router.\nimport Router from '../../Router.js'; // Import symbols.\n\nimport { ROUTER } from '../../symbols.js';\nexport default (routerOptions => {\n  return {\n    name: 'router',\n    update: (component, attribute, {\n      processExpression\n    }) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement(); // Get router.\n\n      let router = element[ROUTER];\n\n      if (!router) {\n        // Construct options.\n        const options = Object.assign({}, routerOptions, processExpression(component, attribute.clone(), attribute.getValue())); // Create router\n\n        router = element[ROUTER] = new Router(options);\n      }\n    },\n    destroy: (component, attribute) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement(); // Get router.\n\n      const router = element[ROUTER];\n\n      if (!router) {\n        return;\n      } // Remove router reference.\n\n\n      delete element[ROUTER]; // Deconstruct router.\n\n      const id = router.getId(); // Destroy router.\n\n      router.destroy(); // Deconstruct component.\n\n      const library = component.getLibrary(); // Trigger update due to changed router.\n\n      library.update([{\n        id: id,\n        path: ''\n      }]);\n    }\n  };\n});", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = string => {\n  const template = document.createElement('template');\n  template.innerHTML = string;\n  return template.content.childNodes[0];\n};\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\n\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling);\n  } else {\n    reference.parentNode.appendChild(node);\n  }\n};\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\n\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b);\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false;\n  }\n\n  if (a.type === 3) {\n    // Text node.\n    return a.nodeValue === b.nodeValue;\n  }\n\n  return false;\n};\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\n\nexport const walk = (element, filter) => {\n  let index = -1;\n  let iterator = null;\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator();\n\n      if (child) {\n        return child;\n      }\n    } // Get next child that passes the filter.\n\n\n    let child = null;\n\n    do {\n      index++;\n\n      if (index >= element.childElementCount) {\n        return null;\n      }\n\n      child = element.children[index];\n    } while (!filter(child)); // Setup iterator for child.\n\n\n    if (child.childElementCount) {\n      iterator = walk(child, filter);\n    } // Return the child.\n\n\n    return child;\n  };\n};\nexport default {\n  fromString: fromString,\n  insertAfter: insertAfter,\n  isSame: isSame,\n  walk: walk\n};", "// Import symbols.\nimport { ROUTE } from '../symbols.js'; // Import utilities.\n\nimport closestRouter from '../utilities/closestRouter.js';\nimport { insertAfter } from '@doars/common/src/utilities/Element.js';\nexport default {\n  name: 'route',\n  update: (component, attribute, {\n    transitionIn,\n    transitionOut\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    let router;\n\n    const setup = () => {\n      // Stop listening to router and remove it.\n      if (router && attribute[ROUTE]) {\n        router.removeEventListener('changed', attribute[ROUTE].handler);\n        router.removeEventListener('destroyed', attribute[ROUTE].setup);\n        delete attribute[ROUTE];\n      } // Get closest router in parent nodes.\n\n\n      router = closestRouter(element);\n\n      if (!router) {\n        console.warn('DoarsRouter: Router not found for route.');\n        return;\n      } // Setup route data.\n\n\n      attribute[ROUTE] = {\n        setup: setup\n      }; // Deconstruct attribute.\n\n      const value = attribute.getValue(); // Add route to router.\n\n      router.addRoute(value); // Handle router changes.\n\n      const handleChange = (router, route) => {\n        if (route !== value) {\n          if (element.tagName === 'TEMPLATE') {\n            if (attribute[ROUTE] && attribute[ROUTE].element) {\n              // Transition out.\n              const routeElement = attribute[ROUTE].element;\n              transitionOut(component, routeElement, () => {\n                // Remove node.\n                routeElement.remove();\n                attribute[ROUTE].element = undefined;\n              });\n            }\n          } else {\n            // Transition out and set display none.\n            transitionOut(component, element, () => {\n              element.style.display = 'none';\n            });\n          }\n        } else if (element.tagName === 'TEMPLATE') {\n          // Create new element from template.\n          const templateInstance = document.importNode(element.content, true); // Add element after the template element.\n\n          insertAfter(element, templateInstance); // Get HTMLElement reference instead of DocumentFragment.\n\n          attribute[ROUTE].element = element.nextSibling; // Transition in.\n\n          transitionIn(component, attribute[ROUTE].element);\n        } else {\n          // Remove display none.\n          element.style.display = null; // Transition in.\n\n          transitionIn(component, element);\n        }\n      };\n\n      attribute[ROUTE].handler = handleChange; // Listen to router changes and perform initial run.\n\n      router.addEventListener('changed', handleChange);\n      handleChange(router, router.getRoute()); // If the router is destroyed look for another\n\n      router.addEventListener('destroyed', setup);\n    }; // Perform initial setup.\n\n\n    setup();\n  },\n  destroy: (component, attribute, {\n    transitionOut\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n\n    if (element.tagName === 'TEMPLATE') {\n      if (attribute[ROUTE] && attribute[ROUTE].element) {\n        // Transition out.\n        const routeElement = attribute[ROUTE].element;\n        transitionOut(component, routeElement, () => {\n          // Remove node.\n          routeElement.remove();\n          attribute[ROUTE].element = undefined;\n        });\n      }\n    } else {\n      // Transition out and set display none.\n      transitionOut(component, element, () => {\n        element.style.display = 'none';\n      });\n    } // Get closest router in parent nodes.\n\n\n    const router = closestRouter(element);\n\n    if (!router) {\n      return;\n    } // Remove router listeners.\n\n\n    if (attribute[ROUTE]) {\n      router.removeEventListener('destroyed', attribute[ROUTE].setup);\n\n      if (attribute[ROUTE].handler) {\n        router.removeEventListener('change', attribute[ROUTE].handler);\n      }\n    }\n  }\n};", "// Import symbols.\nimport { ROUTE_TO } from '../symbols.js'; // Import utilities.\n\nimport closestRouter from '../utilities/closestRouter.js';\nconst CLICK = 'click';\nexport default {\n  name: 'route-to',\n  update: (component, attribute) => {\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n    const value = attribute.getValue(); // Check for existing data.\n\n    if (attribute[ROUTE_TO]) {\n      // Exit early if listener has not changed.\n      if (attribute[ROUTE_TO].value === value) {\n        return;\n      } // Remove existing listeners so we don't listen twice.\n\n\n      attribute[ROUTE_TO].target.removeEventListener(CLICK, attribute[ROUTE_TO].handler);\n    }\n\n    const handler = event => {\n      if (modifiers.self && event.target !== element) {\n        return;\n      }\n\n      if (modifiers.prevent) {\n        event.preventDefault();\n      }\n\n      if (modifiers.stop) {\n        event.stopPropagation();\n      }\n\n      const router = closestRouter(element);\n\n      if (!router) {\n        return;\n      }\n\n      router.setPath(value);\n    }; // Listen to click and keyboard events.\n\n\n    element.addEventListener(CLICK, handler); // Store listener data on the component.\n\n    attribute[ROUTE_TO] = {\n      handler: handler,\n      value: value\n    };\n  },\n  destroy: (component, attribute) => {\n    if (!attribute[ROUTE_TO]) {\n      return;\n    }\n\n    const element = attribute.getElement();\n    element.removeEventListener(CLICK, attribute[ROUTE_TO].handler);\n    delete attribute[ROUTE_TO];\n  }\n};", "/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (target, ...sources) => {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepAssign(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map(value => {\n          if (isObject(value)) {\n            return deepAssign({}, value);\n          }\n\n          return value;\n        });\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources);\n};\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\n\nexport const getDeeply = (object, path) => {\n  let objectTemp = object;\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]];\n  }\n\n  return objectTemp[path[i]];\n};\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\n\nexport const isObject = value => {\n  return value && typeof value === 'object' && !Array.isArray(value);\n};\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\n\nexport const setDeeply = (object, path, value) => {\n  // Exit early if not an object.\n  if (typeof object !== 'object') {\n    return;\n  }\n\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]; // Exit early if not an object.\n\n    if (typeof object !== 'object') {\n      return;\n    }\n  }\n\n  object[path[i]] = value;\n};\nexport default {\n  deepAssign: deepAssign,\n  getDeeply: getDeeply,\n  isObject: isObject,\n  setDeeply: setDeeply\n};", "// Import contexts.\nimport contextRouter from './contexts/router.js'; // Import directives.\n\nimport createDirectiveRouter from './factories/directives/router.js';\nimport directiveRoute from './directives/route.js';\nimport directiveRouteTo from './directives/routeTo.js'; // Import utilities.\n\nimport { deepAssign } from '@doars/common/src/utilities/Object.js';\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {Object} options The plugin options.\n */\n\nexport default function (library, options = null) {\n  // Clone options.\n  options = deepAssign({}, options); // Set private variables.\n\n  let isEnabled = false;\n\n  const onEnable = function () {\n    // Add contexts and directives.\n    library.addContexts(0, contextRouter);\n    directiveRouter = createDirectiveRouter(options);\n    library.addDirectives(-1, directiveRouter, directiveRoute, directiveRouteTo);\n  };\n\n  const onDisable = function () {\n    // Remove contexts and directives.\n    library.removeContexts(contextRouter);\n    library.removeDirectives(directiveRouter, directiveRoute, directiveRouteTo);\n    directiveRouter = null;\n  };\n\n  this.disable = function () {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false; // Stop listening to enable state of the library.\n\n      library.removeEventListener('enabling', onEnable);\n      library.removeEventListener('disabling', onDisable);\n    }\n  };\n\n  this.enable = function () {\n    if (!isEnabled) {\n      isEnabled = true; // Listen to enable state of the library.\n\n      library.addEventListener('enabling', onEnable);\n      library.addEventListener('disabling', onDisable);\n    }\n  }; // Automatically enable plugin.\n\n\n  this.enable();\n}"],
  "mappings": "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",
  "names": ["REFLECTION_METHODS", "RevocableProxy_default", "target", "handler", "revoked", "revocableHandler", "key", "parameters", "ROUTE_TO", "ROUTER", "ROUTE", "closestRouter_default", "element", "ROUTER", "router_default", "component", "attribute", "element", "router", "revocable", "RevocableProxy_default", "target", "propertyKey", "receiver", "ROUTER", "closestRouter_default", "lexer", "str", "tokens", "i", "char", "name", "j", "code", "count", "pattern", "parse", "options", "_a", "prefixes", "defaultPattern", "escapeString", "result", "key", "path", "tryConsume", "type", "mustConsume", "value", "nextType", "index", "consumeText", "prefix", "open", "name_1", "pattern_1", "suffix", "escapeString", "str", "flags", "options", "regexpToRegexp", "path", "keys", "groupsRegex", "index", "execResult", "arrayToRegexp", "paths", "parts", "pathToRegexp", "stringToRegexp", "tokensToRegexp", "parse", "tokens", "_a", "strict", "_b", "start", "_c", "end", "_d", "encode", "x", "_e", "delimiter", "_f", "endsWith", "endsWithRe", "delimiterRe", "route", "_i", "tokens_1", "token", "prefix", "suffix", "mod", "endToken", "isEndDelimited", "EventDispatcher", "events", "name", "callback", "options", "eventData", "index", "i", "parameters", "event", "EventDispatcher_default", "Router", "EventDispatcher_default", "options", "id", "path", "route", "routes", "handleHistory", "updateRoute", "url", "newPath", "newRoute", "_url", "_route", "pathToRegexp", "_path", "Router_default", "router_default", "routerOptions", "component", "attribute", "processExpression", "element", "router", "ROUTER", "options", "Router_default", "id", "insertAfter", "reference", "node", "route_default", "component", "attribute", "transitionIn", "transitionOut", "element", "router", "setup", "ROUTE", "closestRouter_default", "value", "handleChange", "route", "routeElement", "templateInstance", "insertAfter", "CLICK", "routeTo_default", "component", "attribute", "element", "modifiers", "value", "ROUTE_TO", "handler", "event", "router", "closestRouter_default", "deepAssign", "target", "sources", "source", "isObject", "key", "value", "isObject", "value", "DoarsRouter_default", "library", "options", "deepAssign", "isEnabled", "onEnable", "router_default", "route_default", "routeTo_default", "onDisable"]
}
