{
  "version": 3,
  "sources": ["../node_modules/@doars/common/src/utilities/Object.js", "../node_modules/@doars/common/src/polyfills/RevocableProxy.js", "../src/symbols.js", "../../../node_modules/path-to-regexp/src/index.ts", "../node_modules/@doars/common/src/events/EventDispatcher.js", "../src/Router.js", "../src/utilities/closestRouter.js", "../src/contexts/router.js", "../node_modules/@doars/common/src/utilities/String.js", "../node_modules/@doars/common/src/utilities/Attribute.js", "../node_modules/@doars/common/src/utilities/Transition.js", "../src/directives/route.js", "../src/directives/router.js", "../src/directives/routeTo.js", "../src/DoarsRouter.js"],
  "sourcesContent": ["/**\n * Deeply assign a series of objects properties together.\n * @param {object} target Target object to merge to.\n * @param {...object} sources Objects to merge into the target.\n * @returns {object} Merged resulting object.\n */\nexport const deepAssign = (\n  target,\n  ...sources\n) => {\n  if (!sources.length) {\n    return target\n  }\n  const source = sources.shift()\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {},\n          })\n        }\n        deepAssign(target[key], source[key])\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map((value) => {\n          if (isObject(value)) {\n            return deepAssign({}, value)\n          }\n          return value\n        })\n      } else {\n        Object.assign(target, {\n          [key]: source[key],\n        })\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources)\n}\n\n/**\n * Get value at path on object.\n * @param {object} object Object to get from.\n * @param  {Array<string>} path Path to value.\n * @returns {any} value at path.\n */\nexport const getDeeply = (\n  object,\n  path,\n) => {\n  let objectTemp = object\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]]\n  }\n  return objectTemp[path[i]]\n}\n\n/**\n * Check whether the value is an object.\n * @param {any} value Value of unknown type.\n * @returns {boolean} Whether the value is an object.\n */\nexport const isObject = (\n  value,\n) => {\n  return (value && typeof value === 'object' && !Array.isArray(value))\n}\n\n/**\n * Set value on path at object.\n * @param {object} object Object to set on.\n * @param {Array<string>} path Path to value.\n * @param {any} value Value to set.\n */\nexport const setDeeply = (\n  object,\n  path,\n  value,\n) => {\n  // Exit early if not an object.\n  if (typeof (object) !== 'object') {\n    return\n  }\n\n  let i = 0\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]\n\n    // Exit early if not an object.\n    if (typeof (object) !== 'object') {\n      return\n    }\n  }\n  object[path[i]] = value\n}\n\nexport default {\n  deepAssign,\n  getDeeply,\n  isObject,\n  setDeeply,\n}\n", "/**\n * Function to call to revoke the proxy.\n * @callback RevocableProxyCallback\n */\n\n/**\n * @typedef RevocableProxy\n * @type {object}\n * @property {Proxy} proxy Proxy that will be revocable.\n * @property {RevocableProxyCallback} revoke Function to call to revoke the proxy.\n */\n\n/**\n * Function called when a proxy has been handled.\n * @callback ProxyHandlerCallback\n */\n\n/**\n * @typedef ProxyHandler\n * @type {object}\n * @property {?ProxyHandlerCallback} apply A trap method for a function call.\n * @property {?ProxyHandlerCallback} construct A trap for the `new` operator.\n * @property {?ProxyHandlerCallback} defineProperty A trap for `Object.defineProperty()`.\n * @property {?ProxyHandlerCallback} deleteProperty A trap for the `delete` operator.\n * @property {?ProxyHandlerCallback} get A trap for getting a property value.\n * @property {?ProxyHandlerCallback} getOwnPropertyDescriptor A trap for `Object.getOwnPropertyDescriptor()`.\n * @property {?ProxyHandlerCallback} getPrototypeOf A trap for the `[[GetPrototypeOf]]` internal method.\n * @property {?ProxyHandlerCallback} has A trap for the `in` operator.\n * @property {?ProxyHandlerCallback} isExtensible A trap for `Object.isExtensible()`.\n * @property {?ProxyHandlerCallback} ownKeys A trap for `Reflect.ownKeys()`.\n * @property {?ProxyHandlerCallback} preventExtensions A trap for `Object.preventExtensions()`.\n * @property {?ProxyHandlerCallback} set A trap for setting a property value.\n * @property {?ProxyHandlerCallback} setPrototypeOf A trap for `Object.setPrototypeOf()`.\n */\n\n// List of methods to revoke access to.\nconst PROXY_TRAPS = [\n  'apply',\n  'construct',\n  'defineProperty',\n  'deleteProperty',\n  'get',\n  'getOwnPropertyDescriptor',\n  'getPrototypeOf',\n  'has',\n  'isExtensible',\n  'ownKeys',\n  'preventExtensions',\n  'set',\n  'setPrototypeOf',\n]\n\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n * @param {object} target Object to proxy.\n * @param {ProxyHandler} handler Object of handler methods.\n * @returns {?RevocableProxy} Proxy object and revoke method.\n */\nexport default (\n  target,\n  handler,\n) => {\n  // Keep track of status.\n  let revoked = false\n\n  // Add revocable handlers for each given handlers.\n  /**\n   * Copy of allowed handlers with a revocable layer in between.\n   * @type {ProxyHandler}\n   */\n  const revocableHandler = {}\n  for (const key of PROXY_TRAPS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        return\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters)\n      }\n      return Reflect[key](...parameters)\n    }\n  }\n\n  // Return proxy and revoke method.\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true\n    },\n  }\n}\n", "export const ROUTER = Symbol('ROUTER')\n", "/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {}\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {}\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {}\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n", "/**\n * @typedef EventListenerOptions\n * @type {object}\n * @property {?boolean} once Whether to call the listener only once.\n */\n\n/**\n * @typedef DispatchEventOptions\n * @type {object}\n * @property {?boolean} reverse Whether to call the listeners in reverse order.\n */\n\nexport default class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor(\n  ) {\n    /**\n     * Object to store event listeners for the EventDispatcher class.\n     * @type {Record<string, Array<{callback: Function, options: EventListenerOptions }>>}\n     */\n    let events = {}\n\n    /**\n     * Add callback to event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {EventListenerOptions} options Callback options.\n     */\n    this.addEventListener = (\n      name,\n      callback,\n      options = null,\n    ) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = []\n      }\n\n      // Add to events.\n      events[name].push({\n        callback,\n        options,\n      })\n    }\n\n    /**\n     * Remove callback from event.\n     * @param {string} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n    this.removeEventListener = (\n      name,\n      callback,\n    ) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return\n      }\n      const eventData = events[name]\n\n      // Get index of callback in events.\n      let index = -1\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i\n          break\n        }\n      }\n      if (index < 0) {\n        return\n      }\n\n      // Remove item from events.\n      eventData.splice(index, 1)\n\n      // Remove event if list is empty.\n      if (Object.keys(eventData).length === 0) {\n        delete events[name]\n      }\n    }\n\n    /**\n     * Remove listeners to an event.\n     * @param {string} name Event name.\n     */\n    this.removeEventListeners = (\n      name,\n    ) => {\n      if (!name) {\n        return\n      }\n\n      // Remove all handlers with the event name.\n      delete events[name]\n    }\n\n    /**\n     * Remove all listeners.\n     */\n    this.removeAllEventListeners = (\n    ) => {\n      // Remove all listeners.\n      events = {}\n    }\n\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {string} name Event name.\n     * @param {Array<any>} parameters Event parameters to pass through.\n     * @param {DispatchEventOptions} options Dispatch options.\n     */\n    this.dispatchEvent = (\n      name,\n      parameters,\n      options = null,\n    ) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return\n      }\n      // Get events by trigger name.\n      const eventData = events[name]\n\n      // Dispatch a call to each event.\n      for (let i = 0; i < eventData.length; i++) {\n        const event = (options && options.reverse) ? eventData[eventData.length - (i + 1)] : eventData[i]\n\n        // If once is truthy then remove the callback.\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1)\n        }\n\n        // Execute callback.\n        event.callback(...parameters)\n      }\n    }\n  }\n}\n", "// Import external modules.\nimport { pathToRegexp } from 'path-to-regexp'\n\n// Import event dispatcher.\nimport EventDispatcher from '@doars/common/src/events/EventDispatcher.js'\n\nexport default class Router extends EventDispatcher {\n  /**\n   * @param {object} options Router options.\n   * - {string} basePath = '' - Base path of the routes.\n   * - {string} path = '' - Initial active path.\n   * - {object} pathToRegexp = {} - Path-to-RegExp options used for parsing route paths.\n   * - {boolean} updateHistory = false - Whether to update the [History API](https://developer.mozilla.org/docs/Web/API/History_API).\n   */\n  constructor(\n    options = {},\n  ) {\n    super()\n\n    // Create id.\n    const id = Symbol('ID_ROUTER')\n\n    // Overwrite default with given options.\n    options = Object.assign({\n      basePath: '',\n      path: null,\n      pathToRegexp: {},\n      updateHistory: false,\n    }, options)\n\n    let path = options.path\n    let route = null\n    let routes = {}\n\n    // Listen for history state changes.\n    const handleHistory = (\n    ) => {\n      this.setPath(window.location.pathname)\n    }\n    if (options.updateHistory) {\n      window.addEventListener('popstate', handleHistory)\n    }\n\n    /**\n     * Update route.\n     * @param {string} url The base URL to update.\n     * @param {string} newPath The new path to update to.\n     * @param {string} newRoute The new route to update to.\n     */\n    const updateRoute = (\n      url,\n      newPath,\n      newRoute,\n    ) => {\n      // Update stored data.\n      path = newPath\n      route = newRoute\n\n      // Update page history if the option is set.\n      if (options.updateHistory) {\n        // Construct url.\n        const _url = url.includes(options.basePath) ? url : options.basePath + url\n        // Check if url is not current url.\n        if (_url !== window.location.pathname) {\n          // Add path to history.\n          window.history.pushState(null, window.document.title, _url)\n        }\n      }\n\n      // Dispatch event on router.\n      this.dispatchEvent('changed', [this, route, path])\n    }\n\n    /**\n     * Get router id.\n     * @returns {symbol} Unique identifier.\n     */\n    this.getId = (\n    ) => {\n      return id\n    }\n\n    /**\n     * Get current path.\n     * @returns {string} path.\n     */\n    this.getPath = (\n    ) => {\n      return path\n    }\n\n    /**\n     * Get current route.\n     * @returns {string} Route.\n     */\n    this.getRoute = (\n    ) => {\n      return route\n    }\n\n    /**\n     * Get observed routes.\n     * @returns {Array<string>} List of routers.\n     */\n    this.getRoutes = (\n    ) => {\n      return Object.keys(routes)\n    }\n\n    /**\n     * Destroy router instance.\n     */\n    this.destroy = (\n    ) => {\n      // Stop listening to state changes.\n      if (options.updateHistory) {\n        window.removeEventListener('popstate', handleHistory)\n      }\n\n      options = null\n      path = null\n      route = null\n      routes = null\n\n      // Dispatch add event.\n      this.dispatchEvent('destroyed', [this])\n\n      // Remove all listeners.\n      this.removeAllEventListeners()\n    }\n\n    /**\n     * Add route.\n     * @param {string} _route Route pattern.\n     */\n    this.addRoute = (\n      _route,\n    ) => {\n      // Convert path to regexp and store it in routes.\n      routes[_route] = pathToRegexp(_route, [], options.pathToRegexp)\n\n      // Dispatch add event.\n      this.dispatchEvent('added', [this, _route])\n\n      if (path) {\n        // Remove base url, if present.\n        const _path = path.replace(options.basePath, '')\n        // Check if current route is.\n        if (routes[_route].test(_path)) {\n          updateRoute(path, _path, _route)\n        }\n      }\n    }\n\n    /**\n     * Remove route.\n     * @param {string} _route Route pattern.\n     */\n    this.removeRoute = (\n      _route,\n    ) => {\n      // Delete route.\n      delete routes[_route]\n\n      // Dispatch removed event.\n      this.dispatchEvent('removed', [this, _route])\n\n      if (route === _route) {\n        // Set current route as none.\n        path = null\n        route = null\n\n        // Dispatch changed event.\n        this.dispatchEvent('changed', [this, route, path])\n      }\n    }\n\n    /**\n     * Set current route.\n     * @param {string} url URL path.\n     */\n    this.setPath = (\n      url,\n    ) => {\n      // Remove base url, if present.\n      const newPath = url.replace(options.basePath, '')\n      if (path === newPath) {\n        return\n      }\n\n      // Find matching routes.\n      let newRoute = null\n      for (const _route in routes) {\n        // Test route.\n        if (routes[_route].test(newPath)) {\n          newRoute = _route\n          break\n        }\n      }\n\n      // Update route.\n      updateRoute(url, newPath, newRoute)\n    }\n  }\n}\n", "// Import symbols.\nimport { ROUTER } from '../symbols.js'\nimport Router from '../Router.js'\n\n/**\n * Get closest router in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Router | undefined} Closest router.\n */\nconst closestRouter = (\n  element,\n) => {\n  if (element.parentElement) {\n    element = element.parentElement\n\n    if (element[ROUTER]) {\n      /** @type {Router} */\n      return element[ROUTER]\n    }\n\n    return closestRouter(element)\n  }\n}\n\nexport default closestRouter\n", "// Import polyfill.\nimport RevocableProxy from '@doars/common/src/polyfills/RevocableProxy.js'\n\n// Import symbol.\nimport { ROUTER } from '../symbols'\n\n// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\n\nexport default ({\n  routerContextName,\n}) => ({\n  name: routerContextName,\n\n  create: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    let router = null\n    const revocable = RevocableProxy({}, {\n      get: (\n        target,\n        propertyKey,\n        receiver,\n      ) => {\n        // Get closest router from hierarchy.\n        if (router === null) {\n          if (element[ROUTER]) {\n            router = element[ROUTER]\n          } else {\n            router = closestRouter(element)\n          }\n\n          // Set router to false so we don't look twice.\n          if (!router) {\n            router = false\n          }\n        }\n\n        // Mark as router accessed.\n        attribute.accessed(router.getId(), '')\n\n        if (!router) {\n          return\n        }\n\n        // Return router property.\n        return Reflect.get(router, propertyKey, receiver)\n      },\n    })\n\n    return {\n      value: revocable.proxy,\n\n      destroy: (\n      ) => {\n        revocable.revoke()\n      },\n    }\n  },\n})\n", "/**\n * Escape slashes, quotation marks, and new lines.\n * @param {string} text String to escape.\n * @returns {string} Escaped string.\n */\nexport const escapeHtml = (\n  text,\n) => {\n  return text\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(/\\\\'/g, '\\\\\\'')\n    .replace(/\\\\\"/g, '\\\\\"')\n    .replace(/\\n/g, '\\\\n')\n}\n\n/**\n * Convert a string from kebab-case to camelCase.\n * @param {string} text String to modify.\n * @returns {string} Converted string.\n */\nexport const kebabToCamel = (\n  text,\n) => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase())\n}\n\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<string>} modifiers List of modifiers to parse.\n * @returns {object} Parsed modifiers.\n */\nexport const parseAttributeModifiers = (\n  modifiers,\n) => {\n  const result = {}\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-')\n\n    // If no hyphen then set the modifiers to true.\n    if (hyphenIndex < 0) {\n      result[modifier] = true\n      continue\n    }\n\n    // If it starts with hyphen then set the modifier to false.\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false\n      continue\n    }\n\n    // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n    const key = modifier.substring(0, hyphenIndex)\n    let value = modifier.substring(hyphenIndex + 1)\n\n    let tmpValue = value\n\n    // Try to remove time suffixes.\n    let type\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2)\n    } else if (value.endsWith('s')) {\n      type = 's'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('m')) {\n      type = 'm'\n      tmpValue = value.substring(-1)\n    } else if (value.endsWith('h')) {\n      type = 'h'\n      tmpValue = value.substring(-1)\n    }\n\n    // Try to parse the value as a number.\n    tmpValue = Number.parseInt(tmpValue)\n    if (!isNaN(tmpValue)) {\n      value = tmpValue\n\n      // Convert to milliseconds if given in a different format.\n      switch (type) {\n        case 'h':\n          value *= 60\n        case 'm':\n          value *= 60\n        case 's':\n          value *= 1000\n          break\n      }\n    }\n\n    // Store modifier data.\n    result[key] = value\n  }\n\n  return result\n}\n\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {string} prefix Directive prefix.\n * @param {string} name Name to parse.\n * @returns {Array<string> | undefined} list of segments.\n */\nexport const parseAttributeName = (\n  prefix,\n  name,\n) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'))\n  if (!name) {\n    return\n  }\n  // Deconstruct match.\n  let [full, directive, keyRaw, modifiers] = name // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n  keyRaw = keyRaw !== '' ? keyRaw : null\n  const key = keyRaw ? kebabToCamel(keyRaw) : null\n  // Ensure modifiers is and array.\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []\n  // Return result a single array.\n  return [directive, keyRaw, key, modifiers]\n}\n\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n * @param {string} expression For expression to parse.\n * @returns {object | undefined} Iterable type and variables.\n */\nexport const parseForExpression = (\n  expression,\n) => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i)\n  if (!match) {\n    return\n  }\n\n  // Remove parenthesis.\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, '')\n  // Parse for variables.\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i)\n  if (!variables) {\n    return\n  }\n  variables.shift()\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables], // Convert it to an array instead of a regular expression match.\n  }\n}\n\n/**\n * Parse selector to an attributes object.\n * @param {string} selector Selector to parse.\n * @returns {object | undefined} Attributes. Do note the class property is a list of strings not a single string.\n */\nexport const parseSelector = (\n  selector,\n) => {\n  // Convert to array.\n  if (typeof (selector) === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/)\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.')\n    return\n  }\n\n  const attributes = {}\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim()\n\n    // Base what to do of the leading character.\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1)\n        break\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1)\n        // Add to classlist.\n        if (!attributes.class) {\n          attributes.class = []\n        }\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment)\n        }\n        break\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i) // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n        attributes[key] = value\n        break\n    }\n  }\n  return attributes\n}\n\nexport default {\n  escapeHtml,\n  kebabToCamel,\n  parseAttributeModifiers,\n  parseAttributeName,\n  parseForExpression,\n  parseSelector,\n}\n", "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to add.\n */\nexport const addAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className)\n      }\n      continue\n    }\n\n    // Set attribute.\n    element.setAttribute(name, data[name])\n  }\n}\n\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\nexport const copyAttributes = (\n  existingNode,\n  newNode,\n) => {\n  const existingAttributes = existingNode.attributes\n  const newAttributes = newNode.attributes\n  let attributeNamespaceURI = null\n  let attributeValue = null\n  let fromValue = null\n  let attributeName = null\n  let attribute = null\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i]\n    attributeName = attribute.name\n    attributeNamespaceURI = attribute.namespaceURI\n    attributeValue = attribute.value\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName)\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue)\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue)\n      } else {\n        fromValue = existingNode.getAttribute(attributeName)\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName)\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue)\n          }\n        }\n      }\n    }\n  }\n\n  // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j]\n    if (attribute.specified !== false) {\n      attributeName = attribute.name\n      attributeNamespaceURI = attribute.namespaceURI\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName)\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName)\n        }\n      }\n    }\n  }\n}\n\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {object} data Attribute data to remove.\n */\nexport const removeAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className)\n      }\n      continue\n    }\n\n    // Check if optional values match.\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue\n    }\n\n    // Remove attribute.\n    element.removeAttribute(name)\n  }\n}\n\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {string} key Attribute name.\n * @param {any} data Attribute data.\n */\nexport const setAttribute = (\n  element,\n  key,\n  data,\n) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = ''\n    }\n\n    // Exit early if nothing will change.\n    if (element.getAttribute(key) === data) {\n      return\n    }\n\n    // Update attribute.\n    element.setAttribute(key, data)\n\n    // Exit special cases early.\n    return\n  }\n\n  // If checked attribute then set the checked property instead.\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data\n      return\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ')\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ')\n    } else if (typeof (data) === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';')\n    }\n  }\n\n  // Update attribute on element.\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key)\n  } else {\n    element.setAttribute(key, data)\n  }\n}\n\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {object} data Attribute data to set.\n */\nexport const setAttributes = (\n  element,\n  data,\n) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name])\n  }\n}\n\nexport default {\n  addAttributes,\n  copyAttributes,\n  removeAttributes,\n  setAttribute,\n}\n", "// Import utilities.\nimport { parseSelector } from './String.js'\nimport { addAttributes, removeAttributes } from './Attribute.js'\n\n// Transition name.\nconst TRANSITION_NAME = '-transition:'\n\n/**\n * @callback TransitionEnd\n */\n\n/**\n * Transition an element.\n * @param {string} type Type of transition, for example 'in' and 'out'.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transition = (\n  type,\n  libraryOptions,\n  element,\n  callback = null,\n) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback()\n    }\n    return\n  }\n\n  // Transition attribute name.\n  const transitionDirectiveName = libraryOptions.prefix + TRANSITION_NAME + type\n\n  // Setup dispatcher function.\n  const dispatchEvent = (phase) => {\n    element.dispatchEvent(\n      new CustomEvent('transition-' + phase),\n    )\n    element.dispatchEvent(\n      new CustomEvent('transition-' + type + '-' + phase),\n    )\n  }\n\n  // Declare variables for later.\n  let name, value, timeout, requestFrame\n  let isDone = false\n  const selectors = {}\n\n  // Process transition during attribute.\n  name = transitionDirectiveName\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.during = parseSelector(value)\n    addAttributes(element, selectors.during)\n  }\n\n  // Process transition from attribute.\n  name = transitionDirectiveName + '.from'\n  value = element.getAttribute(name)\n  // Parse and apply returned selector.\n  if (value) {\n    selectors.from = parseSelector(value)\n    addAttributes(element, selectors.from)\n  }\n\n  // Dispatch transition event.\n  dispatchEvent('start')\n\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null\n\n    // If cancelled then stop immediately.\n    if (isDone) {\n      return\n    }\n\n    // Remove from selector.\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    }\n\n    // Process transition to attribute.\n    name = transitionDirectiveName + '.to'\n    value = element.getAttribute(name)\n    // Parse and apply returned selector.\n    if (value) {\n      selectors.to = parseSelector(value)\n      addAttributes(element, selectors.to)\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n      return\n    }\n\n    // Get computes style.\n    const styles = getComputedStyle(element)\n\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null\n\n      // If cancelled then stop immediately.\n      if (isDone) {\n        return\n      }\n\n      // Remove during selector.\n      if (selectors.during) {\n        removeAttributes(element, selectors.during)\n        selectors.during = undefined\n      }\n\n      // Remove to selector.\n      if (selectors.to) {\n        removeAttributes(element, selectors.to)\n        selectors.to = undefined\n      }\n\n      // Dispatch end event.\n      dispatchEvent('end')\n      // Invoke callback.\n      if (callback) {\n        callback()\n      }\n      // Mark as done.\n      isDone = true\n    }, duration)\n  })\n\n  return (\n  ) => {\n    if (!isDone) {\n      return\n    }\n    isDone = true\n\n    // Remove applied selector.\n    if (selectors.during) {\n      removeAttributes(element, selectors.during)\n      selectors.during = undefined\n    }\n    if (selectors.from) {\n      removeAttributes(element, selectors.from)\n      selectors.from = undefined\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to)\n      selectors.to = undefined\n    }\n\n    // Clear request animation frame and timeout.\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame)\n      requestFrame = null\n    } else if (timeout) {\n      clearTimeout(timeout)\n      timeout = null\n    }\n\n    // Dispatch end event.\n    dispatchEvent('end')\n    // Invoke callback.\n    if (callback) {\n      callback()\n    }\n  }\n}\n\n/**\n * Transition an element in.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionIn = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('in', libraryOptions, element, callback)\n}\n\n/**\n * Transition an element out.\n * @param {object} libraryOptions Library options.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n * @returns {TransitionEnd | undefined} Function to immediately end the transition.\n */\nexport const transitionOut = (\n  libraryOptions,\n  element,\n  callback,\n) => {\n  return transition('out', libraryOptions, element, callback)\n}\n\nexport default {\n  transition,\n  transitionIn,\n  transitionOut,\n}\n", "// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\nimport {\n  transitionIn,\n  transitionOut,\n} from '@doars/common/src/utilities/Transition.js'\n\nconst ROUTE = Symbol('ROUTE')\n\nexport default ({\n  routeDirectiveName,\n}) => ({\n  name: routeDirectiveName,\n\n  update: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct component and attribute.\n    const libraryOptions = component.getLibrary().getOptions()\n    const element = attribute.getElement()\n\n    let router\n    const setup = (\n    ) => {\n      // Stop listening to router and remove it.\n      if (router && attribute[ROUTE]) {\n        router.removeEventListener('changed', attribute[ROUTE].handler)\n        router.removeEventListener('destroyed', attribute[ROUTE].setup)\n\n        delete attribute[ROUTE]\n      }\n\n      // Get closest router in parent nodes.\n      router = closestRouter(element)\n      if (!router) {\n        console.warn('DoarsRouter: Router not found for route.')\n        return\n      }\n\n      // Setup route data.\n      attribute[ROUTE] = {\n        setup,\n      }\n\n      // Deconstruct attribute.\n      const value = attribute.getValue()\n\n      // Add route to router.\n      router.addRoute(value)\n\n      // Handle router changes.\n      const handleChange = (\n        router,\n        route,\n      ) => {\n        if (route !== value) {\n          if (element.tagName === 'TEMPLATE') {\n            if (attribute[ROUTE] && attribute[ROUTE].element) {\n              // Transition out.\n              const routeElement = attribute[ROUTE].element\n              transitionOut(libraryOptions, routeElement, () => {\n                // Remove node.\n                routeElement.remove()\n                attribute[ROUTE].element = undefined\n              })\n            }\n          } else {\n            // Transition out and set display none.\n            transitionOut(libraryOptions, element, () => {\n              element.style.display = 'none'\n            })\n          }\n        } else if (element.tagName === 'TEMPLATE') {\n          // Create new element from template.\n          const templateInstance = document.importNode(element.content, true)\n          // Add element after the template element.\n          element.insertAdjacentElement('afterend', templateInstance)\n          // Get HTMLElement reference instead of DocumentFragment.\n          attribute[ROUTE].element = element.nextSibling\n\n          // Transition in.\n          transitionIn(libraryOptions, attribute[ROUTE].element)\n        } else {\n          // Remove display none.\n          element.style.display = null\n\n          // Transition in.\n          transitionIn(libraryOptions, element)\n        }\n      }\n      attribute[ROUTE].handler = handleChange\n\n      // Listen to router changes and perform initial run.\n      router.addEventListener('changed', handleChange)\n      handleChange(router, router.getRoute())\n\n      // If the router is destroyed look for another\n      router.addEventListener('destroyed', setup)\n    }\n\n    // Perform initial setup.\n    setup()\n  },\n\n  destroy: (\n    component,\n    attribute, {\n      transitionOut,\n    },\n  ) => {\n    const libraryOptions = component.getLibrary().getOptions()\n\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n    if (element.tagName === 'TEMPLATE') {\n      if (attribute[ROUTE] && attribute[ROUTE].element) {\n        // Transition out.\n        const routeElement = attribute[ROUTE].element\n        transitionOut(libraryOptions, routeElement, () => {\n          // Remove node.\n          routeElement.remove()\n          attribute[ROUTE].element = undefined\n        })\n      }\n    } else {\n      // Transition out and set display none.\n      transitionOut(libraryOptions, element, () => {\n        element.style.display = 'none'\n      })\n    }\n\n    // Get closest router in parent nodes.\n    const router = closestRouter(element)\n    if (!router) {\n      return\n    }\n\n    // Remove router listeners.\n    if (attribute[ROUTE]) {\n      router.removeEventListener('destroyed', attribute[ROUTE].setup)\n      if (attribute[ROUTE].handler) {\n        router.removeEventListener('change', attribute[ROUTE].handler)\n      }\n    }\n  },\n})\n", "// Import router.\nimport Router from '../Router.js'\n\n// Import symbols.\nimport { ROUTER } from '../symbols.js'\n\nexport default (\n  options,\n) => ({\n  name: options.routerDirectiveName,\n\n  update: (\n    component,\n    attribute,\n    processExpression,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Get router.\n    let router = element[ROUTER]\n    if (!router) {\n      // Create router\n      router = element[ROUTER] = new Router(\n        Object.assign(\n          {},\n          options,\n          processExpression(\n            component,\n            attribute,\n            attribute.getValue(),\n          ),\n        ),\n      )\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement()\n\n    // Get router.\n    const router = element[ROUTER]\n    if (!router) {\n      return\n    }\n\n    // Remove router reference.\n    delete element[ROUTER]\n\n    // Deconstruct router.\n    const id = router.getId()\n\n    // Destroy router.\n    router.destroy()\n\n    // Deconstruct component.\n    const library = component.getLibrary()\n\n    // Trigger update due to changed router.\n    library.update([{\n      id,\n      path: '',\n    }])\n  },\n})\n", "// Import utilities.\nimport closestRouter from '../utilities/closestRouter.js'\n\nconst ROUTE_TO = Symbol('ROUTE_TO')\nconst CLICK = 'click'\n\nexport default ({\n  routeToDirectiveName,\n}) => ({\n  name: routeToDirectiveName,\n\n  update: (\n    component,\n    attribute,\n  ) => {\n    const element = attribute.getElement()\n    const modifiers = attribute.getModifiers()\n    const value = attribute.getValue()\n\n    // Check for existing data.\n    if (attribute[ROUTE_TO]) {\n      // Exit early if listener has not changed.\n      if (attribute[ROUTE_TO].value === value) {\n        return\n      }\n\n      // Remove existing listeners so we don't listen twice.\n      attribute[ROUTE_TO].target.removeEventListener(\n        CLICK,\n        attribute[ROUTE_TO].handler,\n      )\n    }\n\n    const handler = (event) => {\n      if (modifiers.self && event.target !== element) {\n        return\n      }\n\n      if (modifiers.prevent) {\n        event.preventDefault()\n      }\n      if (modifiers.stop) {\n        event.stopPropagation()\n      }\n\n      const router = closestRouter(element)\n      if (!router) {\n        return\n      }\n\n      router.setPath(value)\n    }\n\n    // Listen to click and keyboard events.\n    element.addEventListener(CLICK, handler)\n\n    // Store listener data on the component.\n    attribute[ROUTE_TO] = {\n      handler,\n      value,\n    }\n  },\n\n  destroy: (\n    component,\n    attribute,\n  ) => {\n    if (!attribute[ROUTE_TO]) {\n      return\n    }\n\n    const element = attribute.getElement()\n\n    element.removeEventListener(CLICK, attribute[ROUTE_TO].handler)\n\n    delete attribute[ROUTE_TO]\n  },\n})\n", "/**\n * @typedef {import('@doars/doars').default} Doars\n */\n\nimport { deepAssign } from '@doars/common/src/utilities/Object.js'\n\nimport createRouterContext from './contexts/router.js'\nimport createRouteDirective from './directives/route.js'\nimport createRouterDirective from './directives/router.js'\nimport createRouteToDirective from './directives/routeTo.js'\n\n/**\n * Create plugin instance.\n * @param {Doars} library Doars instance to add onto.\n * @param {object} options The plugin options.\n */\nexport default function (\n  library,\n  options = null,\n) {\n  // Clone options.\n  options = deepAssign({\n    basePath: '',\n    path: '',\n    pathToRegexp: {},\n    updateHistory: false,\n\n    routerContextName: '$router',\n    routeDirectiveName: 'route',\n    routerDirectiveName: 'router',\n    routeToDirectiveName: 'route-to',\n  }, options)\n\n  // Set private variables.\n  let isEnabled = false\n  const routerContext = createRouterContext(options),\n    routeDirective = createRouteDirective(options),\n    routerDirective = createRouterDirective(options),\n    routeToDirective = createRouteToDirective(options)\n\n  const onEnable = (\n  ) => {\n    // Add contexts and directives.\n    library.addContexts(0, routerContext)\n    library.addDirectives(\n      -1,\n      routeDirective,\n      routerDirective,\n      routeToDirective,\n    )\n  }\n  const onDisable = (\n  ) => {\n    // Remove contexts and directives.\n    library.removeContexts(routerContext)\n    library.removeDirectives(\n      routeDirective,\n      routerDirective,\n      routeToDirective,\n    )\n  }\n\n  this.disable = (\n  ) => {\n    // Check if library is disabled.\n    if (!library.getEnabled() && isEnabled) {\n      isEnabled = false\n\n      // Stop listening to enable state of the library.\n      library.removeEventListener('enabling', onEnable)\n      library.removeEventListener('disabling', onDisable)\n    }\n  }\n\n  this.enable = (\n  ) => {\n    if (!isEnabled) {\n      isEnabled = true\n\n      // Listen to enable state of the library.\n      library.addEventListener('enabling', onEnable)\n      library.addEventListener('disabling', onDisable)\n    }\n  }\n\n  // Automatically enable plugin.\n  this.enable()\n}\n"],
  "mappings": "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",
  "names": ["deepAssign", "target", "sources", "source", "isObject", "key", "value", "isObject", "value", "PROXY_TRAPS", "RevocableProxy_default", "target", "handler", "revoked", "revocableHandler", "key", "parameters", "ROUTER", "lexer", "str", "tokens", "i", "char", "name", "j", "code", "count", "pattern", "parse", "options", "_a", "prefixes", "defaultPattern", "escapeString", "result", "key", "path", "tryConsume", "type", "mustConsume", "value", "nextType", "index", "consumeText", "prefix", "open", "name_1", "pattern_1", "suffix", "escapeString", "str", "flags", "options", "regexpToRegexp", "path", "keys", "groupsRegex", "index", "execResult", "arrayToRegexp", "paths", "parts", "pathToRegexp", "stringToRegexp", "tokensToRegexp", "parse", "tokens", "_a", "strict", "_b", "start", "_c", "end", "_d", "encode", "x", "_e", "delimiter", "_f", "endsWith", "endsWithRe", "delimiterRe", "route", "_i", "tokens_1", "token", "prefix", "suffix", "mod", "endToken", "isEndDelimited", "EventDispatcher", "events", "name", "callback", "options", "eventData", "index", "i", "parameters", "event", "Router", "EventDispatcher", "options", "id", "path", "route", "routes", "handleHistory", "updateRoute", "url", "newPath", "newRoute", "_url", "_route", "pathToRegexp", "_path", "closestRouter", "element", "ROUTER", "closestRouter_default", "router_default", "routerContextName", "component", "attribute", "element", "router", "revocable", "RevocableProxy_default", "target", "propertyKey", "receiver", "ROUTER", "closestRouter_default", "parseSelector", "selector", "attributes", "selectorSegment", "full", "key", "value", "addAttributes", "element", "data", "name", "className", "removeAttributes", "element", "data", "name", "className", "TRANSITION_NAME", "transition", "type", "libraryOptions", "element", "callback", "transitionDirectiveName", "dispatchEvent", "phase", "name", "value", "timeout", "requestFrame", "isDone", "selectors", "parseSelector", "addAttributes", "removeAttributes", "styles", "duration", "transitionIn", "transitionOut", "ROUTE", "route_default", "routeDirectiveName", "component", "attribute", "libraryOptions", "element", "router", "setup", "closestRouter_default", "value", "handleChange", "route", "routeElement", "transitionOut", "templateInstance", "transitionIn", "router_default", "options", "component", "attribute", "processExpression", "element", "router", "ROUTER", "Router", "id", "ROUTE_TO", "CLICK", "routeTo_default", "routeToDirectiveName", "component", "attribute", "element", "modifiers", "value", "handler", "event", "router", "closestRouter_default", "DoarsRouter_default", "library", "options", "deepAssign", "isEnabled", "routerContext", "router_default", "routeDirective", "route_default", "routerDirective", "routeToDirective", "routeTo_default", "onEnable", "onDisable"]
}
