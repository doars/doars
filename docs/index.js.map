{
  "version": 3,
  "sources": ["../.docs/node_modules/@doars/doars/src/symbols.js", "../.docs/node_modules/@doars/doars/src/events/EventDispatcher.js", "../.docs/node_modules/@doars/doars/src/utils/StringUtils.js", "../.docs/node_modules/@doars/doars/src/Attribute.js", "../.docs/node_modules/@doars/doars/src/polyfills/RevocableProxy.js", "../.docs/node_modules/@doars/doars/src/events/ProxyDispatcher.js", "../.docs/node_modules/@doars/doars/src/utils/AttributeUtils.js", "../.docs/node_modules/@doars/doars/src/utils/ElementUtils.js", "../.docs/node_modules/@doars/doars/src/utils/MorphUtils.js", "../.docs/node_modules/@doars/doars/src/utils/ComponentUtils.js", "../.docs/node_modules/@doars/doars/src/utils/ExpressionUtils.js", "../.docs/node_modules/@doars/doars/src/utils/TransitionUtils.js", "../.docs/node_modules/@doars/doars/src/Component.js", "../.docs/node_modules/@doars/doars/src/contexts/children.js", "../.docs/node_modules/@doars/doars/src/contexts/component.js", "../.docs/node_modules/@doars/doars/src/contexts/element.js", "../.docs/node_modules/@doars/doars/src/contexts/dispatch.js", "../.docs/node_modules/@doars/doars/src/contexts/for.js", "../.docs/node_modules/@doars/doars/src/contexts/inContext.js", "../.docs/node_modules/@doars/doars/src/contexts/nextTick.js", "../.docs/node_modules/@doars/doars/src/contexts/parent.js", "../.docs/node_modules/@doars/doars/src/contexts/references.js", "../.docs/node_modules/@doars/doars/src/contexts/state.js", "../.docs/node_modules/@doars/doars/src/utils/PromiseUtils.js", "../.docs/node_modules/@doars/doars/src/directives/attribute.js", "../.docs/node_modules/@doars/doars/src/directives/cloak.js", "../.docs/node_modules/@doars/doars/src/directives/for.js", "../.docs/node_modules/@doars/doars/src/utils/HtmlUtils.js", "../.docs/node_modules/@doars/doars/src/directives/html.js", "../.docs/node_modules/@doars/doars/src/directives/if.js", "../.docs/node_modules/@doars/doars/src/directives/initialized.js", "../.docs/node_modules/@doars/doars/src/directives/on.js", "../.docs/node_modules/@doars/doars/src/directives/reference.js", "../.docs/node_modules/@doars/doars/src/directives/select.js", "../.docs/node_modules/@doars/doars/src/directives/show.js", "../.docs/node_modules/@doars/doars/src/utils/ObjectUtils.js", "../.docs/node_modules/@doars/doars/src/factories/directives/sync.js", "../.docs/node_modules/@doars/doars/src/directives/syncState.js", "../.docs/node_modules/@doars/doars/src/directives/text.js", "../.docs/node_modules/@doars/doars/src/directives/watch.js", "../.docs/node_modules/@doars/doars/src/Doars.js", "../.docs/src/scripts/index.js"],
  "sourcesContent": ["export const ATTRIBUTES = Symbol('ATTRIBUTES');\nexport const COMPONENT = Symbol('COMPONENT');\nexport const FOR = Symbol('FOR');\nexport const IGNORE = Symbol('IGNORE');\nexport const INITIALIZED = Symbol('INITIALIZED');\nexport const ON = Symbol('ON');\nexport const REFERENCES = Symbol('REFERENCES');\nexport const REFERENCES_CACHE = Symbol('REFERENCES_CACHE');\nexport const SYNC = Symbol('SYNC');\nexport const SYNC_STATE = Symbol('SYNC_STATE');", "class EventDispatcher {\n  /**\n   * Create instance.\n   */\n  constructor() {\n    let events = {};\n    /**\n     * Add callback to event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function to call on dispatch.\n     * @param {Object} options Callback options.\n     */\n\n    this.addEventListener = (name, callback, options = null) => {\n      // Check if event name exits and callback is not already present.\n      if (!(name in events)) {\n        events[name] = [];\n      } // Add to events.\n\n\n      events[name].push({\n        callback: callback,\n        options: options\n      });\n    };\n    /**\n     * Remove callback from event.\n     * @param {String} name Event name.\n     * @param {Function} callback Function that would be called.\n     */\n\n\n    this.removeEventListener = (name, callback) => {\n      // Check if event exists.\n      if (!Object.keys(events).includes(name)) {\n        return;\n      }\n\n      const eventData = events[name]; // Get index of callback in events.\n\n      let index = -1;\n\n      for (let i = 0; i < eventData.length; i++) {\n        if (eventData[i].callback === callback) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index < 0) {\n        return;\n      } // Remove item from events.\n\n\n      eventData.splice(index, 1); // Remove event if list is empty.\n\n      if (Object.keys(eventData).length === 0) {\n        delete events[name];\n      }\n    };\n    /**\n     * Remove listeners to an event.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeEventListeners = name => {\n      if (!name) {\n        return;\n      } // Remove all handlers with the event name.\n\n\n      delete events[name];\n    };\n    /**\n     * Remove all listeners.\n     * @param {String} name Event name.\n     */\n\n\n    this.removeAllEventListeners = () => {\n      // Remove all listeners.\n      events = {};\n    };\n    /**\n     * Trigger event and dispatch data to listeners.\n     * @param {String} name Event name.\n     * @param {Array<Any>} parameters Event parameters to pass through.\n     * @param {Object} options Dispatch options.\n     */\n\n\n    this.dispatchEvent = (name, parameters, options = null) => {\n      // Check if event exists.\n      if (!events[name]) {\n        return;\n      } // Get events by trigger name.\n\n\n      const eventData = events[name]; // Dispatch a call to each event.\n\n      for (let i = 0; i < eventData.length; i++) {\n        const event = options && options.reverse ? eventData[eventData.length - (i + 1)] : eventData[i]; // If once is truthy then remove the callback.\n\n        if (event.options && event.options.once) {\n          eventData.splice(i, 1);\n        } // Execute callback.\n\n\n        event.callback(...parameters);\n      }\n    };\n  }\n\n}\n\nexport default EventDispatcher;", "/**\n  * Convert a string from kebab-case to camelCase.\n  * @param {String} text String to modify.\n  * @returns {String} Converted string.\n  */\nexport const kebabToCamel = text => {\n  return text.replace(/-(\\w)/g, (match, character) => character.toUpperCase());\n};\n/**\n * Parse list of modifiers to an object.\n * - [ 'hello', 'there-100', 'general-kenobi' ]\n *    -> { 'hello': true, 'there': 100, 'general': 'kenobi' }\n * @param {Array<String>} modifiers List of modifiers to parse.\n * @returns {Object} Parsed modifiers.\n */\n\nexport const parseAttributeModifiers = modifiers => {\n  const result = {};\n\n  for (const modifier of modifiers) {\n    // Get index of hyphen.\n    const hyphenIndex = modifier.indexOf('-'); // If no hyphen then set the modifiers to true.\n\n    if (hyphenIndex < 0) {\n      result[modifier] = true;\n      continue;\n    } // If it starts with hyphen then set the modifier to false.\n\n\n    if (hyphenIndex === 0) {\n      result[modifier.substring(1)] = false;\n      continue;\n    } // If the hyphen is somewhere in the modifier then assume it is used as a split character.\n\n\n    const key = modifier.substring(0, hyphenIndex);\n    let value = modifier.substring(hyphenIndex + 1);\n    let tmpValue = value; // Try to remove time suffixes.\n\n    let type;\n\n    if (value.endsWith('ms')) {\n      tmpValue = value.substring(-2);\n    } else if (value.endsWith('s')) {\n      type = 's';\n      tmpValue = value.substring(-1);\n    } else if (value.endsWith('m')) {\n      type = 'm';\n      tmpValue = value.substring(-1);\n    } else if (value.endsWith('h')) {\n      type = 'h';\n      tmpValue = value.substring(-1);\n    } // Try to parse the value as a number.\n\n\n    tmpValue = Number.parseInt(tmpValue);\n\n    if (!isNaN(tmpValue)) {\n      value = tmpValue; // Convert to milliseconds if given in a different format.\n\n      switch (type) {\n        case 'h':\n          value *= 60;\n\n        case 'm':\n          value *= 60;\n\n        case 's':\n          value *= 1000;\n          break;\n      }\n    } // Store modifier data.\n\n\n    result[key] = value;\n  }\n\n  return result;\n};\n/**\n * Parse attribute name to list of segments.\n * Valid formats are:\n * - \"d-directive\"\n *    -> [ 'directive', null, null, null ]\n * - \"d-directive:key\"\n *    -> [ 'directive', 'key', 'key', null ]\n * - \"d-directive:key-name\"\n *    -> [ 'directive', 'key-name', 'keyName', null ]\n * - \"d-directive:key-name.modifiers\"\n *    -> [ 'directive', 'key-name', 'keyName', [ 'modifiers' ] ]\n * - \"d-directive.modifiers.multiple\"\n *    -> [ 'directive', null, null, [ 'modifiers', 'multiple' ] ]\n * @param {String} name Name to parse.\n * @returns {Array<String>} list of segments.\n */\n\nexport const parseAttributeName = (prefix, name) => {\n  // Match with expression.\n  name = name.match(new RegExp('^' + prefix + '-([a-z][0-9a-z-]{1,}):?([a-z][0-9a-z-]*)?(\\\\..*]*)?$', 'i'));\n\n  if (!name) {\n    return;\n  } // Deconstruct match.\n\n\n  let [full, directive, keyRaw, modifiers] = name; // eslint-disable-line no-unused-vars\n  // If no key provided set it to null instead of empty.\n\n  keyRaw = keyRaw !== '' ? keyRaw : null;\n  const key = keyRaw ? kebabToCamel(keyRaw) : null; // Ensure modifiers is and array.\n\n  modifiers = modifiers ? modifiers.substring(1).split('.') : []; // Return result a single array.\n\n  return [directive, keyRaw, key, modifiers];\n};\n/**\n * Parses for expression. Valid expression formats are:\n * - \"index of 4\"\n *    -> { iterable: \"4\", variables: [ \"index\" ] }\n * - \"item of items\"\n *    -> { iterable: \"items\", variables: [ \"item\" ] }\n * - \"key in object\"\n *    -> { iterable: \"object\", variables: [ \"key\" ] }\n * - \"(key, value) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\" ] }\n * - \"(key, value, index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", \"value\", \"index\" ] }\n * - \"(key, , index) in object\"\n *    -> { iterable: \"object\", variables: [ \"key\", undefined, \"index\" ] }\n */\n\nexport const parseForExpression = expression => {\n  // Split variables from items expression.\n  const match = expression.match(/^([$_a-z0-9,(){}\\s]{1,}?)\\s+(?:in|of)\\s+([\\s\\S]{1,})$/i);\n\n  if (!match) {\n    return;\n  } // Remove parenthesis.\n\n\n  let variables = match[1].replace(/^[\\s({]*|[)}\\s]*$/g, ''); // Parse for variables.\n\n  variables = variables.match(/^([$_a-z0-9]{1,})?(?:,\\s+?)?([$_a-z0-9]{1,})?(?:,\\s+)?([$_a-z0-9]{1,})?$/i);\n\n  if (!variables) {\n    return;\n  }\n\n  variables.shift();\n  return {\n    iterable: match[2].trim(),\n    variables: [...variables] // Convert it to an array instead of a regular expression match.\n\n  };\n};\n/**\n * Parse selector to an attributes object.\n * @param {String} selector Selector to parse.\n * @returns {Object} Attributes. Do note the class property is a list of strings not a single string.\n */\n\nexport const parseSelector = selector => {\n  // Convert to array.\n  if (typeof selector === 'string') {\n    selector = selector.split(/(?=\\.)|(?=#)|(?=\\[)/);\n  }\n\n  if (!Array.isArray(selector)) {\n    console.error('Doars: parseSelector expects Array of string or a single string.');\n    return;\n  }\n\n  const attributes = {};\n\n  for (let selectorSegment of selector) {\n    // Trim spaces.\n    selectorSegment = selectorSegment.trim(); // Base what to do of the leading character.\n\n    switch (selectorSegment[0]) {\n      case '#':\n        // Remove leading character and store as id.\n        attributes.id = selectorSegment.substring(1);\n        break;\n\n      case '.':\n        // Remove leading character.\n        selectorSegment = selectorSegment.substring(1); // Add to classlist.\n\n        if (!attributes.class) {\n          attributes.class = [];\n        }\n\n        if (!attributes.class.includes(selectorSegment)) {\n          attributes.class.push(selectorSegment);\n        }\n\n        break;\n\n      case '[':\n        // Remove brackets and split key from value.\n        const [full, key, value] = selectorSegment.match(/^(?:\\[)?([-$_.a-z0-9]{1,})(?:[$*^])?(?:=)?([\\s\\S]{0,})(?:\\])$/i); // eslint-disable-line no-unused-vars\n        // Store attribute value in results.\n\n        attributes[key] = value;\n        break;\n    }\n  }\n\n  return attributes;\n};\nexport default {\n  kebabToCamel: kebabToCamel,\n  parseAttributeModifiers: parseAttributeModifiers,\n  parseAttributeName: parseAttributeName,\n  parseForExpression: parseForExpression,\n  parseSelector: parseSelector\n};", "// Import event dispatcher.\nimport EventDispatcher from './events/EventDispatcher.js'; // Import symbols.\n\nimport { ATTRIBUTES } from './symbols.js'; // Import utils.\n\nimport { parseAttributeName, parseAttributeModifiers } from './utils/StringUtils.js';\nexport default class Attribute extends EventDispatcher {\n  /**\n   * Create instance.\n   * @param {Component} component Component instance.\n   * @param {HTMLElement} element Element.\n   * @param {String} name Attribute name (with library prefix removed).\n   * @param {String} value Attribute value.\n   * @param {Boolean} isClone Whether this will be a clone of an existing attribute.\n   */\n  constructor(component, element, name, value, isClone = false) {\n    super(); // Create unique ID.\n\n    const id = Symbol('ID_ATTRIBUTE');\n\n    if (!isClone) {\n      // Add attribute reference to the element.\n      if (!element[ATTRIBUTES]) {\n        element[ATTRIBUTES] = [];\n      }\n\n      element[ATTRIBUTES].push(this);\n    } // Create private variables.\n\n\n    let accessedItems = {},\n        data = null,\n        directive,\n        key,\n        keyRaw,\n        modifiersRaw,\n        modifiers; // Parse and store name.\n\n    if (name) {\n      // Parse and store attribute name.\n      const [_directive, _keyRaw, _key, _modifiers] = parseAttributeName(component.getLibrary().getOptions().prefix, name);\n      directive = _directive;\n      key = _key;\n      keyRaw = _keyRaw;\n      modifiersRaw = _modifiers; // Parse and store modifiers.\n\n      if (_modifiers) {\n        modifiers = parseAttributeModifiers(_modifiers);\n      }\n    }\n    /**\n     * Get the component this attribute is a part of.\n     * @returns {Component} Attribute's component.\n     */\n\n\n    this.getComponent = () => {\n      return component;\n    };\n    /**\n     * Get the element this attribute belongs to.\n     * @returns {HTMLElement} Element.\n     */\n\n\n    this.getElement = () => {\n      return element;\n    };\n    /**\n     * Get attribute id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get the directive this attribute matches.\n     * @returns {String} Directive name.\n     */\n\n\n    this.getDirective = () => {\n      return directive;\n    };\n    /**\n     * Get the optional key of the attribute.\n     * @returns {String} Key.\n     */\n\n\n    this.getKey = () => {\n      return key;\n    };\n    /**\n     * Get the optional key of the attribute before being processed.\n     * @returns {String} Raw key.\n     */\n\n\n    this.getKeyRaw = () => {\n      return keyRaw;\n    };\n    /**\n     * Get the optional modifiers of the attribute.\n     * @returns {Object} Modifiers object.\n     */\n\n\n    this.getModifiers = () => {\n      return Object.assign({}, modifiers);\n    };\n    /**\n     * Get the optional modifiers of the attribute before being processed.\n     * @returns {Array<String>} List of raw modifiers.\n     */\n\n\n    this.getModifiersRaw = () => {\n      return modifiersRaw;\n    };\n    /**\n     * Get attribute's name.\n     * @returns {String} Attribute name.\n     */\n\n\n    this.getName = () => {\n      return name;\n    };\n    /**\n     * Get the attribute's value.\n     * @returns {String} Value.\n     */\n\n\n    this.getValue = () => {\n      return value;\n    };\n    /**\n     * Set the attribute's value.\n     * @param {String} value New value.\n     */\n\n\n    this.setValue = _value => {\n      value = _value; // Dispatch changed event.\n\n      this.dispatchEvent('changed', [this]);\n    };\n    /**\n     * Clear custom data set.\n     */\n\n\n    this.clearData = () => {\n      data = null;\n    };\n    /**\n     * Whether there is data set.\n     * @returns {boolean} Whether data is set.\n     */\n\n\n    this.hasData = () => {\n      return data !== null;\n    };\n    /**\n     * Get custom data set previously.\n     * @returns {any} the data.\n     */\n\n\n    this.getData = () => {\n      return data;\n    };\n    /**\n     * Set custom attribute data.\n     * @param {any} data Some data.\n     */\n\n\n    this.setData = _data => {\n      data = _data;\n    };\n    /**\n     * Destroy the attribute.\n     */\n\n\n    this.destroy = () => {\n      // Clear data.\n      this.setData(null); // Clear accessed.\n\n      this.clearAccessed(); // Remove attribute from element's attributes.\n\n      const indexInElement = element[ATTRIBUTES].indexOf(this);\n\n      if (indexInElement >= 0) {\n        element[ATTRIBUTES].splice(indexInElement, 1);\n      } // Dispatch destroy event.\n\n\n      this.dispatchEvent('destroyed', [this]); // Remove all listeners.\n\n      this.removeAllEventListeners();\n    };\n    /**\n     * Mark an item as accessed.\n     * @param {Symbol} id Unique identifier.\n     * @param {String} path Context path.\n     */\n\n\n    this.accessed = (id, path) => {\n      if (!accessedItems[id]) {\n        accessedItems[id] = [];\n      } else if (accessedItems[id].includes(path)) {\n        return;\n      }\n\n      accessedItems[id].push(path); // Dispatch accessed event.\n\n      this.dispatchEvent('accessed', [this, id, path]);\n    };\n    /**\n     * Clear list of accessed items.\n     */\n\n\n    this.clearAccessed = () => {\n      accessedItems = {};\n    };\n    /**\n     * Check if attribute accessed any of the item's paths.\n     * @param {Symbol} id Unique identifier.\n     * @param {Array<String>} paths Contexts path.\n     * @returns {Boolean} Whether any item's path was accessed.\n     */\n\n\n    this.hasAccessed = (id, paths) => {\n      if (!(id in accessedItems)) {\n        return false;\n      }\n\n      const accessedAtId = accessedItems[id];\n\n      for (const path of paths) {\n        if (accessedAtId.includes(path)) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n    /**\n     * Creates a clone of the attribute without copying over the id and accessed values.\n     * @returns {Attribute} Cloned attribute.\n     */\n\n\n    this.clone = () => {\n      // Create new attribute as clone.\n      return new Attribute(component, element, name, value, true);\n    };\n  }\n\n}", "// List of methods to revoke access to.\nconst REFLECTION_METHODS = ['apply', 'construct', 'defineProperty', 'deleteProperty', 'get', 'getOwnPropertyDescriptor', 'getPrototypeOf', 'isExtensible', 'ownKeys', 'preventExtensions', 'set', 'setPrototypeOf'];\n/**\n * Revocable proxy made using regular a proxy and a simple boolean.\n */\n\nexport default ((target, handler) => {\n  // Keep track of status.\n  let revoked = false; // Add revocable handlers for each given handlers.\n\n  const revocableHandler = {};\n\n  for (const key of REFLECTION_METHODS) {\n    revocableHandler[key] = (...parameters) => {\n      if (revoked) {\n        console.error('illegal operation attempted on a revoked proxy');\n        return;\n      }\n\n      if (key in handler) {\n        return handler[key](...parameters);\n      }\n\n      return Reflect[key](...parameters);\n    };\n  } // Return proxy and revoke method.\n\n\n  return {\n    proxy: new Proxy(target, revocableHandler),\n    revoke: () => {\n      revoked = true;\n    }\n  };\n});", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js'; // Import event dispatcher.\n\nimport EventDispatcher from './EventDispatcher.js';\n\nclass ProxyDispatcher extends EventDispatcher {\n  constructor(options = {}) {\n    super();\n    options = Object.assign({\n      delete: true,\n      get: true,\n      set: true\n    }, options); // Setup WeakMap for keep track of created proxies.\n\n    const map = new WeakMap();\n    /**\n     * Add object to start keeping track of it.\n     * @param {Object} target Object that is being kept track of.\n     * @param {Array<String>} path Path of object on optional parent object, used for recursion.\n     * @returns {Proxy} Object to access and mutate.\n     */\n\n    this.add = (target, path = []) => {\n      // Exit early if proxy already exists.\n      if (map.has(target)) {\n        return map.get(target);\n      } // Recursively create proxies for each property.\n\n\n      for (const key in target) {\n        if (target[key] && typeof target[key] === 'object') {\n          target[key] = this.add(target[key], [...path, key]);\n        }\n      } // Create handler and add the handler for which a callback exits..\n\n\n      const handler = {};\n\n      if (options.delete) {\n        handler.deleteProperty = (target, key) => {\n          // Exit early successful if property doesn't exist.\n          if (!Reflect.has(target, key)) {\n            return true;\n          } // Remove proxy.\n\n\n          this.remove(target, key); // Delete property.\n\n          const deleted = Reflect.deleteProperty(target, key); // Dispatch delete event.\n\n          if (deleted) {\n            this.dispatchEvent('delete', [target, Array.isArray(target) ? [...path] : [...path, key]]);\n          } // Return deleted.\n\n\n          return deleted;\n        };\n      }\n\n      if (options.get) {\n        handler.get = (target, key, receiver) => {\n          // Dispatch get event.\n          if (key !== Symbol.unscopables) {\n            this.dispatchEvent('get', [target, [...path, key], receiver]);\n          } // Return value from object.\n\n\n          return Reflect.get(target, key, receiver);\n        };\n      }\n\n      if (options.set) {\n        handler.set = (target, key, value, receiver) => {\n          // Exit early if not changed.\n          if (target[key] === value) {\n            return true;\n          } // Add proxy if value is an object.\n\n\n          if (typeof value === 'object') {\n            value = this.add(value, [...path, key]);\n          } // Store value.\n\n\n          target[key] = value; // Dispatch set event. If the target is an array and a new item has been pushed then the length has also changed, therefore a more generalizable path will be dispatched.\n\n          this.dispatchEvent('set', [target, Array.isArray(target) ? [...path] : [...path, key], value, receiver]); // Return success.\n\n          return true;\n        };\n      } // Create proxy.\n\n\n      const revocable = RevocableProxy(target, handler); // Store target at proxy.\n\n      map.set(revocable, target); // Return proxy.\n\n      return revocable.proxy;\n    };\n    /**\n     * Remove object from being kept track of.\n     * @param {Object} target Object that is being kept track of.\n     */\n\n\n    this.remove = target => {\n      // Remove target from the map.\n      if (!map.has(target)) {\n        return;\n      }\n\n      const revocable = map.get(target);\n      map.delete(revocable); // Recursively remove properties as well.\n\n      for (const property in revocable.proxy) {\n        if (typeof revocable.proxy[property] === 'object') {\n          this.remove(revocable.proxy[property]);\n        }\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    };\n  }\n\n}\n\nexport default ProxyDispatcher;", "/**\n * Add attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to add.\n */\nexport const addAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.add(className);\n      }\n\n      continue;\n    } // Set attribute.\n\n\n    element.setAttribute(name, data[name]);\n  }\n};\n/**\n * Copy all attributes onto one node from another.\n * @param {HTMLElement} existingNode Node to copy to.\n * @param {HTMLElement} newNode Node to copy from.\n */\n\nexport const copyAttributes = (existingNode, newNode) => {\n  const existingAttributes = existingNode.attributes;\n  const newAttributes = newNode.attributes;\n  let attributeNamespaceURI = null;\n  let attributeValue = null;\n  let fromValue = null;\n  let attributeName = null;\n  let attribute = null;\n\n  for (let i = newAttributes.length - 1; i >= 0; --i) {\n    attribute = newAttributes[i];\n    attributeName = attribute.name;\n    attributeNamespaceURI = attribute.namespaceURI;\n    attributeValue = attribute.value;\n\n    if (attributeNamespaceURI) {\n      attributeName = attribute.localName || attributeName;\n      fromValue = existingNode.getAttributeNS(attributeNamespaceURI, attributeName);\n\n      if (fromValue !== attributeValue) {\n        existingNode.setAttributeNS(attributeNamespaceURI, attributeName, attributeValue);\n      }\n    } else {\n      if (!existingNode.hasAttribute(attributeName)) {\n        existingNode.setAttribute(attributeName, attributeValue);\n      } else {\n        fromValue = existingNode.getAttribute(attributeName);\n\n        if (fromValue !== attributeValue) {\n          // apparently values are always cast to strings, ah well\n          if (attributeValue === 'null' || attributeValue === 'undefined') {\n            existingNode.removeAttribute(attributeName);\n          } else {\n            existingNode.setAttribute(attributeName, attributeValue);\n          }\n        }\n      }\n    }\n  } // Remove any extra attributes found on the original DOM element that\n  // weren't found on the target element.\n\n\n  for (let j = existingAttributes.length - 1; j >= 0; --j) {\n    attribute = existingAttributes[j];\n\n    if (attribute.specified !== false) {\n      attributeName = attribute.name;\n      attributeNamespaceURI = attribute.namespaceURI;\n\n      if (attributeNamespaceURI) {\n        attributeName = attribute.localName || attributeName;\n\n        if (!newNode.hasAttributeNS(attributeNamespaceURI, attributeName)) {\n          existingNode.removeAttributeNS(attributeNamespaceURI, attributeName);\n        }\n      } else {\n        if (!newNode.hasAttributeNS(null, attributeName)) {\n          existingNode.removeAttribute(attributeName);\n        }\n      }\n    }\n  }\n};\n/**\n * Remove attributes on an element based of an object.\n * @param {HTMLElement} element Element to remove the attributes from.\n * @param {Object} data Attribute data to remove.\n */\n\nexport const removeAttributes = (element, data) => {\n  for (const name in data) {\n    if (name === 'class') {\n      // Add classes to classlist.\n      for (const className of data.class) {\n        element.classList.remove(className);\n      }\n\n      continue;\n    } // Check if optional values match.\n\n\n    if (data[name] && element.attributes[name] !== data[name]) {\n      continue;\n    } // Remove attribute.\n\n\n    element.removeAttribute(name);\n  }\n};\n/**\n * Set data at key on element as attribute.\n * @param {HTMLElement} element Element to set attribute of.\n * @param {String} key Attribute name.\n * @param {Any} data Attribute data.\n */\n\nexport const setAttribute = (element, key, data) => {\n  // Check if a special attribute key.\n  if (key === 'value' && element.tagName === 'INPUT') {\n    if (!data) {\n      data = '';\n    } // Exit early if nothing will change.\n\n\n    if (element.getAttribute(key) === data) {\n      return;\n    } // Update attribute.\n\n\n    element.setAttribute(key, data); // Exit special cases early.\n\n    return;\n  } // If checked attribute then set the checked property instead.\n\n\n  if (key === 'checked') {\n    if (element.type === 'checkbox' || element.type === 'radio') {\n      element.checked = !!data;\n      return;\n    }\n  }\n\n  if (key === 'class') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).filter(([key, value]) => value).map(([key]) => key).join(' ');\n    }\n  }\n\n  if (key === 'style') {\n    if (Array.isArray(data)) {\n      // Join values together if it is a list of classes.\n      data = data.join(' ');\n    } else if (typeof data === 'object') {\n      // List keys of object as a string if the value is truthy.\n      data = Object.entries(data).map(([key, value]) => key + ':' + value).join(';');\n    }\n  } // Update attribute on element.\n\n\n  if (data === false || data === null || data === undefined) {\n    element.removeAttribute(key);\n  } else {\n    element.setAttribute(key, data);\n  }\n};\n/**\n * Set attributes on an element based of an object.\n * @param {HTMLElement} element Element to add the attributes to.\n * @param {Object} data Attribute data to set.\n */\n\nexport const setAttributes = (element, data) => {\n  for (const name in data) {\n    setAttribute(element, name, data[name]);\n  }\n};\nexport default {\n  addAttributes: addAttributes,\n  copyAttributes: copyAttributes,\n  removeAttributes: removeAttributes,\n  setAttribute: setAttribute\n};", "/**\n * Convert string to HTML element.\n * @param {String} string Element contents.\n * @returns {HTMLElement} HTML element part of a document fragment.\n */\nexport const fromString = string => {\n  const template = document.createElement('template');\n  template.innerHTML = string;\n  return template.content.childNodes[0];\n};\n/**\n * Inserts an element after the reference element opposite of insertBefore and more reliable then ChildNode.after()\n * @param {HTMLElement} reference Node to insert after.\n * @param {Node} node Node to insert.\n */\n\nexport const insertAfter = (reference, node) => {\n  if (reference.nextSibling) {\n    reference.parentNode.insertBefore(node, reference.nextSibling);\n  } else {\n    reference.parentNode.appendChild(node);\n  }\n};\n/**\n * Check whether two nodes are the same.\n * @param {HTMElement} a A node.\n * @param {HTMElement} b Another node.\n * @returns {Boolean} Whether the nodes are the same.\n */\n\nexport const isSame = (a, b) => {\n  if (a.isSameNode) {\n    return a.isSameNode(b);\n  }\n\n  if (a.tagName !== b.tagName) {\n    return false;\n  }\n\n  if (a.type === 3) {\n    // Text node.\n    return a.nodeValue === b.nodeValue;\n  }\n\n  return false;\n};\n/**\n * Iterate over all descendants of a given node.\n * @param {HTMLElement} element Element to walk over.\n * @param {Function} filter Filter function, return false to skip element.\n * @returns {Function} Iterator function. Call until a non-truthy value is returned.\n */\n\nexport const walk = (element, filter) => {\n  let index = -1;\n  let iterator = null;\n  return () => {\n    // First go over iterator.\n    if (index >= 0 && iterator) {\n      const child = iterator();\n\n      if (child) {\n        return child;\n      }\n    } // Get next child that passes the filter.\n\n\n    let child = null;\n\n    do {\n      index++;\n\n      if (index >= element.childElementCount) {\n        return null;\n      }\n\n      child = element.children[index];\n    } while (!filter(child)); // Setup iterator for child.\n\n\n    if (child.childElementCount) {\n      iterator = walk(child, filter);\n    } // Return the child.\n\n\n    return child;\n  };\n};\nexport default {\n  fromString: fromString,\n  insertAfter: insertAfter,\n  isSame: isSame,\n  walk: walk\n};", "// Based on choo's nanomorph, v5.4.3, https://github.com/choojs/nanomorph#readme).\n// Import utils.\nimport { copyAttributes } from './AttributeUtils.js';\nimport { fromString as ElementFromString, isSame as ElementIsSame } from './ElementUtils.js';\n/**\n * Diff elements and apply the resulting patch to the existing node.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n*/\n\nexport const morphNode = (existingNode, newNode) => {\n  const nodeType = newNode.nodeType;\n  const nodeName = newNode.nodeName; // Element node.\n\n  if (nodeType === 1) {\n    copyAttributes(existingNode, newNode);\n  } // Text node or comment node.\n\n\n  if (nodeType === 3 || nodeType === 8) {\n    if (existingNode.nodeValue !== newNode.nodeValue) {\n      existingNode.nodeValue = newNode.nodeValue;\n    }\n  } // Some DOM nodes are weird\n  // https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n\n\n  if (nodeName === 'INPUT') {\n    updateInput(existingNode, newNode);\n  } else if (nodeName === 'OPTION') {\n    updateAttribute(existingNode, newNode, 'selected');\n  } else if (nodeName === 'TEXTAREA') {\n    updateTextarea(existingNode, newNode);\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @param {Object} options Options to modify the morphing behaviour.\n * @returns {HTMLElement} New tree root element.\n */\n\nexport const morphTree = (existingTree, newTree, options) => {\n  if (typeof existingTree !== 'object') {\n    throw new Error('Existing tree should be an object.');\n  }\n\n  if (typeof newTree === 'string') {\n    newTree = ElementFromString(newTree);\n  } else if (typeof newTree !== 'object') {\n    throw new Error('New tree should be an object.');\n  } // Check if outer or inner html should be updated. Always update children if root node is a document fragment.\n\n\n  if (options && options.childrenOnly || newTree.nodeType === 11) {\n    updateChildren(existingTree, newTree);\n    return existingTree;\n  }\n\n  return updateTree(existingTree, newTree);\n};\n/**\n * Update attributes on input element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\nconst updateInput = (existingNode, newNode) => {\n  // The \"value\" attribute is special for the <input> element since it sets the\n  // initial value. Changing the \"value\" attribute without changing the \"value\"\n  // property will have no effect since it is only used to the set the initial\n  // value. Similar for the \"checked\" attribute, and \"disabled\".\n  const newValue = newNode.value;\n  const existingValue = existingNode.value;\n  updateAttribute(existingNode, newNode, 'checked');\n  updateAttribute(existingNode, newNode, 'disabled'); // The \"indeterminate\" property can not be set using an HTML attribute.\n  // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox\n\n  if (existingNode.indeterminate !== newNode.indeterminate) {\n    existingNode.indeterminate = newNode.indeterminate;\n  } // Persist file value since file inputs can't be changed programmatically\n\n\n  if (existingNode.type === 'file') {\n    return;\n  }\n\n  if (existingValue !== newValue) {\n    existingNode.setAttribute('value', newValue);\n    existingNode.value = newValue;\n  }\n\n  if (newValue === 'null') {\n    existingNode.value = '';\n    existingNode.removeAttribute('value');\n  }\n\n  if (!newNode.hasAttributeNS(null, 'value')) {\n    existingNode.removeAttribute('value');\n  } else if (existingNode.type === 'range') {\n    // this is so elements like slider move their UI thingy\n    existingNode.value = newValue;\n  }\n};\n/**\n * Update attributes on textarea element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateTextarea = (existingNode, newNode) => {\n  const newValue = newNode.value;\n\n  if (existingNode.value !== newValue) {\n    existingNode.value = newValue;\n  }\n\n  if (existingNode.firstChild && existingNode.firstChild.nodeValue !== newValue) {\n    // Needed for IE. Apparently IE sets the placeholder as the\n    // node value and visa versa. This ignores an empty update.\n    if (existingNode.firstChild.nodeValue === existingNode.placeholder && newValue === '') {\n      return;\n    }\n\n    existingNode.firstChild.nodeValue = newValue;\n  }\n};\n/**\n * Update attributes on element.\n * @param {HTMLElement} existingNode Existing node to update.\n * @param {HTMLElement} newNode Element to update existing node with.\n */\n\n\nconst updateAttribute = (existingNode, newNode, name) => {\n  if (existingNode[name] !== newNode[name]) {\n    existingNode[name] = newNode[name];\n\n    if (newNode[name]) {\n      existingNode.setAttribute(name, '');\n    } else {\n      existingNode.removeAttribute(name);\n    }\n  }\n};\n/**\n * Morph the existing element tree into the given tree.\n * @param {HTMLElement} existingTree The existing tree to convert.\n * @param {HTMLElement} newTree The tree to change to.\n * @returns {HTMLElement} New tree root element.\n */\n\n\nconst updateTree = (existingTree, newTree) => {\n  if (!existingTree) {\n    return newTree;\n  }\n\n  if (!newTree) {\n    return null;\n  }\n\n  if (existingTree.isSameNode && existingTree.isSameNode(newTree)) {\n    return existingTree;\n  }\n\n  if (existingTree.tagName !== newTree.tagName) {\n    return newTree;\n  }\n\n  morphNode(existingTree, newTree);\n  updateChildren(existingTree, newTree);\n  return existingTree;\n};\n/**\n * Change the existing element's children into the given element's children.\n * @param {HTMLElement} existingNode The existing node who's children to update.\n * @param {HTMLElement} newNode The existing node who's children to change to.\n */\n\n\nconst updateChildren = (existingNode, newNode) => {\n  let existingChild, newChild, morphed, existingMatch; // The offset is only ever increased, and used for [i - offset] in the loop\n\n  let offset = 0;\n\n  for (let i = 0;; i++) {\n    existingChild = existingNode.childNodes[i];\n    newChild = newNode.childNodes[i - offset]; // Both nodes are empty, do nothing\n\n    if (!existingChild && !newChild) {\n      break; // There is no new child, remove old\n    } else if (!newChild) {\n      existingNode.removeChild(existingChild);\n      i--; // There is no old child, add new\n    } else if (!existingChild) {\n      existingNode.appendChild(newChild);\n      offset++; // Both nodes are the same, morph\n    } else if (ElementIsSame(existingChild, newChild)) {\n      morphed = updateTree(existingChild, newChild);\n\n      if (morphed !== existingChild) {\n        existingNode.replaceChild(morphed, existingChild);\n        offset++;\n      } // Both nodes do not share an ID or a placeholder, try reorder\n\n    } else {\n      existingMatch = null; // Try and find a similar node somewhere in the tree\n\n      for (let j = i; j < existingNode.childNodes.length; j++) {\n        if (ElementIsSame(existingNode.childNodes[j], newChild)) {\n          existingMatch = existingNode.childNodes[j];\n          break;\n        }\n      } // If there was a node with the same ID or placeholder in the old list\n\n\n      if (existingMatch) {\n        morphed = updateTree(existingMatch, newChild);\n        if (morphed !== existingMatch) offset++;\n        existingNode.insertBefore(morphed, existingChild); // It's safe to morph two nodes in-place if neither has an ID\n      } else if (!newChild.id && !existingChild.id) {\n        morphed = updateTree(existingChild, newChild);\n\n        if (morphed !== existingChild) {\n          existingNode.replaceChild(morphed, existingChild);\n          offset++;\n        } // Insert the node at the index if we couldn't morph or find a matching node\n\n      } else {\n        existingNode.insertBefore(newChild, existingChild);\n        offset++;\n      }\n    }\n  }\n};\n\nexport default {\n  morphNode: morphNode,\n  morphTree: morphTree\n};", "// Import symbols.\nimport { COMPONENT } from '../symbols.js';\n/**\n * Get closest component in hierarchy.\n * @param {HTMLElement} element Element to start searching from.\n * @returns {Component} Closest component.\n */\n\nexport const closestComponent = element => {\n  if (!element.parentElement) {\n    return;\n  }\n\n  element = element.parentElement;\n\n  if (element[COMPONENT]) {\n    return element[COMPONENT];\n  }\n\n  return closestComponent(element);\n};\nexport default {\n  closestComponent: closestComponent\n};", "// Import polyfill.\nimport RevocableProxy from '../polyfills/RevocableProxy.js';\n/**\n * Create an object with utility function.\n * @returns {Object} Utils.\n */\n\nconst createContextUtils = () => {\n  return {\n    createContexts: createContexts,\n    createContextsProxy: createContextsProxy,\n    RevocableProxy: RevocableProxy\n  };\n};\n/**\n * Create component's contexts for an attributes expression.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {Function} update Called when update needs to be invoked.\n * @param {Object} extra Optional extra context items.\n * @returns {Array<Object, Function>} Expressions contexts and destroy functions.\n */\n\n\nexport const createContexts = (component, attribute, update, extra = null) => {\n  // Iterate over all contexts.\n  const results = {};\n  const destroyFunctions = [];\n  let after = '';\n  let before = '';\n  const contexts = component.getLibrary().getContexts();\n\n  for (const context of contexts) {\n    if (!context || !context.name) {\n      continue;\n    } // Get context result.\n\n\n    const result = context.create(component, attribute, update, createContextUtils());\n\n    if (!result || !result.value) {\n      continue;\n    } // Store destroy functions.\n\n\n    if (result.destroy && typeof result.destroy === 'function') {\n      destroyFunctions.push(result.destroy);\n    } // Deconstruct options if marked as such.\n\n\n    if (context.deconstruct && typeof result.value === 'object') {\n      before += 'with(' + context.name + ') { ';\n      after += ' }';\n    } // Store result value in context results.\n\n\n    results[context.name] = result.value;\n  } // Add extra items to context.\n\n\n  if (typeof extra === 'object') {\n    for (const name in extra) {\n      results[name] = extra[name];\n    }\n  }\n\n  return {\n    after: after,\n    before: before,\n    destroy: () => {\n      // Call all destroy functions.\n      for (const destroyFunction of destroyFunctions) {\n        destroyFunction(createContextUtils());\n      }\n    },\n    contexts: results\n  };\n};\n/**\n * Create component's contexts only after the context gets used.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {Object} extra Optional extra context items.\n * @param {Function} update Called when update needs to be invoked.\n * @returns {Proxy} Expressions contexts' proxy.\n */\n\nexport const createContextsProxy = (component, attribute, update, extra = null) => {\n  // Store context after first call.\n  let data = null; // Create context proxy.\n\n  const revocable = RevocableProxy({}, {\n    get: (target, property) => {\n      // Create context.\n      if (!data) {\n        data = createContexts(component, attribute, update, extra);\n      } // Check if name exists in context.\n\n\n      if (property in data.contexts) {\n        // Call accessed callback if element or state is accessed.\n        attribute.accessed(component.getId(), property); // Return value.\n\n        return data.contexts[property];\n      } // Try and get value from state.\n\n\n      if (data.contexts.$state) {\n        if (property in data.contexts.$state) {\n          // Call accessed callback if element or state is accessed.\n          attribute.accessed(component.getId(), '$state'); // Return value.\n\n          return data.contexts.$state[property];\n        }\n      }\n    }\n  }); // Return context.\n\n  return {\n    contexts: revocable.proxy,\n    destroy: () => {\n      // Call destroy on created context.\n      if (data && data.destroy) {\n        data.destroy(component, attribute);\n      } // Revoke proxy.\n\n\n      revocable.revoke();\n    }\n  };\n};\n/**\n * Executes value in the correct context.\n * @param {Component} component Instance of the component.\n * @param {Attribute} attribute Instance of the attribute.\n * @param {String} expression Expression to execute.\n * @param {Object} extra Optional extra context items.\n * @param {Object} options Optional options object.\n * @returns {Any} Result of expression.\n */\n\nexport const executeExpression = (component, attribute, expression, extra = null, options = null) => {\n  // Override default with given options.\n  options = Object.assign({\n    return: true\n  }, options); // Collect update triggers.\n\n  const triggers = [];\n\n  const update = (id, context) => {\n    triggers.push({\n      id: id,\n      path: context\n    });\n  }; // Create function context.\n\n\n  let {\n    after,\n    before,\n    contexts,\n    destroy\n  } = createContexts(component, attribute, update, extra); // Apply options.\n\n  if (options.return) {\n    before += 'return ';\n  } // Try to execute code.\n\n\n  let result;\n\n  try {\n    result = new Function(...Object.keys(contexts), before + expression + after)(...Object.values(contexts)); // eslint-disable-line no-new-func\n  } catch (error) {\n    console.error(error, 'Error encountered when executing the following expression: ', expression);\n    result = null;\n  } // Invoke destroy.\n\n\n  destroy(); // Dispatch update triggers.\n\n  if (triggers.length > 0) {\n    component.getLibrary().update(triggers);\n  }\n\n  return result;\n};\nexport default {\n  createContexts: createContexts,\n  createContextsProxy: createContextsProxy,\n  executeExpression: executeExpression\n};", "// Import utils.\nimport { parseSelector } from './StringUtils.js';\nimport { addAttributes, removeAttributes } from './AttributeUtils.js'; // Transition name.\n\nconst TRANSITION_NAME = '-transition:';\n/**\n * Transition an element.\n * @param {String} type Type of transition, for example 'in' and 'out'.\n * @param {Component} component Component the transitioning element is part of.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n */\n\nexport const transition = (type, component, element, callback = null) => {\n  // Only transition element nodes.\n  if (element.nodeType !== 1) {\n    if (callback) {\n      callback();\n    }\n\n    return;\n  } // Get library options.\n\n\n  const {\n    prefix\n  } = component.getLibrary().getOptions(); // Transition attribute name.\n\n  const transitionName = prefix + TRANSITION_NAME + type; // Setup dispatcher function.\n\n  const dispatchEvent = phase => {\n    element.dispatchEvent(new CustomEvent('transition-' + phase));\n    element.dispatchEvent(new CustomEvent('transition-' + type + '-' + phase));\n  }; // Declare variables for later.\n\n\n  let name, value, timeout, requestFrame;\n  let isDone = false;\n  const selectors = {}; // Process transition during attribute.\n\n  name = transitionName;\n  value = element.getAttribute(name); // Parse and apply returned selector.\n\n  if (value) {\n    selectors.during = parseSelector(value);\n    addAttributes(element, selectors.during);\n  } // Process transition from attribute.\n\n\n  name = transitionName + '.from';\n  value = element.getAttribute(name); // Parse and apply returned selector.\n\n  if (value) {\n    selectors.from = parseSelector(value);\n    addAttributes(element, selectors.from);\n  } // Dispatch transition event.\n\n\n  dispatchEvent('start');\n  requestFrame = requestAnimationFrame(() => {\n    requestFrame = null; // If cancelled then stop immediately.\n\n    if (isDone) {\n      return;\n    } // Remove from selector.\n\n\n    if (selectors.from) {\n      removeAttributes(element, selectors.from);\n      selectors.from = undefined;\n    } // Process transition to attribute.\n\n\n    name = transitionName + '.to';\n    value = element.getAttribute(name); // Parse and apply returned selector.\n\n    if (value) {\n      selectors.to = parseSelector(value);\n      addAttributes(element, selectors.to);\n    } else if (!selectors.during) {\n      // Exit early if no active selectors set.\n      // Dispatch end event.\n      dispatchEvent('end'); // Invoke callback.\n\n      if (callback) {\n        callback();\n      } // Mark as done.\n\n\n      isDone = true;\n      return;\n    } // Get computes style.\n\n\n    const styles = getComputedStyle(element);\n    let duration = Number(styles.transitionDuration.replace(/,.*/, '').replace('s', '')) * 1000;\n\n    if (duration === 0) {\n      duration = Number(styles.animationDuration.replace('s', '')) * 1000;\n    }\n\n    timeout = setTimeout(() => {\n      timeout = null; // If cancelled then stop immediately.\n\n      if (isDone) {\n        return;\n      } // Remove during selector.\n\n\n      if (selectors.during) {\n        removeAttributes(element, selectors.during);\n        selectors.during = undefined;\n      } // Remove to selector.\n\n\n      if (selectors.to) {\n        removeAttributes(element, selectors.to);\n        selectors.to = undefined;\n      } // Dispatch end event.\n\n\n      dispatchEvent('end'); // Invoke callback.\n\n      if (callback) {\n        callback();\n      } // Mark as done.\n\n\n      isDone = true;\n    }, duration);\n  });\n  return () => {\n    if (!isDone) {\n      return;\n    }\n\n    isDone = true; // Remove applied selector.\n\n    if (selectors.during) {\n      removeAttributes(element, selectors.during);\n      selectors.during = undefined;\n    }\n\n    if (selectors.from) {\n      removeAttributes(element, selectors.from);\n      selectors.from = undefined;\n    } else if (selectors.to) {\n      removeAttributes(element, selectors.to);\n      selectors.to = undefined;\n    } // Clear request animation frame and timeout.\n\n\n    if (requestFrame) {\n      cancelAnimationFrame(requestFrame);\n      requestFrame = null;\n    } else if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    } // Dispatch end event.\n\n\n    dispatchEvent('end'); // Invoke callback.\n\n    if (callback) {\n      callback();\n    }\n  };\n};\n/**\n * Transition an element in.\n * @param {Component} component Component the transitioning element is part of.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n */\n\nexport const transitionIn = (component, element, callback) => {\n  return transition('in', component, element, callback);\n};\n/**\n * Transition an element out.\n * @param {Component} component Component the transitioning element is part of.\n * @param {HTMLElement} element Element to transition.\n * @param {Function} callback Function to call after transition is done.\n */\n\nexport const transitionOut = (component, element, callback) => {\n  return transition('out', component, element, callback);\n};\nexport default {\n  transition: transition,\n  transitionIn: transitionIn,\n  transitionOut: transitionOut\n};", "// Import symbols.\nimport { COMPONENT } from './symbols.js'; // Import classes.\n\nimport Attribute from './Attribute.js'; // Import proxy dispatcher.\n\nimport ProxyDispatcher from './events/ProxyDispatcher.js'; // Import utils.\n\nimport { morphNode, morphTree } from './utils/MorphUtils.js';\nimport { closestComponent } from './utils/ComponentUtils.js';\nimport { executeExpression } from './utils/ExpressionUtils.js';\nimport { transition, transitionIn, transitionOut } from './utils/TransitionUtils.js';\nimport { walk } from './utils/ElementUtils.js'; // Create an object with utility function.\n\nconst DIRECTIVE_UTILS = Object.freeze({\n  executeExpression: executeExpression,\n  morphNode: morphNode,\n  morphTree: morphTree,\n  transition: transition,\n  transitionIn: transitionIn,\n  transitionOut: transitionOut\n});\nexport default class Component {\n  /**\n   * Create instance.\n   * @param {Doars} library Library instance.\n   * @param {HTMLElement} element Element.\n   */\n  constructor(library, element) {\n    // Create unique ID.\n    const id = Symbol('ID_COMPONENT'); // Deconstruct library options.\n\n    const {\n      prefix\n    } = library.getOptions(); // create private variables.\n\n    let attributes = [],\n        hasUpdated = false,\n        isInitialized = false,\n        data,\n        proxy,\n        state; // Check if element has a state attribute.\n\n    if (!element.attributes[prefix + '-state']) {\n      console.error('Doars: element given to component does not contain a state attribute!');\n      return;\n    } // Add reference to element.\n\n\n    element[COMPONENT] = this; // Update position in hierarchy.\n\n    const children = []; // Get current parent component.\n\n    let parent = closestComponent(element);\n\n    if (parent) {\n      // Add to list of children in parent.\n      if (!parent.getChildren().includes(this)) {\n        parent.getChildren().push(this); // Trigger children update.\n\n        library.update([{\n          id: parent.getId(),\n          path: 'children'\n        }]);\n      }\n    }\n    /**\n     * Get the attributes in this component.\n     * @returns {Array<Attribute>} List of attributes.\n     */\n\n\n    this.getAttributes = () => {\n      return attributes;\n    };\n    /**\n     * Get child components in hierarchy of this component.\n     * @returns {Array<Component>} List of components.\n     */\n\n\n    this.getChildren = () => {\n      return children;\n    };\n    /**\n     * Get root element of the component.\n     * @returns {HTMLElement} Element.\n     */\n\n\n    this.getElement = () => {\n      return element;\n    };\n    /**\n     * Get component id.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get the library instance this component is from.\n     * @returns {Doars} Doars instance.\n     */\n\n\n    this.getLibrary = () => {\n      return library;\n    };\n    /**\n     * Get parent component in hierarchy of this component.\n     * @returns {Component} Component.\n     */\n\n\n    this.getParent = () => {\n      return parent;\n    };\n    /**\n     * Get the event dispatcher of state's proxy.\n     * @returns {ProxyDispatcher} State's proxy dispatcher.\n     */\n\n\n    this.getProxy = () => {\n      return proxy;\n    };\n    /**\n     * Get the component's state.\n     * @returns {Proxy} State.\n     */\n\n\n    this.getState = () => {\n      return state;\n    };\n    /**\n     * Set new parent component of this component.\n     * @param {Component} _parent Parent component.\n     */\n\n\n    this.setParent = _parent => {\n      parent = _parent;\n    };\n    /**\n     * Initialize the component.\n     */\n\n\n    this.initialize = () => {\n      if (isInitialized) {\n        return;\n      } // Set as enabled.\n\n\n      isInitialized = true; // Get component's state attribute.\n\n      const componentName = prefix + '-state';\n      const value = element.attributes[componentName].value; // Execute expression for generating the state using a mock attribute.\n\n      data = executeExpression(this, new Attribute(this, element, null, value), value) ?? {};\n\n      if (Array.isArray(data) || typeof data !== 'object') {\n        console.error('Doars: component tag must return an object!');\n        return;\n      } // Create proxy dispatcher for state.\n\n\n      proxy = new ProxyDispatcher(); // Add data to dispatcher to create the state.\n\n      state = proxy.add(data); // Scan for attributes.\n\n      this.scanAttributes(element);\n    };\n    /**\n     * Destroy the component.\n     */\n\n\n    this.destroy = () => {\n      if (!isInitialized) {\n        return;\n      }\n\n      if (attributes.length > 0) {\n        // Filter out directives without a destroy function.\n        const directives = library.getDirectivesObject();\n\n        for (const key in directives) {\n          if (!directives[key].destroy) {\n            directives[key] = undefined;\n          }\n        }\n\n        for (const attribute of attributes) {\n          // Clean up attribute if the directive has a destroy function.\n          const directive = directives[attribute.getKey()];\n\n          if (directive) {\n            directive.destroy(this, attribute, DIRECTIVE_UTILS);\n          } // Destroy the attribute.\n\n\n          attribute.destroy();\n        }\n      } // Remove reference from element.\n\n\n      delete element[COMPONENT]; // Reset variables.\n\n      attributes = []; // Set as not initialized.\n\n      isInitialized = false; // Remove state and state handling.\n\n      proxy.remove(data);\n      state = null;\n      proxy = null;\n      data = null; // Store update triggers.\n\n      const triggers = []; // Set children as children of parent.\n\n      if (children.length > 0) {\n        for (const child of children) {\n          // Set new parent of children.\n          child.setParent(parent); // Add parent update trigger.\n\n          triggers.push({\n            id: child.getId(),\n            path: 'parent'\n          });\n        } // Add children update trigger.\n\n\n        triggers.push({\n          id: id,\n          path: 'children'\n        });\n      }\n\n      if (parent) {\n        if (children.length > 0) {\n          // Add children to parent.\n          parent.getChildren().push(...children); // Add children update trigger.\n\n          triggers.push({\n            id: parent.getId(),\n            path: 'children'\n          });\n        } // Add parent update trigger.\n\n\n        triggers.push({\n          id: id,\n          path: 'parent'\n        });\n      } // Dispatch triggers.\n\n\n      if (triggers.length > 0) {\n        library.update(triggers);\n      } // Dispatch event.\n\n\n      dispatchEvent('destroyed', {\n        element: element,\n        id: id\n      });\n    };\n    /**\n     * Create and add an attribute. Assumes this attribute has not been added before.\n     * @param {HTMLElement} element Attribute element.\n     * @param {String} name Name of the attribute.\n     * @param {String} value Value of the attribute.\n     * @returns {Attribute} New attribute.\n     */\n\n\n    this.addAttribute = (element, name, value) => {\n      // Get directive keys from library.\n      const directivesKeys = library.getDirectivesNames(); // Create and add attribute.\n\n      const attribute = new Attribute(this, element, name, value); // Get index to add attribute at.\n\n      let index = attribute.length;\n      const directiveIndex = directivesKeys.indexOf(attribute.getDirective());\n\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        // If the other attribute is further down the keys list than add it after that item.\n        if (directivesKeys.indexOf(attributes[i].getDirective()) <= directiveIndex) {\n          index = i + 1;\n          break;\n        }\n      } // Add to list of attributes.\n\n\n      attributes.splice(index, 0, attribute); // Return new attribute.\n\n      return attribute;\n    };\n    /**\n     * Remove an attribute.\n     * @param {Attribute} attribute The attribute to remove.\n     */\n\n\n    this.removeAttribute = attribute => {\n      // Get index of attribute in list.\n      const indexInAttributes = attributes.indexOf(attribute);\n\n      if (indexInAttributes < 0) {\n        return;\n      } // Get directives.\n\n\n      const directives = library.getDirectivesObject; // Attribute has been removed, call the destroy directive.\n\n      const directive = directives[attribute.getKey()];\n\n      if (directive && directive.destroy) {\n        directive.destroy(this, attribute, DIRECTIVE_UTILS);\n      } // Remove attribute from list.\n\n\n      attributes.splice(indexInAttributes, 1); // Destroy attribute.\n\n      attribute.destroy();\n    };\n    /**\n     * Scans element for new attributes. It assumes this element as not been read before and is part of the component.\n     * @param {HTMLElement} element Element to scan.\n     * @returns {Array<Attribute>} New attributes.\n     */\n\n\n    this.scanAttributes = element => {\n      // Get component's state attribute.\n      const componentName = prefix + '-state';\n      const ignoreName = prefix + '-ignore'; // Store new attributes.\n\n      const newAttributes = []; // Create iterator for walking over all elements in the component, skipping elements that are components or contain the ignore directive.\n\n      const iterator = walk(element, element => !element.hasAttribute(componentName) && !element.hasAttribute(ignoreName)); // Start on the given element then continue iterating over all children.\n\n      do {\n        for (const {\n          name,\n          value\n        } of element.attributes) {\n          // Skip attribute if it is not that of a directive.\n          if (library.isDirectiveName(name)) {\n            newAttributes.push(this.addAttribute(element, name, value));\n          }\n        }\n      } while (element = iterator()); // Return new attributes.\n\n\n      return newAttributes;\n    };\n    /**\n     * Update an attribute.\n     * @param {Attribute} attribute The attribute to update.\n     */\n\n\n    this.updateAttribute = attribute => {\n      // Check if the attribute is still relevant, since the attribute or element could have been removed.\n      if (!attribute.getElement() || attribute.getValue() === null || attribute.getValue() === undefined) {\n        this.removeAttribute(attribute);\n        return;\n      } // Get directives.\n\n\n      const directives = library.getDirectivesObject(); // Clear accessed.\n\n      attribute.clearAccessed(); // Execute directive on attribute.\n\n      const directive = directives[attribute.getDirective()];\n\n      if (directive) {\n        directive.update(this, attribute, DIRECTIVE_UTILS);\n      }\n    };\n    /**\n     * Update the specified attributes of the component.\n     * @param {Array<Attribute>} attributes Attributes to update.\n     */\n\n\n    this.updateAttributes = attributes => {\n      if (!isInitialized || attributes.length <= 0) {\n        if (!hasUpdated) {\n          // Dispatch updated event anyway.\n          hasUpdated = true;\n          dispatchEvent('updated', {\n            attributes: attributes,\n            element: element,\n            id: id\n          });\n        }\n\n        return;\n      }\n\n      for (const attribute of attributes) {\n        this.updateAttribute(attribute);\n      } // Dispatch updated event.\n\n\n      hasUpdated = true;\n      dispatchEvent('updated', {\n        attributes: attributes,\n        element: element,\n        id: id\n      });\n    };\n    /**\n     * Start updating the component's attributes.\n     * @param {Array<Object>} triggers List of triggers.\n     */\n\n\n    this.update = triggers => {\n      if (!isInitialized) {\n        return;\n      } // Get all ids of triggers.\n\n\n      const triggerIds = Object.getOwnPropertySymbols(triggers); // Update all attributes whose accessed items match any update trigger.\n\n      const updatedAttributes = [];\n\n      for (const attribute of attributes) {\n        for (const id of triggerIds) {\n          if (attribute.hasAccessed(id, triggers[id])) {\n            this.updateAttribute(attribute);\n            updatedAttributes.push(attribute);\n          }\n        }\n      } // Dispatch updated event.\n\n\n      if (!hasUpdated || updatedAttributes.length > 0) {\n        hasUpdated = true;\n        dispatchEvent('updated', {\n          attributes: updatedAttributes,\n          element: element,\n          id: id\n        });\n      }\n    };\n    /**\n     * Dispatch an event from this component.\n     * @param {String} name Name of the event.\n     */\n\n\n    const dispatchEvent = (name, detail) => {\n      element.dispatchEvent(new CustomEvent(prefix + '-' + name, {\n        detail: detail,\n        bubbles: true\n      }));\n    };\n  }\n\n}", "export default {\n  name: '$children',\n  create: (component, attribute, update, {\n    createContextsProxy,\n    RevocableProxy\n  }) => {\n    // Create contexts proxy for children.\n    let children;\n    const revocable = RevocableProxy(component.getChildren(), {\n      get: (target, key, receiver) => {\n        if (!children) {\n          // Create list of child contexts.\n          children = target.map(child => createContextsProxy(child, attribute, update)); // Set children of this component as accessed.\n\n          attribute.accessed(component.getId(), 'children');\n        } // If not a number then do a normal access.\n\n\n        if (isNaN(key)) {\n          return Reflect.get(children, key, receiver);\n        } // Return context from child.\n\n\n        const child = Reflect.get(children, key, receiver);\n\n        if (child) {\n          return child.contexts;\n        }\n      }\n    });\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        // Call destroy on all created contexts.\n        if (children) {\n          children.forEach(child => child.destroy());\n        } // Revoke proxy.\n\n\n        revocable.revoke();\n      }\n    };\n  }\n};", "export default {\n  name: '$component',\n  create: component => {\n    // Return the component's element.\n    return {\n      value: component.getElement()\n    };\n  }\n};", "export default {\n  name: '$element',\n  create: (component, attribute) => {\n    // Return the attribute's element.\n    return {\n      value: attribute.getElement()\n    };\n  }\n};", "export default {\n  name: '$dispatch',\n  create: component => {\n    // Return the dispatch method.\n    return {\n      value: (name, detail = {}) => {\n        // Dispatch the event after the elements have updated.\n        component.getElement().dispatchEvent(new CustomEvent(name, {\n          detail: detail,\n          bubbles: true\n        }));\n      }\n    };\n  }\n};", "// Import symbols.\nimport { FOR } from '../symbols.js';\nexport default {\n  deconstruct: true,\n  name: '$for',\n  create: (component, attribute, update, {\n    RevocableProxy\n  }) => {\n    // Exit early in parent contexts.\n    if (component !== attribute.getComponent()) {\n      return;\n    } // Deconstruct attribute.\n\n\n    let element = attribute.getElement(); // Walk up the tree until the component's root element is found.\n\n    const componentElement = component.getElement(),\n          items = [],\n          target = {};\n\n    while (element && !element.isSameNode(componentElement)) {\n      // Check if element has for symbol.\n      const data = element[FOR];\n\n      if (data) {\n        items.push(data);\n\n        for (const key in data.variables) {\n          target[key] = data.variables[key];\n        }\n      } // Go up the document tree.\n\n\n      element = element.parentNode;\n    }\n\n    if (items.length === 0) {\n      return;\n    } // Create revocable proxy.\n\n\n    const revocable = RevocableProxy(target, {\n      get: (target, key) => {\n        for (const item of items) {\n          if (key in item.variables) {\n            // Mark as accessed for data.\n            attribute.accessed(item.id, '$for'); // Return value at key.\n\n            return item.variables[key];\n          }\n        }\n      }\n    }); // Set keys and return values.\n\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        revocable.revoke();\n      }\n    };\n  }\n};", "export default {\n  name: '$inContext',\n  create: (component, attribute, update, {\n    createContexts\n  }) => {\n    return {\n      value: callback => {\n        // Collect update triggers.\n        const triggers = [];\n\n        const contextUpdate = (id, context) => {\n          triggers.push({\n            id: id,\n            path: context\n          });\n        }; // Create contexts.\n\n\n        const {\n          contexts,\n          destroy\n        } = createContexts(component, attribute, contextUpdate, {}); // Invoke callback and store its result.\n\n        const result = callback(contexts); // Destroy contexts.\n\n        destroy(); // Dispatch update triggers.\n\n        if (triggers.length > 0) {\n          component.getLibrary().update(triggers);\n        } // Return callback's result.\n\n\n        return result;\n      }\n    };\n  }\n};", "export default {\n  name: '$nextTick',\n  create: (component, attribute, update, {\n    createContexts\n  }) => {\n    // Keep track of callbacks.\n    let callbacks; // The setup process is delayed since we only want this code to run if the context is used.\n\n    let isSetup = false;\n\n    const setup = () => {\n      // Exit early if already setup.\n      if (isSetup) {\n        return;\n      }\n\n      isSetup = true; // Deconstruct component.\n\n      const library = component.getLibrary(); // Setup callbacks list.\n\n      callbacks = []; // Remove and invoke each callback in the list.\n\n      const handleUpdate = () => {\n        // Stop listening the update has happened.\n        stopListening(); // Create function context.\n\n        const {\n          contexts,\n          destroy\n        } = createContexts(component, attribute, update, {}); // Invoke all callbacks.\n\n        for (const callback of callbacks) {\n          callback(contexts);\n        } // Destroy contexts.\n\n\n        destroy();\n      }; // Stop listening for the update event and attribute changes.\n\n\n      const stopListening = () => {\n        // Stop listening for updated event.\n        library.removeEventListener('updated', handleUpdate); // Remove self from listening.\n\n        attribute.removeEventListener('changed', stopListening);\n        attribute.removeEventListener('destroyed', stopListening);\n      }; // Listen to the libraries updated event.\n\n\n      library.addEventListener('updated', handleUpdate); // Stop listening if the attribute changes since this directive will be run again.\n\n      attribute.addEventListener('changed', stopListening);\n      attribute.addEventListener('destroyed', stopListening);\n    };\n\n    return {\n      value: callback => {\n        // Do delayed setup now.\n        setup(); // Add callback to list.\n\n        callbacks.push(callback);\n      }\n    };\n  }\n};", "export default {\n  name: '$parent',\n  create: (component, attribute, update, {\n    createContextsProxy\n  }) => {\n    // Deconstruct component.\n    const parent = component.getParent();\n\n    if (!parent) {\n      return {\n        key: '$parent',\n        value: null\n      };\n    } // Create contexts proxy for parent.\n\n\n    const {\n      contexts,\n      destroy\n    } = createContextsProxy(parent, attribute, update);\n    return {\n      value: contexts,\n      destroy: destroy\n    };\n  }\n};", "// Import symbols.\nimport { REFERENCES, REFERENCES_CACHE } from '../symbols.js';\nexport default {\n  name: '$references',\n  create: (component, attribute, update, {\n    RevocableProxy\n  }) => {\n    // Exit early if no references exist.\n    if (!component[REFERENCES]) {\n      return {\n        key: '$references',\n        value: []\n      };\n    } // Generate references cache.\n\n\n    let cache = component[REFERENCES_CACHE];\n\n    if (!cache) {\n      // Get references from component.\n      const references = component[REFERENCES];\n      const attributeIds = Object.getOwnPropertySymbols(references); // Convert references to a named object.\n\n      cache = {};\n\n      for (const id of attributeIds) {\n        const {\n          element,\n          name\n        } = references[id];\n        cache[name] = element;\n      }\n\n      component[REFERENCES_CACHE] = cache;\n    } // Create revocable proxy.\n\n\n    const revocable = RevocableProxy(cache, {\n      get: (target, propertyKey, receiver) => {\n        // Mark references as accessed.\n        attribute.accessed(component.getId(), '$references.' + propertyKey); // Return reference.\n\n        return Reflect.get(target, propertyKey, receiver);\n      }\n    }); // Return references proxy.\n\n    return {\n      value: revocable.proxy,\n      destroy: () => {\n        revocable.revoke();\n      }\n    };\n  }\n};", "export default {\n  deconstruct: true,\n  name: '$state',\n  create: (component, attribute, update, {\n    RevocableProxy\n  }) => {\n    // Deconstruct component.\n    const proxy = component.getProxy();\n    const state = component.getState();\n\n    if (!proxy || !state) {\n      return;\n    } // Create event handlers.\n\n\n    const onDelete = (target, path) => update(component.getId(), '$state.' + path.join('.'));\n\n    const onGet = (target, path) => attribute.accessed(component.getId(), '$state.' + path.join('.'));\n\n    const onSet = (target, path) => update(component.getId(), '$state.' + path.join('.')); // Add event listeners.\n\n\n    proxy.addEventListener('delete', onDelete);\n    proxy.addEventListener('get', onGet);\n    proxy.addEventListener('set', onSet); // Wrap in a revocable proxy.\n\n    const revocable = RevocableProxy(state, {});\n    return {\n      value: revocable.proxy,\n      // Remove event listeners.\n      destroy: () => {\n        proxy.removeEventListener('delete', onDelete);\n        proxy.removeEventListener('get', onGet);\n        proxy.removeEventListener('set', onSet); // Revoke access to state.\n\n        revocable.revoke();\n      }\n    };\n  }\n};", "// Create and cache native promise for comparison.\nconst nativePromise = Function.prototype.toString.call(Function\n/* A native object */\n).replace('Function', 'Promise') // Replace identifier.\n.replace(/\\(.*\\)/, '()'); // Remove possible FormalParameterList.\n\nexport const isNativePromise = value => {\n  return value && typeof value.constructor === 'function' && Function.prototype.toString.call(value.constructor).replace(/\\(.*\\)/, '()') === nativePromise;\n};\nexport const isPromise = value => {\n  return value && Object.prototype.toString.call(value) === '[object Promise]';\n};\nexport default {\n  isPromise: isPromise,\n  isNativePromise: isNativePromise\n};", "// Import utils.\nimport { setAttribute, setAttributes } from '../utils/AttributeUtils.js';\nimport { isPromise } from '../utils/PromiseUtils.js';\nimport { parseSelector } from '../utils/StringUtils.js';\nexport default {\n  name: 'attribute',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = value => {\n      if (modifiers.selector) {\n        if (typeof value !== 'string') {\n          console.error('Doars: Value returned to attribute directive must be a string if the selector modifier is set.');\n          return;\n        }\n\n        value = parseSelector(value);\n        setAttributes(element, value);\n        return;\n      } // Deconstruct attribute.\n\n\n      const key = attribute.getKeyRaw();\n\n      if (!key) {\n        // Set attributes on element.\n        if (typeof value === 'object' && !Array.isArray(value)) {\n          setAttributes(element, value);\n        } else {\n          console.error('Doars: Value returned to attribute directive of invalid type.');\n        }\n\n        return;\n      } // Set attribute on element at key.\n\n\n      setAttribute(element, key, value);\n    }; // Execute attribute value.\n\n\n    const result = executeExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "export default {\n  name: 'cloak',\n  update: function (component, attribute, {\n    transitionIn\n  }) {\n    // Deconstruct attribute.\n    const element = attribute.getElement(); // Remove attribute from element.\n\n    element.removeAttribute(component.getLibrary().getOptions().prefix + '-' + this.name); // Transition in.\n\n    transitionIn(component, element);\n  }\n};", "// Import symbols.\nimport { FOR } from '../symbols.js'; // Import utils.\n\nimport { insertAfter } from '../utils/ElementUtils.js';\nimport { isPromise } from '../utils/PromiseUtils.js';\nimport { parseForExpression } from '../utils/StringUtils.js';\nimport { transitionIn, transitionOut } from '../utils/TransitionUtils.js';\n/**\n * Add values add object by name in given order.\n * @param {Array<String>} names Names of values.\n * @param  {...Any} values Values to add to object.\n * @returns {Object} Resulting object with values at names.\n */\n\nconst createVariables = (names, ...values) => {\n  const variables = {};\n\n  for (let i = 0; i < values.length; i++) {\n    if (i >= names.length) {\n      break;\n    }\n\n    variables[names[i]] = values[i];\n  }\n\n  return variables;\n};\n/**\n * Finds the index of an element in list matching the value.\n * @param {HTMLElement} elements List of elements to search through.\n * @param {Any} value Value to compare to.\n * @param {Number} index The index to start searching after.\n */\n\n\nconst indexInSiblings = (elements, value, index = -1) => {\n  index++;\n\n  if (index >= elements.length) {\n    return -1;\n  }\n\n  if (elements[index][FOR].value === value) {\n    return index;\n  }\n\n  return indexInSiblings(elements, value, index);\n};\n/**\n * Adds item to document at right index.\n * @param {Component} component Component attribute is part of.\n * @param {Function} update Update trigger function.\n * @param {DocumentFragment} template Template of items.\n * @param {Array<HTMLElement>} elements Existing item elements.\n * @param {Number} index Index to start looking from.\n * @param {Any} value Value of item to add.\n * @param {Object} variables Variables associated with item.\n */\n\n\nconst setAfter = (component, update, template, elements, index, value, variables) => {\n  const existingIndex = indexInSiblings(elements, value, index);\n\n  if (existingIndex >= 0) {\n    // Exit early it is already in place.\n    if (existingIndex === index + 1) {\n      return;\n    } // Get existing element to move.\n\n\n    const element = elements[existingIndex]; // Move element after element at index or directly after the template.\n\n    insertAfter(elements[index] ?? template, element); // Update all attributes using this for item's data.\n\n    update(element[FOR].id);\n    return;\n  } // Create new element from template.\n\n\n  let element = document.importNode(template.content, true); // Add element after template or element at index.\n\n  const sibling = index === -1 ? template : elements[index];\n  insertAfter(sibling, element); // Get HTMLElement reference instead of DocumentFragment.\n\n  element = sibling.nextElementSibling; // Transition in.\n\n  transitionIn(component, element); // Store data.\n\n  element[FOR] = {\n    id: Symbol('ID_FOR'),\n    value: value,\n    variables: variables\n  }; // Store reference.\n\n  elements.splice(index + 1, 0, element);\n};\n/**\n * Removes elements after maximum length.\n * @param {Array<HTMLElement>} elements List of existing elements.\n * @param {Number} maxLength Maximum number of elements.\n */\n\n\nconst removeAfter = (component, elements, maxLength) => {\n  // Exit early if length is not exceeded.\n  if (elements.length < maxLength) {\n    return;\n  } // Iterate over exceeding elements.\n\n\n  for (let i = elements.length - 1; i >= maxLength; i--) {\n    // Remove element from list.\n    const element = elements[i];\n    elements.splice(i, 1); // Transition out.\n\n    transitionOut(component, element, () => {\n      element.remove();\n    });\n  }\n};\n\nexport default {\n  name: 'for',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct attribute.\n    const template = attribute.getElement(); // Check if placed on a template tag.\n\n    if (template.tagName !== 'TEMPLATE') {\n      console.warn('Doars: `for` directive must be placed on a `<template>` tag.');\n      return;\n    }\n\n    const expression = parseForExpression(attribute.getValue());\n\n    if (!expression) {\n      console.error('Doars: Error in `for` expression: ', attribute.getValue());\n      return;\n    } // Setup update method.\n\n\n    const triggers = {};\n\n    const update = id => {\n      if (!triggers[id]) {\n        triggers[id] = ['$for'];\n      }\n    };\n\n    const set = iterable => {\n      // Get stored data.\n      const data = attribute.getData(); // Get list of elements already made by this attribute.\n\n      const elements = data.elements ?? []; // Process iterable based on type.\n\n      const iterableType = typeof iterable;\n\n      if (iterableType === 'number') {\n        for (let index = 0; index < iterable; index++) {\n          // Setup variables for context.\n          const variables = createVariables(expression.variables, index); // Add element based on data after previously iterated value.\n\n          setAfter(component, update, template, elements, index - 1, iterable, variables);\n        } // Remove old values.\n\n\n        removeAfter(component, elements, iterable);\n      } else if (iterableType === 'string') {\n        for (let index = 0; index < iterable.length; index++) {\n          // Get value at index.\n          const value = iterable[index]; // Setup variables for context.\n\n          const variables = createVariables(expression.variables, value, index); // Add element based on data after previously iterated value.\n\n          setAfter(component, update, template, elements, index - 1, value, variables);\n        } // Remove old values.\n\n\n        removeAfter(component, elements, iterable.length);\n      } else {\n        // We can't rely on Array.isArray since it might be a proxy, therefore we try to convert it to an array.\n        let isArray, length;\n\n        try {\n          const values = [...iterable];\n          isArray = true;\n          length = values.length;\n        } catch {}\n\n        if (isArray) {\n          for (let index = 0; index < length; index++) {\n            // Get value at index.\n            const value = iterable[index]; // Setup variables for context.\n\n            const variables = createVariables(expression.variables, value, index); // Add element based on data after previously iterated value.\n\n            setAfter(component, update, template, elements, index - 1, value, variables);\n          }\n        } else {\n          const keys = Object.keys(iterable);\n          length = keys.length;\n\n          for (let index = 0; index < length; index++) {\n            // Get value at index.\n            const key = keys[index];\n            const value = iterable[key]; // Setup variables for context.\n\n            const variables = createVariables(expression.variables, key, value, index); // Add element based on data after previously iterated value.\n\n            setAfter(component, update, template, elements, index - 1, value, variables);\n          }\n        } // Remove old values.\n\n\n        removeAfter(component, elements, length);\n      } // Dispatch triggers.\n\n\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        component.update(triggers);\n      } // Store results.\n\n\n      attribute.setData(Object.assign({}, data, {\n        elements: elements\n      }));\n    }; // Get iterable value.\n\n\n    let result; // Check if iterable is a number.\n\n    if (!isNaN(expression.iterable)) {\n      result = Number(expression.iterable);\n    } else {\n      // Get iterable data, and this will automatically mark the data as being accessed by this component.\n      result = executeExpression(component, attribute, expression.iterable);\n    } // Get stored data.\n\n\n    const data = attribute.getData(); // Store results.\n\n    attribute.setData(Object.assign({}, data, {\n      result: result\n    })); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData().result !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  },\n  destroy: (component, attribute) => {\n    // Get stored data.\n    const data = attribute.getData(); // Get list of elements created by this attribute.\n\n    if (data.elements) {\n      // Iterate over generated elements.\n      for (const element of data.elements) {\n        // Transition out.\n        transitionOut(component, element, () => {\n          // Remove element.\n          element.remove();\n        });\n      }\n    }\n  }\n};", "const DECODE_LOOKUP = {\n  '&amp;': '&',\n  '&#38;': '&',\n  '&lt;': '<',\n  '&#60;': '<',\n  '&gt;': '>',\n  '&#62;': '>',\n  '&apos;': '\\'',\n  '&#39;': '\\'',\n  '&quot;': '\"',\n  '&#34;': '\"'\n};\nconst DECODE_REGEXP = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34);/g;\nconst ENCODE_LOOKUP = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\\'': '&#39;',\n  '\"': '&quot;'\n};\nconst ENCODE_REGEXP = /[&<>'\"]/g;\nexport const decode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(DECODE_REGEXP, character => {\n    return DECODE_LOOKUP[character];\n  });\n};\nexport const encode = string => {\n  if (typeof string !== 'string') {\n    return string;\n  }\n\n  return string.replaceAll(ENCODE_REGEXP, character => {\n    return ENCODE_LOOKUP[character];\n  });\n};\nexport default {\n  decode: decode,\n  encode: encode\n};", "// Import utils.\nimport { decode } from '../utils/HtmlUtils.js';\nimport { isPromise } from '../utils/PromiseUtils.js';\nexport default {\n  name: 'html',\n  update: (component, attribute, {\n    executeExpression,\n    morphTree\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = html => {\n      // Decode string.\n      if (modifiers.decode && typeof html === 'string') {\n        html = decode(html);\n      } // Morph if morph modifier is set.\n\n\n      if (modifiers.morph) {\n        // Ensure element only has one child.\n        if (element.children.length === 0) {\n          element.appendChild(document.createElement('div'));\n        } else if (element.children.length > 1) {\n          for (let i = element.children.length - 1; i >= 1; i--) {\n            element.children[i].remove();\n          }\n        } // Morph first child to given element tree.\n\n\n        const root = morphTree(element.children[0], html);\n\n        if (!element.children[0].isSameNode(root)) {\n          element.children[0].remove();\n          element.appendChild(root);\n        }\n\n        return;\n      } // Clone and set html as only child for HTMLElements.\n\n\n      if (html instanceof HTMLElement) {\n        for (const child of element.children) {\n          child.remove();\n        }\n\n        element.appendChild(html.cloneNode(true));\n        return;\n      } // Set html via inner html for strings.\n\n\n      if (typeof html === 'string') {\n        if (element.innerHTML !== html) {\n          element.innerHTML = html;\n        }\n\n        return;\n      }\n\n      console.error('Doars/directives/html: Unknown type returned to directive!');\n    }; // Execute value and retrieve result.\n\n\n    const result = executeExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "// Import utils.\nimport { insertAfter } from '../utils/ElementUtils.js';\nimport { isPromise } from '../utils/PromiseUtils.js';\nexport default {\n  name: 'if',\n  update: (component, attribute, {\n    executeExpression,\n    transitionIn,\n    transitionOut\n  }) => {\n    // Deconstruct attribute.\n    const template = attribute.getElement(); // Check if placed on a template tag.\n\n    if (template.tagName !== 'TEMPLATE') {\n      console.warn('Doars: `if` directive must be placed on a `<template>` tag.');\n      return;\n    } // Check if it only has one child.\n\n\n    if (template.childCount > 1) {\n      console.warn('Doars: `if` directive must have a single child node.');\n      return;\n    }\n\n    const set = result => {\n      // Get stored data.\n      const data = attribute.getData(); // Get existing reference element.\n\n      let element = data.element;\n      let transition = data.transition;\n\n      if (!result) {\n        // If the element exists then transition out and remove the element.\n        if (element) {\n          // Cancel previous transition.\n          if (transition) {\n            transition();\n          }\n\n          transition = transitionOut(component, element, () => {\n            element.remove();\n          });\n        }\n      } else if (!element) {\n        // If the reference does not exist create the element.\n        // Cancel previous transition.\n        if (transition) {\n          transition();\n        } // Create new element from template.\n\n\n        element = document.importNode(template.content, true); // Add element after the template element.\n\n        insertAfter(template, element); // Get HTMLElement reference instead of DocumentFragment.\n\n        element = template.nextElementSibling; // Transition element in.\n\n        transition = transitionIn(component, element);\n      } // Store results.\n\n\n      attribute.setData(Object.assign({}, data, {\n        element: element,\n        transition: transition\n      }));\n    }; // Execute expression.\n\n\n    const result = executeExpression(component, attribute, attribute.getValue()); // Get stored data.\n\n    const data = attribute.getData(); // Store results.\n\n    attribute.setData(Object.assign({}, data, {\n      result: result\n    })); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(result => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData().result !== result) {\n          return;\n        }\n\n        set(result);\n      });\n    } else {\n      set(result);\n    }\n  },\n  destroy: (component, attribute, {\n    transitionOut\n  }) => {\n    // Get stored data.\n    const data = attribute.getData(); // If the element exists then transition out and remove the element.\n\n    if (data.element) {\n      transitionOut(component, data.element, () => {\n        data.element.remove();\n      });\n    }\n  }\n};", "// Import symbols.\nimport { INITIALIZED } from '../symbols.js';\n\nconst destroy = (component, attribute) => {\n  // Exit early if no listeners can be found.\n  if (!attribute[INITIALIZED]) {\n    return;\n  } // Deconstruct component.\n\n\n  const element = component.getElement(); // Create event name.\n\n  const name = component.getLibrary().getOptions().prefix + '-updated'; // Remove existing listener and delete directive data.\n\n  element.removeEventListener(name, attribute[INITIALIZED].handler);\n  delete attribute[INITIALIZED];\n};\n\nexport default {\n  name: 'initialized',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct component.\n    const element = component.getElement(); // Deconstruct attribute.\n\n    const value = attribute.getValue(); // Create event name.\n\n    const name = component.getLibrary().getOptions().prefix + '-updated'; // Check if existing listener exists.\n\n    if (attribute[INITIALIZED]) {\n      // Exit early if listener has not changed.\n      if (attribute[INITIALIZED].value === value) {\n        return;\n      } // Remove existing listener so we don' listen twice.\n\n\n      element.removeEventListener(name, attribute[INITIALIZED].handler);\n      delete attribute[INITIALIZED];\n    }\n\n    const handler = ({\n      detail\n    }) => {\n      // Only execute on self.\n      if (detail.element !== element) {\n        return;\n      } // Execute value using a copy of the attribute since this attribute does not need to update based on what it accesses.\n\n\n      executeExpression(component, attribute.clone(), value, {}, {\n        return: false\n      }); // Call destroy.\n\n      destroy(component, attribute);\n    }; // Add listener to component.\n\n\n    element.addEventListener(name, handler, {\n      once: true\n    }); // Store listener data on the component.\n\n    attribute[INITIALIZED] = {\n      handler: handler,\n      value: value\n    };\n  },\n  destroy: destroy\n};", "// Import symbols.\nimport { ON } from '../symbols.js'; // Declare constants.\n\nconst EXECUTION_MODIFIERS = {\n  NONE: 0,\n  BUFFER: 1,\n  DEBOUNCE: 2,\n  THROTTLE: 3\n};\nconst KEYPRESS_MODIFIERS = ['alt', 'ctrl', 'meta', 'shift'];\nexport default {\n  name: 'on',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct attribute.\n    let name = attribute.getKeyRaw(); // Check if required key is set.\n\n    if (!name) {\n      console.warn('Doars: `on` directive must have a key.');\n      return;\n    } // Process keyboard events.\n\n\n    let key;\n\n    if (name.startsWith('keydown-')) {\n      key = name.substring(8).toLowerCase();\n      name = 'keydown';\n    } else if (name.startsWith('keyup-')) {\n      key = name.substring(6).toLowerCase();\n      name = 'keyup';\n    } // Deconstruct attribute.\n\n\n    const element = attribute.getElement();\n    const value = attribute.getValue(); // Check if existing listener exists.\n\n    if (attribute[ON]) {\n      // Exit early if value has not changed.\n      if (attribute[ON].value === value) {\n        return;\n      } // Remove existing listener so we don't listen twice.\n\n\n      attribute[ON].target.removeEventListener(name, attribute[ON].handler); // Clear any ongoing timeouts.\n\n      if (attribute[ON].timeout) {\n        clearTimeout(attribute[ON].timeout);\n      } // Delete directive data.\n\n\n      delete attribute[ON];\n    } // Deconstruct attribute.\n\n\n    const modifiers = attribute.getModifiers(); // Process modifiers.\n    // Set listener options.\n\n    const options = {};\n\n    if (modifiers.capture) {\n      options.capture = true;\n    }\n\n    if (modifiers.once) {\n      options.once = true;\n    }\n\n    if (modifiers.passive) {\n      options.passive = true;\n    } // Process execution modifiers.\n\n\n    let executionModifier = EXECUTION_MODIFIERS.NONE;\n\n    if (modifiers.buffer) {\n      executionModifier = EXECUTION_MODIFIERS.BUFFER;\n\n      if (modifiers.buffer === true) {\n        modifiers.buffer = 5;\n      }\n    } else if (modifiers.debounce) {\n      executionModifier = EXECUTION_MODIFIERS.DEBOUNCE;\n\n      if (modifiers.debounce === true) {\n        modifiers.debounce = 500;\n      }\n    } else if (modifiers.throttle) {\n      executionModifier = EXECUTION_MODIFIERS.THROTTLE;\n\n      if (modifiers.throttle === true) {\n        modifiers.throttle = 500;\n      }\n    } // Store keypress modifiers.\n\n\n    const keypressModifiers = [];\n\n    if (key) {\n      // Convert command and super to meta.\n      modifiers.meta = modifiers.meta ? true : modifiers.cmd || modifiers.super;\n\n      for (const modifier of KEYPRESS_MODIFIERS) {\n        if (modifiers[modifier]) {\n          keypressModifiers.push(modifier);\n        }\n      }\n    }\n\n    const handler = event => {\n      // Only fire when self is provided if the target is the element itself.\n      if (modifiers.self && event.target !== element) {\n        return;\n      }\n\n      if (modifiers.outside && element.contains(event.target)) {\n        // Don't fire with outside modifier unless the event came from outside.\n        return;\n      }\n\n      if ((name === 'keydown' || name === 'keyup') && key) {\n        // For keyboard events check the key pressed.\n        // Check if all key press modifiers are held.\n        for (const keypressModifier of keypressModifiers) {\n          if (!event[keypressModifier + 'Key']) {\n            return;\n          }\n        }\n\n        let eventKey = modifiers.code ? event.code : event.key;\n\n        if (eventKey === ' ') {\n          eventKey = 'space';\n        }\n\n        eventKey = eventKey.toLowerCase();\n\n        if (key !== eventKey) {\n          return;\n        }\n      } // Prevent default if the prevent modifier is present.\n\n\n      if (modifiers.prevent) {\n        event.preventDefault();\n      } // Stop propagation if the stop modifier is present.\n\n\n      if (modifiers.stop) {\n        event.stopPropagation();\n      }\n\n      const execute = () => {\n        // Execute value using a copy of the attribute since this attribute should not update based on what contexts will be accessed.\n        executeExpression(component, attribute.clone(), value, {\n          $event: event,\n          $events: attribute[ON].buffer\n        }, {\n          return: false\n        }); // Reset the buffer.\n\n        attribute[ON].buffer = [];\n      }; // Store event in buffer.\n\n\n      attribute[ON].buffer.push(event); // Check if we need to apply an execution modifier.\n\n      if (executionModifier === EXECUTION_MODIFIERS.BUFFER) {\n        // Exit early if buffer is not full.\n        if (attribute[ON].buffer.length < modifiers.buffer) {\n          return;\n        }\n\n        execute();\n      } else if (executionModifier === EXECUTION_MODIFIERS.DEBOUNCE) {\n        // Clear existing timeout.\n        if (attribute[ON].timeout) {\n          clearTimeout(attribute[ON].timeout);\n          attribute[ON].timeout = null;\n        } // Setup timeout and execute expression when it finishes.\n\n\n        attribute[ON].timeout = setTimeout(execute, modifiers.debounce);\n      } else if (executionModifier === EXECUTION_MODIFIERS.THROTTLE) {\n        // Get current time in milliseconds.\n        const now = window.performance.now(); // Exit early if throttle time has not passed.\n\n        if (attribute[ON].lastExecution && now - attribute[ON].lastExecution < modifiers.throttle) {\n          return;\n        }\n\n        execute(); // Store new latest execution time.\n\n        attribute[ON].lastExecution = now;\n      } else {\n        // Execute expression.\n        execute();\n      }\n    }; // Set listener target and start listening.\n\n\n    const target = modifiers.outside ? document : element;\n    target.addEventListener(name, handler, options); // Store listener data on the component.\n\n    attribute[ON] = {\n      buffer: [],\n      handler: handler,\n      target: target,\n      timeout: attribute[ON] ? attribute[ON].timeout : undefined,\n      value: value\n    };\n  },\n  destroy: (component, attribute) => {\n    // Exit early if no listeners can be found.\n    if (!attribute[ON]) {\n      return;\n    } // Deconstruct attribute.\n\n\n    const key = attribute.getKeyRaw(); // Remove existing listener.\n\n    attribute[ON].target.removeEventListener(key, attribute[ON].handler); // Clear any ongoing timeouts.\n\n    if (attribute[ON].timeout) {\n      clearTimeout(attribute[ON].timeout);\n    } // Delete directive data.\n\n\n    delete attribute[ON];\n  }\n};", "// Import symbols.\nimport { REFERENCES, REFERENCES_CACHE } from '../symbols.js';\n\nconst destroy = (component, attribute) => {\n  // Exit early if not set.\n  if (!component[REFERENCES]) {\n    return;\n  } // Deconstruct attribute.\n\n\n  const attributeId = attribute.getId(); // Exit early if not the same attribute.\n\n  if (!component[REFERENCES][attributeId]) {\n    return;\n  } // Deconstruct component.\n\n\n  const library = component.getLibrary();\n  const componentId = component.getId(); // Deconstruct attribute.\n\n  const value = attribute.getValue().trim(); // Remove reference from object.\n\n  delete component[REFERENCES][attributeId]; // Remove context cache.\n\n  delete component[REFERENCES_CACHE]; // Remove object if it is empty now.\n\n  if (Object.keys(component[REFERENCES]).length === 0) {\n    delete component[REFERENCES];\n  } // Trigger references update.\n\n\n  library.update([{\n    id: componentId,\n    path: '$references.' + value\n  }]);\n};\n\nexport default {\n  name: 'reference',\n  update: (component, attribute) => {\n    // Deconstruct attribute.\n    const value = attribute.getValue().trim(); // Check if value is a valid variable name.\n\n    if (!/^[_$a-z]{1}[_\\-$a-z0-9]{0,}$/i.test(value)) {\n      destroy(component, attribute);\n      console.warn('Doars: `reference` directive\\'s value not a valid variable name: \"' + value + '\".');\n      return;\n    } // Deconstruct component.\n\n\n    const library = component.getLibrary();\n    const componentId = component.getId(); // Deconstruct attribute.\n\n    const element = attribute.getElement();\n    const attributeId = attribute.getId(); // Check if references object exists.\n\n    if (!component[REFERENCES]) {\n      component[REFERENCES] = {};\n    } // Store reference.\n\n\n    component[REFERENCES][attributeId] = {\n      element: element,\n      name: value\n    }; // Remove context cache.\n\n    delete component[REFERENCES_CACHE]; // Trigger references update.\n\n    library.update([{\n      id: componentId,\n      path: '$references.' + value\n    }]);\n  },\n  destroy: destroy\n};", "// Import utils.\nimport { isPromise } from '../utils/PromiseUtils.js';\nexport default {\n  name: 'select',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement(); // Check if placed on a select tag.\n\n    const type = element.getAttribute('type');\n\n    if (element.tagName !== 'SELECT' && !(element.tagName === 'INPUT' && (type === 'checkbox' || type === 'radio'))) {\n      console.warn('Doars: `select` directive must be placed on a `select` tag or `input` of type checkbox or radio.');\n      return;\n    }\n\n    const set = data => {\n      // Iterate over the select options.\n      if (element.tagName === 'SELECT') {\n        for (const option of Array.from(element.options)) {\n          // Update option if the selected value has changed.\n          const select = Array.isArray(data) ? data.includes(option.value) : data === option.value;\n\n          if (option.selected !== select) {\n            // Update option's status.\n            option.selected = select; // Update option's attribute.\n\n            if (select) {\n              option.setAttribute('selected', '');\n            } else {\n              option.removeAttribute('selected');\n            }\n          }\n        }\n      } else if (type === 'checkbox') {\n        // Update option if the checked value has changed.\n        const checked = data.includes(element.value);\n\n        if (element.checked !== checked) {\n          // Update checked attribute.\n          if (checked) {\n            element.setAttribute('checked', '');\n          } else {\n            element.removeAttribute('checked');\n          }\n        }\n      } else {\n        // Update option if the checked value has changed.\n        const checked = data === element.value;\n\n        if (element.checked !== checked) {\n          // Update checked attribute.\n          if (checked) {\n            element.setAttribute('checked', '');\n          } else {\n            element.removeAttribute('checked');\n          }\n        }\n      }\n    }; // Execute attribute value.\n\n\n    const result = executeExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "// Import utils.\nimport { isPromise } from '../utils/PromiseUtils.js';\nexport default {\n  name: 'show',\n  update: (component, attribute, {\n    executeExpression,\n    transitionIn,\n    transitionOut\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n\n    const set = () => {\n      // Get stored data.\n      const data = attribute.getData(); // Cancel previous transition.\n\n      if (data.transition) {\n        data.transition();\n      } // Assign display based on truthiness of expression result.\n\n\n      let transition;\n\n      if (data.result) {\n        element.style.display = null;\n        transition = transitionIn(component, element);\n      } else {\n        transition = transitionOut(component, element, () => {\n          element.style.display = 'none';\n        });\n      } // Store new transition.\n\n\n      attribute.setData(Object.assign({}, data, {\n        transition: transition\n      }));\n    }; // Execute attribute value.\n\n\n    const result = executeExpression(component, attribute, attribute.getValue()); // Get stored data.\n\n    const data = attribute.getData(); // Handle promises.\n\n    if (isPromise(result)) {\n      // Store results.\n      attribute.setData(Object.assign({}, data, {\n        result: result\n      }));\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData().result !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else if (!data || data.result !== result) {\n      // Store results.\n      attribute.setData(Object.assign({}, data, {\n        result: result\n      }));\n      set();\n    }\n  }\n};", "/**\n * Deeply assign a series of objects properties together.\n * @param {Object} target Target object to merge to.\n * @param  {...Object} sources Objects to merge into the target.\n */\nexport const deepAssign = (target, ...sources) => {\n  if (!sources.length) {\n    return target;\n  }\n\n  const source = sources.shift();\n\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) {\n          Object.assign(target, {\n            [key]: {}\n          });\n        }\n\n        deepAssign(target[key], source[key]);\n      } else if (Array.isArray(source[key])) {\n        target[key] = source[key].map(value => {\n          if (isObject(value)) {\n            return deepAssign({}, value);\n          }\n\n          return value;\n        });\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n\n  return deepAssign(target, ...sources);\n};\n/**\n * Get value at path on object.\n * @param {Object} object Object to get from.\n * @param  {Array<String>} path Path to value.\n * @returns {Any} value at path.\n */\n\nexport const get = (object, path) => {\n  let objectTemp = object;\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    objectTemp = objectTemp[path[i]];\n  }\n\n  return objectTemp[path[i]];\n};\n/**\n * Check whether the value is an object.\n * @param {Any} value Value of unknown type.\n * @returns Whether the value is an object.\n */\n\nexport const isObject = value => {\n  return value && typeof value === 'object' && !Array.isArray(value);\n};\n/**\n * Set value on path at object.\n * @param {Object} object Object to set on.\n * @param {Array<String>} path Path to value.\n * @param {Any} value Value to set.\n */\n\nexport const set = (object, path, value) => {\n  // Exit early if not an object.\n  if (typeof object !== 'object') {\n    return;\n  }\n\n  let i = 0;\n\n  for (; i < path.length - 1; i++) {\n    object = object[path[i]]; // Exit early if not an object.\n\n    if (typeof object !== 'object') {\n      return;\n    }\n  }\n\n  object[path[i]] = value;\n};\nexport default {\n  deepAssign: deepAssign,\n  get: get,\n  isObject: isObject,\n  set: set\n};", "// Import utils.\nimport { set } from '../../utils/ObjectUtils.js';\nexport default ((symbol, getData, contextPrefix) => {\n  const destroy = (component, attribute) => {\n    // Exit early if nothing to destroy.\n    if (!attribute[symbol]) {\n      return;\n    } // Deconstruct attribute.\n\n\n    const element = attribute.getElement(); // Remove existing event listeners.\n\n    element.removeEventListener('input', attribute[symbol]); // Remove data from attribute.\n\n    delete attribute[symbol];\n  };\n\n  return {\n    update: (component, attribute, {\n      executeExpression\n    }) => {\n      // Deconstruct attribute.\n      const element = attribute.getElement(); // Store whether this call is an update.\n\n      const isNew = !attribute[symbol];\n\n      if (isNew) {\n        // Check if placed on a correct tag.\n        if (!(element.tagName === 'DIV' && element.hasAttribute('contenteditable')) && element.tagName !== 'INPUT' && element.tagName !== 'SELECT' && element.tagName !== 'TEXTAREA') {\n          console.warn('Doars: `sync` directive must be placed on an `<input>`, `<select>`, `<textarea>` tag, or a content editable `div`.');\n          return;\n        }\n      } // Deconstruct attribute.\n\n\n      const value = attribute.getValue(); // Check if value is a valid variable name.\n\n      if (!/^[_$a-z]{1}[._$a-z0-9]{0,}$/i.test(value)) {\n        destroy(component, attribute);\n        console.warn('Doars: `sync` directive\\'s value not a valid variable name: \"' + value + '\".');\n        return;\n      } // Remove context prefix.\n\n\n      let pathSplit = value;\n\n      if (pathSplit.startsWith(contextPrefix)) {\n        pathSplit = pathSplit.substring(contextPrefix.length);\n      } // Split value into path segments.\n\n\n      pathSplit = pathSplit.split('.');\n\n      if (isNew) {\n        // Get data for syncing.\n        const {\n          data,\n          id,\n          path\n        } = getData(component, attribute); // Set handler that updates data based of node tag.\n\n        let handler;\n\n        switch (element.tagName) {\n          case 'DIV':\n            handler = () => {\n              set(data, pathSplit, element.innerText);\n              return true;\n            };\n\n            break;\n\n          case 'INPUT':\n            handler = () => {\n              if (element.type === 'checkbox') {\n                const dataValue = executeExpression(component, attribute.clone(), value);\n\n                if (element.checked) {\n                  if (!dataValue) {\n                    set(data, pathSplit, [element.value]);\n                    return true;\n                  }\n\n                  if (!dataValue.includes(element.value)) {\n                    dataValue.push(element.value);\n                    return true;\n                  }\n                } else if (dataValue) {\n                  const index = dataValue.indexOf(element.value);\n\n                  if (index >= 0) {\n                    dataValue.splice(index, 1);\n                    return true;\n                  }\n                }\n              } else if (element.type === 'radio') {\n                const dataValue = executeExpression(component, attribute.clone(), value);\n\n                if (element.checked) {\n                  if (dataValue !== element.value) {\n                    set(data, pathSplit, element.value);\n                    return true;\n                  }\n                } else if (dataValue === element.value) {\n                  set(data, pathSplit, null);\n                  return true;\n                }\n              } else {\n                set(data, pathSplit, element.value);\n                return true;\n              }\n\n              return false;\n            };\n\n            break;\n\n          case 'TEXTAREA':\n            handler = () => {\n              set(data, pathSplit, element.value);\n              return true;\n            };\n\n            break;\n\n          case 'SELECT':\n            handler = () => {\n              if (element.multiple) {\n                const values = [];\n\n                for (const option of element.selectedOptions) {\n                  values.push(option.value);\n                }\n\n                set(data, pathSplit, values);\n                return true;\n              }\n\n              set(data, pathSplit, element.selectedOptions[0].value);\n              return true;\n            };\n\n            break;\n        } // Wrap handler so an update is triggered.\n\n\n        const handlerWrapper = () => {\n          // Call handler.\n          if (handler()) {\n            // Dispatch update trigger.\n            component.getLibrary().update([{\n              id: id,\n              path: path\n            }]);\n          }\n        }; // Add event listener.\n\n\n        element.addEventListener('input', handlerWrapper); // Store handler wrapper.\n\n        attribute[symbol] = handlerWrapper;\n      }\n\n      const dataValue = executeExpression(component, attribute, value);\n\n      switch (element.tagName) {\n        case 'DIV':\n        case 'TEXTAREA':\n          // Check if current value is different than attribute value.\n          if (dataValue !== element.innerText) {\n            // Update current value.\n            element.innerText = dataValue;\n          }\n\n          break;\n\n        case 'INPUT':\n          if (element.type === 'checkbox') {\n            // Update option if the checked value has changed.\n            const checked = dataValue.includes(element.value);\n\n            if (element.checked !== checked) {\n              // Update checked value.\n              element.checked = checked; // Update checked attribute.\n\n              if (checked) {\n                element.setAttribute('checked', '');\n              } else {\n                element.removeAttribute('checked');\n              }\n            }\n          } else if (element.type === 'radio') {\n            // Update option if the checked value has changed.\n            const checked = dataValue === element.value;\n\n            if (element.checked !== checked) {\n              // Update checked value.\n              element.checked = checked; // Update checked attribute.\n\n              if (checked) {\n                element.setAttribute('checked', '');\n              } else {\n                element.removeAttribute('checked');\n              }\n            }\n          } else if (dataValue !== element.value) {\n            // Check if current value is different than attribute value.\n            // Update current value.\n            element.setAttribute('value', dataValue);\n          }\n\n          break;\n\n        case 'SELECT':\n          // Iterate over the select options.\n          for (const option of Array.from(element.options)) {\n            // Update option if the selected value has changed.\n            const select = Array.isArray(dataValue) ? dataValue.includes(option.value) : dataValue === option.value;\n\n            if (option.selected !== select) {\n              // Update option status.\n              option.selected = select; // Update option attribute.\n\n              if (select) {\n                option.setAttribute('selected', '');\n              } else {\n                option.removeAttribute('selected');\n              }\n            }\n          }\n\n          break;\n      }\n    },\n    destroy: destroy\n  };\n});", "// Import symbols.\nimport { SYNC_STATE } from '../symbols.js'; // Import generator.\n\nimport createDirectiveSync from '../factories/directives/sync.js';\nconst STATE_PREFIX = '$state.';\nconst directive = createDirectiveSync(SYNC_STATE, (component, attribute) => {\n  // Add prefix to value.\n  let value = attribute.getValue();\n\n  if (!value.startsWith(STATE_PREFIX)) {\n    value = STATE_PREFIX + value;\n  } // Return directive data.\n\n\n  return {\n    data: component.getState(),\n    id: component.getId(),\n    path: value\n  };\n}, STATE_PREFIX);\ndirective.name = 'sync-state';\nexport default directive;", "import { isPromise } from '../utils/PromiseUtils.js';\nexport default {\n  name: 'text',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct attribute.\n    const element = attribute.getElement();\n    const modifiers = attribute.getModifiers();\n\n    const set = text => {\n      // Assign text.\n      if (modifiers.content) {\n        if (element.textContent !== text) {\n          element.textContent = text;\n        }\n      } else if (element.innerText !== text) {\n        element.innerText = text;\n      }\n    }; // Execute value and retrieve result.\n\n\n    const result = executeExpression(component, attribute, attribute.getValue()); // Store results.\n\n    attribute.setData(result); // Handle promises.\n\n    if (isPromise(result)) {\n      Promise.resolve(result).then(resultResolved => {\n        // If stored data has changed then this promise should be ignored.\n        if (attribute.getData() !== result) {\n          return;\n        }\n\n        set(resultResolved);\n      });\n    } else {\n      set(result);\n    }\n  }\n};", "export default {\n  name: 'watch',\n  update: (component, attribute, {\n    executeExpression\n  }) => {\n    // Deconstruct attribute.\n    const value = attribute.getValue(); // Execute attribute expression.\n\n    executeExpression(component, attribute, value, {}, {\n      return: false\n    });\n  }\n};", "// Import symbols.\nimport { ATTRIBUTES, COMPONENT } from './symbols.js'; // Import classes.\n\nimport Component from './Component.js'; // Import contexts.\n\nimport contextChildren from './contexts/children.js';\nimport contextComponent from './contexts/component.js';\nimport contextElement from './contexts/element.js';\nimport contextDispatch from './contexts/dispatch.js';\nimport contextFor from './contexts/for.js';\nimport contextInContext from './contexts/inContext.js';\nimport contextNextTick from './contexts/nextTick.js';\nimport contextParent from './contexts/parent.js';\nimport contextReferences from './contexts/references.js';\nimport contextState from './contexts/state.js'; // Import directives.\n\nimport directiveAttribute from './directives/attribute.js';\nimport directiveCloak from './directives/cloak.js';\nimport directiveFor from './directives/for.js';\nimport directiveHtml from './directives/html.js';\nimport directiveIf from './directives/if.js';\nimport directiveInitialized from './directives/initialized.js';\nimport directiveOn from './directives/on.js';\nimport directiveReference from './directives/reference.js';\nimport directiveSelect from './directives/select.js';\nimport directiveShow from './directives/show.js';\nimport directiveSyncState from './directives/syncState.js';\nimport directiveText from './directives/text.js';\nimport directiveWatch from './directives/watch.js'; // Import event dispatcher.\n\nimport EventDispatcher from './events/EventDispatcher.js'; // Import utils.\n\nimport { closestComponent } from './utils/ComponentUtils.js';\nimport { walk } from './utils/ElementUtils.js';\nexport default class Doars extends EventDispatcher {\n  /**\n   * Create instance.\n   * @param {Object} options Options.\n   */\n  constructor(options) {\n    super(); // Deconstruct options.\n\n    let {\n      prefix,\n      root\n    } = options = Object.assign({\n      prefix: 'd',\n      root: document.body.firstElementChild\n    }, options); // If root is a string assume it is a selector.\n\n    if (typeof root === 'string') {\n      options.root = root = document.querySelector(root);\n    } // Validate options.\n\n\n    if (process.env.NODE_ENV === 'development') {\n      if (!prefix) {\n        console.error('Doars: `prefix` option not set.');\n        return;\n      }\n\n      if (typeof prefix !== 'string') {\n        console.error('Doars: `prefix` option must be of type string.');\n        return;\n      }\n\n      if (!root) {\n        console.error('Doars: `root` option not set.');\n        return;\n      }\n\n      if (typeof root !== 'object') {\n        console.error('Doars: `root` option must be a string or HTMLElement.');\n        return;\n      }\n    } // Create unique identifier.\n\n\n    const id = Symbol('ID_DOARS'); // Create private variables.\n\n    let isEnabled = false,\n        isUpdating = false,\n        mutations,\n        observer,\n        triggers;\n    const components = [];\n    const contexts = [contextChildren, contextComponent, contextElement, contextDispatch, contextInContext, contextNextTick, contextParent, contextReferences, // Order of `state` before `for` context is important for deconstruction.\n    contextState, contextFor];\n    const directives = [// Must happen first as other directives can rely on it.\n    directiveReference, // Then execute those that modify the document tree, since it could make other directives redundant and save on processing.\n    directiveAttribute, directiveFor, directiveHtml, directiveIf, directiveText, // Order does not matter any more.\n    directiveCloak, directiveInitialized, directiveOn, directiveSelect, directiveShow, directiveSyncState, directiveWatch];\n    let directivesNames, directivesObject, directivesRegexp;\n    /**\n     * Whether this is currently enabled.\n     * @returns {Boolean} Whether the library is enabled.\n     */\n\n    this.getEnabled = () => {\n      return isEnabled;\n    };\n    /**\n     * Get the unique identifier.\n     * @returns {Symbol} Unique identifier.\n     */\n\n\n    this.getId = () => {\n      return id;\n    };\n    /**\n     * Get the current options.\n     * @returns {Object} Current options.\n     */\n\n\n    this.getOptions = () => {\n      return Object.assign({}, options);\n    };\n    /**\n     * Enable the library.\n     * @returns {Doars} This instance.\n     */\n\n\n    this.enable = () => {\n      if (isEnabled) {\n        return this;\n      } // Setup values.\n\n\n      isUpdating = false;\n      mutations = [];\n      triggers = {}; // Dispatch event.\n\n      this.dispatchEvent('enabling', [this]); // Mark as enabled.\n\n      isEnabled = true; // Create list of directive names.\n\n      directivesNames = directives.map(directive => directive.name); // Create directives object.\n\n      directivesObject = {};\n\n      for (const directive of directives) {\n        directivesObject[directive.name] = directive;\n      } // Dynamically create expression for matching any attribute names to known directive keys.\n\n\n      directivesRegexp = new RegExp('^' + prefix + '-(' + directivesNames.join('|') + ')(?:[$-_.a-z0-9]{0,})?$', 'i'); // eslint-disable-line prefer-regex-literals\n      // Create mutation observer.\n\n      observer = new MutationObserver(handleMutation.bind(this));\n      observer.observe(root, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      }); // Scan for components.\n\n      const componentName = prefix + '-state';\n      const ignoreName = prefix + '-ignore';\n      const componentElements = [...root.querySelectorAll('[' + componentName + ']')]; // Remove any elements that should be ignored.\n\n      for (let i = componentElements.length - 1; i >= 0; i--) {\n        if (componentElements[i].closest('[' + ignoreName + ']')) {\n          componentElements.splice(i, 1);\n        }\n      }\n\n      addComponents(root.hasAttribute(componentName) && !root.hasAttribute(ignoreName) ? root : null, ...componentElements); // Dispatch events.\n\n      this.dispatchEvent('enabled', [this]);\n      this.dispatchEvent('updated', [this]);\n      return this;\n    };\n    /**\n     * Disable the library.\n     * @returns {Doars} This instance.\n     */\n\n\n    this.disable = () => {\n      if (!isEnabled) {\n        return this;\n      } // Disable mutation observer.\n\n\n      observer.disconnect();\n      observer = null; // Reset values.\n\n      isUpdating = mutations = triggers = null; // Dispatch event.\n\n      this.dispatchEvent('disabling', [this], {\n        reverse: true\n      }); // Remove components.\n\n      removeComponents(...components); // Reset directives helper.\n\n      directivesNames = directivesObject = directivesRegexp = null; // Mark as disabled.\n\n      isEnabled = false; // Dispatch event.\n\n      this.dispatchEvent('disabled', [this], {\n        reverse: true\n      });\n      return this;\n    };\n    /**\n     * Add components to instance.\n     * @param  {...HTMLElement} elements Elements to add as components.\n     * @returns {Array<Component>} List of added components.\n     */\n\n\n    const addComponents = (...elements) => {\n      const results = [];\n      const resultElements = [];\n\n      for (const element of elements) {\n        if (!element) {\n          continue;\n        } // Skip if already a component.\n\n\n        if (element[COMPONENT]) {\n          continue;\n        } // Create component.\n\n\n        const component = new Component(this, element); // Add to list.\n\n        components.push(component); // Add to results.\n\n        results.push(component);\n        resultElements.push(element);\n      }\n\n      if (resultElements.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('components-added', [this, resultElements]);\n      } // Initialize new components.\n\n\n      for (const component of results) {\n        component.initialize();\n      } // Update all attributes on new components.\n\n\n      for (const component of results) {\n        component.updateAttributes(component.getAttributes());\n      }\n\n      return results;\n    };\n    /**\n     * Remove components from instance.\n     * @param  {...Component} components Component to remove.\n     * @returns {Array<HTMLElement>} List of elements of removed components.\n     */\n\n\n    const removeComponents = (..._components) => {\n      const results = [];\n\n      for (const component of _components) {\n        // Skip if not in list.\n        const index = components.indexOf(component);\n\n        if (index < 0) {\n          continue;\n        } // Add to results.\n\n\n        results.push(component.getElement()); // Destroy component.\n\n        component.destroy(); // Remove from list.\n\n        components.splice(index, 1);\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('components-removed', [this, results]);\n      }\n\n      return results;\n    };\n    /**\n     * Get list contexts.\n     * @returns {Array<Object>} List of contexts.\n     */\n\n\n    this.getContexts = () => {\n      return [...contexts];\n    };\n    /**\n     * Add contexts at the index. *Can only be called when NOT enabled.*\n     * @param {Number} index Index to start adding at.\n     * @param {...Object} _contexts List of contexts to add.\n     * @returns {Array<Object>} List of added contexts.\n     */\n\n\n    this.addContexts = (index, ..._contexts) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to add contexts after being enabled!');\n        return;\n      }\n\n      if (index < 0) {\n        index = contexts.length + index % contexts.length;\n      } else if (index > contexts.length) {\n        index = contexts.length;\n      }\n\n      const results = [];\n\n      for (let i = 0; i < _contexts.length; i++) {\n        // Get context from list.\n        const context = _contexts[i]; // Skip if already in list.\n\n        if (contexts.includes(context)) {\n          continue;\n        } // Add to list.\n\n\n        contexts.splice(index + i, 0, context); // Add to results.\n\n        results.push(context);\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('contexts-added', [this, results]);\n      }\n\n      return results;\n    };\n    /**\n     * Remove contexts. *Can only be called when NOT enabled.*\n     * @param {...Object} _contexts List of contexts to remove.\n     * @returns {Array<Object>} List of removed contexts.\n     */\n\n\n    this.removeContexts = (..._contexts) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to remove contexts after being enabled!');\n        return;\n      }\n\n      const results = [];\n\n      for (const context of _contexts) {\n        // Skip if not in list.\n        const index = contexts.indexOf(context);\n\n        if (index < 0) {\n          continue;\n        } // Remove from list.\n\n\n        contexts.slice(index, 1); // Add to results.\n\n        results.push(context);\n      }\n\n      if (results.length > 0) {\n        // Dispatch event.\n        this.dispatchEvent('contexts-removed', [this, results]);\n      }\n\n      return results;\n    };\n    /* Directives */\n\n    /**\n     * Get list directives.\n     * @returns {Array<Object>} List of directives.\n     */\n\n\n    this.getDirectives = () => {\n      return [...directives];\n    };\n    /**\n     * Get list of directive names.\n     * @returns {Array<String>} List of directive names.\n     */\n\n\n    this.getDirectivesNames = () => {\n      return [...directivesNames];\n    };\n    /**\n     * Get object of directives with the directive name as key.\n     * @returns {Object} Object of directives.\n     */\n\n\n    this.getDirectivesObject = () => {\n      return Object.assign({}, directivesObject);\n    };\n    /**\n     * Check whether a name matches that of a directive.\n     * @param {String} attributeName Name of the attribute to match.\n     * @returns {Boolean} Whether the name matches that of a directive.\n     */\n\n\n    this.isDirectiveName = attributeName => {\n      return directivesRegexp.test(attributeName);\n    };\n    /**\n     * Add directives at the index. *Can only be called when NOT enabled.*\n     * @param {Number} index Index to start adding at.\n     * @param  {...Object} _directives List of directives to add.\n     * @returns {Array<Object>} List of added directives.\n     */\n\n\n    this.addDirectives = (index, ..._directives) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to add directives after being enabled!');\n        return;\n      }\n\n      if (index < 0) {\n        index = directives.length + index % directives.length;\n      } else if (index > directives.length) {\n        index = directives.length;\n      }\n\n      const results = [];\n\n      for (let i = 0; i < _directives.length; i++) {\n        // Get directive from list.\n        const directive = _directives[i]; // Skip if already in list.\n\n        if (directives.includes(directive)) {\n          continue;\n        } // Add to list.\n\n\n        directives.splice(index + i, 0, directive); // Add to results.\n\n        results.push(directive);\n      }\n\n      if (results.length > 0) {\n        // Reset directives helpers.\n        directivesNames = directivesObject = directivesRegexp = null; // Dispatch event.\n\n        this.dispatchEvent('directives-added', [this, results]);\n      }\n\n      return results;\n    };\n    /**\n     * Remove directives. *Can only be called when NOT enabled.*\n     * @param  {...Object} _directives List of directives to remove.\n     * @returns {Array<Object>} List of removed directives.\n     */\n\n\n    this.removeDirectives = (..._directives) => {\n      if (isEnabled) {\n        console.warn('Doars: Unable to remove directives after being enabled!');\n        return;\n      }\n\n      const results = [];\n\n      for (const directive of _directives) {\n        // Skip if not in list.\n        const index = directives.indexOf(directive);\n\n        if (index < 0) {\n          continue;\n        } // Remove from list.\n\n\n        directives.slice(index, 1); // Add to results\n\n        results.push(directive);\n      }\n\n      if (results.length > 0) {\n        // Reset directives helpers.\n        directivesNames = directivesObject = directivesRegexp = null; // Dispatch event.\n\n        this.dispatchEvent('directives-removed', [this, results]);\n      }\n\n      return results;\n    };\n    /**\n     * Update directives based on triggers. *Can only be called when enabled.*\n     * @param {Array<Object>} _triggers List of triggers to update with.\n     */\n\n\n    this.update = _triggers => {\n      if (!isEnabled) {\n        // Exit early since it needs to enabled first.\n        return;\n      }\n\n      if (_triggers) {\n        // Add new triggers to existing triggers.\n        for (const trigger of _triggers) {\n          // Deconstruct new trigger.\n          const {\n            id,\n            path\n          } = trigger; // Create list at id if not already there.\n\n          if (!(id in triggers)) {\n            triggers[id] = [path];\n            continue;\n          } // Add path to list at id.\n\n\n          if (!triggers[id].includes(path)) {\n            triggers[id].push(path);\n          }\n        }\n      } // Don't update while another update is going on.\n\n\n      if (isUpdating) {\n        return;\n      } // Check if there is something to update.\n\n\n      if (Object.getOwnPropertySymbols(triggers).length === 0) {\n        return;\n      } // Set as updating.\n\n\n      isUpdating = true; // Move update triggers to local scope only.\n\n      _triggers = triggers;\n      triggers = {}; // Update each component and collect any triggers.\n\n      for (const component of components) {\n        component.update(_triggers); // If this ever needs to be done in hierarchical order try the following. Go over each component and check if its parent is further down in the list. If so place the component directly after the parent. Then continue iteration over the components. This sorting only has to happen when a component is added to or moved in the hierarchy.\n      } // Set as NOT updating.\n\n\n      isUpdating = false; // If there are triggers again then update again.\n\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        console.warn('Doars: during an update another update has been triggered. Normally this should not happen unless an expression in one of the directives is modifying a state which could cause a infinite loop!'); // Use an animation frame to delay the update to prevent freezing.\n\n        window.requestAnimationFrame(() => this.update());\n        return;\n      } // If there are any mutation to handle then handle them.\n\n\n      if (mutations.length > 0) {\n        handleMutation();\n        return;\n      }\n\n      this.dispatchEvent('updated', [this]);\n    };\n    /**\n     * Handle document mutations by update internal data and executing directives.\n     * @param {Array<MutationRecord>} newMutations List of mutations.\n     */\n\n\n    const handleMutation = newMutations => {\n      // Add mutations to existing list.\n      mutations.push(...newMutations); // Don't handle mutations while an update is going on.\n\n      if (isUpdating) {\n        return;\n      } // Check if there are any mutations to handle.\n\n\n      if (mutations.length === 0) {\n        return;\n      } // Set as updating.\n\n\n      isUpdating = true; // Get mutations to handle.\n\n      newMutations = [...mutations];\n      mutations = []; // Construct component name.\n\n      const componentName = prefix + '-state';\n      const ignoreName = prefix + '-ignore'; // Store new attribute and elements that define new components.\n\n      const componentsToAdd = [];\n      const componentsToRemove = [];\n\n      const remove = element => {\n        // Skip if not an element.\n        if (element.nodeType !== 1) {\n          return;\n        } // Check if element is a component itself.\n\n\n        if (element[COMPONENT]) {\n          // Add component to remove list.\n          componentsToRemove.unshift(element[COMPONENT]); // Scan for more components inside this.\n\n          const componentElements = element.querySelectorAll(componentName);\n\n          for (const componentElement of componentElements) {\n            if (componentElement[COMPONENT]) {\n              componentsToRemove.unshift(componentElement);\n            }\n          }\n        } else {\n          // Create iterator for walking over all elements in the component, skipping elements that are components and adding those to the remove list.\n          const iterator = walk(element, element => {\n            if (element[COMPONENT]) {\n              componentsToRemove.unshift(element[COMPONENT]);\n              return false;\n            }\n\n            return true;\n          });\n\n          do {\n            // Check if element has attributes.\n            if (!element[ATTRIBUTES]) {\n              continue;\n            } // Remove attributes from their component.\n\n\n            for (const attribute of element[ATTRIBUTES]) {\n              attribute.getComponent().removeAttribute(attribute);\n            }\n          } while (element = iterator());\n        }\n      };\n\n      const add = element => {\n        // Skip if not an element.\n        if (element.nodeType !== 1) {\n          return;\n        } // Skip if inside an ignore tag.\n\n\n        const ignoreParent = element.closest('[' + ignoreName + ']');\n\n        if (ignoreParent) {\n          return;\n        } // Scan for new components and add them to the list.\n\n\n        const componentElements = element.querySelectorAll('[' + componentName + ']');\n\n        for (const componentElement of componentElements) {\n          // Skip if inside an ignore tag.\n          const ignoreParent = componentElement.closest('[' + ignoreName + ']');\n\n          if (ignoreParent) {\n            continue;\n          }\n\n          componentsToAdd.push(componentElement);\n        } // Check if this elements defines a new component.\n\n\n        if (element.hasAttribute(componentName)) {\n          // Store new component element and exit early.\n          componentsToAdd.push(element);\n          return;\n        } // Find nearest component.\n\n\n        const component = closestComponent(element);\n\n        if (component) {\n          // Scan for and update new attributes.\n          const attributes = component.scanAttributes(element);\n          component.updateAttributes(attributes);\n        }\n      }; // Iterate over mutations.\n\n\n      for (const mutation of newMutations) {\n        if (mutation.type === 'childList') {\n          // Iterate over removed elements.\n          for (const element of mutation.removedNodes) {\n            remove(element);\n          } // Iterate over added elements.\n\n\n          for (const element of mutation.addedNodes) {\n            add(element);\n          }\n        } else if (mutation.type === 'attributes') {\n          const element = mutation.target; // Check if new component is defined.\n\n          if (mutation.attributeName === componentName) {\n            // If a component is already defined ignore the change.\n            if (element[COMPONENT]) {\n              continue;\n            } // Get nearest component, this will become the parent.\n\n\n            const component = closestComponent(element);\n\n            if (component) {\n              // Remove attributes part of nearest component, that will become part of the new component.\n              let currentElement = element;\n              const iterator = walk(element, element => element.hasAttribute(componentName));\n\n              do {\n                for (const attribute of currentElement[ATTRIBUTES]) {\n                  component.removeAttribute(attribute);\n                }\n              } while (currentElement = iterator());\n            } // Add new component.\n\n\n            addComponents(element);\n            continue;\n          } else if (mutation.attributeName === ignoreName) {\n            if (element.hasAttribute(ignoreName)) {\n              // Remove everything inside.\n              remove(element);\n              continue;\n            } // Add everything inside.\n\n\n            add(element);\n            continue;\n          } // Check if a directive is added.\n\n\n          if (!directivesRegexp.test(mutation.attributeName)) {\n            continue;\n          } // Get component of mutated element.\n\n\n          const component = closestComponent(element);\n\n          if (!component) {\n            continue;\n          } // Get attribute from component and value from element.\n\n\n          let attribute = null;\n\n          for (const targetAttribute of element[ATTRIBUTES]) {\n            if (targetAttribute.getName() === mutation.attributeName) {\n              attribute = targetAttribute;\n              break;\n            }\n          }\n\n          const value = element.getAttribute(mutation.attributeName); // If no attribute found add it.\n\n          if (!attribute) {\n            if (value) {\n              component.addAttribute(element, mutation.attributeName, value);\n            }\n\n            continue;\n          } // Update attribute.\n\n\n          attribute.setValue(value);\n          component.updateAttribute(attribute);\n        }\n      } // Remove old components.\n\n\n      if (componentsToRemove.length > 0) {\n        removeComponents(...componentsToRemove);\n      } // Add new components.\n\n\n      if (componentsToAdd.length > 0) {\n        addComponents(...componentsToAdd);\n      } // Set as NOT updating.\n\n\n      isUpdating = false; // If there are any mutation to handle then handle them.\n\n      if (mutations.length > 0) {\n        handleMutation();\n        return;\n      } // If there are any triggers then trigger an update.\n\n\n      if (Object.getOwnPropertySymbols(triggers).length > 0) {\n        this.update();\n      }\n    };\n  }\n\n}", "import Doars from '@doars/doars'; // Setup doars instance.\n\nconst setup = function () {\n  new Doars().enable();\n}; // Setup when document is ready.\n\n\nif (document.readyState === 'complete' || document.readyState === 'interactive') {\n  setup();\n} else {\n  document.addEventListener('DOMContentLoaded', setup, {\n    once: true,\n    passive: true\n  });\n}\n\nwindow.copyToClipboard = text => {\n  // Create element and set content.\n  const element = document.createElement('textarea');\n  element.value = text;\n  document.body.append(element); // Select element's content.\n\n  element.select();\n  element.setSelectionRange(0, 999999); // Copy to clipboard.\n\n  document.execCommand('copy'); // Remove element.\n\n  element.remove();\n};\n\nlet count = 0;\nlet element = document.getElementById('counter-text');\n\nwindow.increment = () => {\n  count++;\n  element.setAttribute('d-text', count);\n};"],
  "mappings": "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",
  "names": ["ATTRIBUTES", "COMPONENT", "FOR", "IGNORE", "INITIALIZED", "ON", "REFERENCES", "REFERENCES_CACHE", "SYNC", "SYNC_STATE", "EventDispatcher", "events", "name", "callback", "options", "eventData", "index", "i", "parameters", "event", "EventDispatcher_default", "kebabToCamel", "text", "match", "character", "parseAttributeModifiers", "modifiers", "result", "modifier", "hyphenIndex", "key", "value", "tmpValue", "type", "parseAttributeName", "prefix", "name", "full", "directive", "keyRaw", "parseForExpression", "expression", "variables", "parseSelector", "selector", "attributes", "selectorSegment", "Attribute", "EventDispatcher_default", "component", "element", "name", "value", "isClone", "id", "ATTRIBUTES", "accessedItems", "data", "directive", "key", "keyRaw", "modifiersRaw", "modifiers", "_directive", "_keyRaw", "_key", "_modifiers", "parseAttributeName", "parseAttributeModifiers", "_value", "_data", "indexInElement", "path", "paths", "accessedAtId", "REFLECTION_METHODS", "RevocableProxy_default", "target", "handler", "revoked", "revocableHandler", "key", "parameters", "ProxyDispatcher", "EventDispatcher_default", "options", "map", "target", "path", "key", "handler", "deleted", "receiver", "value", "revocable", "RevocableProxy_default", "property", "ProxyDispatcher_default", "addAttributes", "element", "data", "name", "className", "copyAttributes", "existingNode", "newNode", "existingAttributes", "newAttributes", "attributeNamespaceURI", "attributeValue", "fromValue", "attributeName", "attribute", "i", "j", "removeAttributes", "setAttribute", "key", "value", "setAttributes", "fromString", "string", "template", "insertAfter", "reference", "node", "isSame", "a", "b", "walk", "element", "filter", "index", "iterator", "child", "morphNode", "existingNode", "newNode", "nodeType", "nodeName", "copyAttributes", "updateInput", "updateAttribute", "updateTextarea", "morphTree", "existingTree", "newTree", "options", "fromString", "updateChildren", "updateTree", "newValue", "existingValue", "name", "existingChild", "newChild", "morphed", "existingMatch", "offset", "i", "isSame", "j", "closestComponent", "element", "COMPONENT", "createContextUtils", "createContexts", "createContextsProxy", "RevocableProxy_default", "component", "attribute", "update", "extra", "results", "destroyFunctions", "after", "before", "contexts", "context", "result", "name", "destroyFunction", "data", "revocable", "target", "property", "executeExpression", "expression", "options", "triggers", "id", "destroy", "error", "TRANSITION_NAME", "transition", "type", "component", "element", "callback", "prefix", "transitionName", "dispatchEvent", "phase", "name", "value", "timeout", "requestFrame", "isDone", "selectors", "parseSelector", "addAttributes", "removeAttributes", "styles", "duration", "transitionIn", "transitionOut", "DIRECTIVE_UTILS", "executeExpression", "morphNode", "morphTree", "transition", "transitionIn", "transitionOut", "Component", "library", "element", "id", "prefix", "attributes", "hasUpdated", "isInitialized", "data", "proxy", "state", "COMPONENT", "children", "parent", "closestComponent", "_parent", "componentName", "value", "Attribute", "ProxyDispatcher_default", "directives", "key", "attribute", "directive", "triggers", "child", "dispatchEvent", "name", "directivesKeys", "index", "directiveIndex", "i", "indexInAttributes", "ignoreName", "newAttributes", "iterator", "walk", "triggerIds", "updatedAttributes", "detail", "children_default", "component", "attribute", "update", "createContextsProxy", "RevocableProxy", "children", "revocable", "target", "key", "receiver", "child", "component_default", "component", "element_default", "component", "attribute", "dispatch_default", "component", "name", "detail", "for_default", "component", "attribute", "update", "RevocableProxy", "element", "componentElement", "items", "target", "data", "FOR", "key", "revocable", "item", "inContext_default", "component", "attribute", "update", "createContexts", "callback", "triggers", "contextUpdate", "id", "context", "contexts", "destroy", "result", "nextTick_default", "component", "attribute", "update", "createContexts", "callbacks", "isSetup", "setup", "library", "handleUpdate", "stopListening", "contexts", "destroy", "callback", "parent_default", "component", "attribute", "update", "createContextsProxy", "parent", "contexts", "destroy", "references_default", "component", "attribute", "update", "RevocableProxy", "REFERENCES", "cache", "REFERENCES_CACHE", "references", "attributeIds", "id", "element", "name", "revocable", "target", "propertyKey", "receiver", "state_default", "component", "attribute", "update", "RevocableProxy", "proxy", "state", "onDelete", "target", "path", "onGet", "onSet", "revocable", "nativePromise", "isPromise", "value", "attribute_default", "component", "attribute", "executeExpression", "element", "modifiers", "set", "value", "parseSelector", "setAttributes", "key", "setAttribute", "result", "isPromise", "resultResolved", "cloak_default", "component", "attribute", "transitionIn", "element", "createVariables", "names", "values", "variables", "i", "indexInSiblings", "elements", "value", "index", "FOR", "setAfter", "component", "update", "template", "existingIndex", "element", "insertAfter", "sibling", "transitionIn", "removeAfter", "maxLength", "transitionOut", "for_default", "attribute", "executeExpression", "expression", "parseForExpression", "triggers", "id", "set", "iterable", "data", "iterableType", "isArray", "length", "keys", "key", "result", "isPromise", "resultResolved", "DECODE_LOOKUP", "DECODE_REGEXP", "decode", "string", "DECODE_REGEXP", "character", "DECODE_LOOKUP", "html_default", "component", "attribute", "executeExpression", "morphTree", "element", "modifiers", "set", "html", "decode", "i", "root", "child", "result", "isPromise", "resultResolved", "if_default", "component", "attribute", "executeExpression", "transitionIn", "transitionOut", "template", "set", "result", "data", "element", "transition", "insertAfter", "isPromise", "destroy", "component", "attribute", "INITIALIZED", "element", "name", "initialized_default", "executeExpression", "value", "handler", "detail", "EXECUTION_MODIFIERS", "KEYPRESS_MODIFIERS", "on_default", "component", "attribute", "executeExpression", "name", "key", "element", "value", "ON", "modifiers", "options", "executionModifier", "keypressModifiers", "modifier", "handler", "event", "keypressModifier", "eventKey", "execute", "now", "target", "destroy", "component", "attribute", "REFERENCES", "attributeId", "library", "componentId", "value", "REFERENCES_CACHE", "reference_default", "element", "select_default", "component", "attribute", "executeExpression", "element", "type", "set", "data", "option", "select", "checked", "result", "isPromise", "resultResolved", "show_default", "component", "attribute", "executeExpression", "transitionIn", "transitionOut", "element", "set", "data", "transition", "result", "isPromise", "resultResolved", "set", "object", "path", "value", "i", "sync_default", "symbol", "getData", "contextPrefix", "destroy", "component", "attribute", "executeExpression", "element", "isNew", "value", "pathSplit", "data", "id", "path", "handler", "set", "dataValue", "index", "values", "option", "handlerWrapper", "checked", "select", "STATE_PREFIX", "directive", "sync_default", "SYNC_STATE", "component", "attribute", "value", "syncState_default", "text_default", "component", "attribute", "executeExpression", "element", "modifiers", "set", "text", "result", "isPromise", "resultResolved", "watch_default", "component", "attribute", "executeExpression", "value", "Doars", "EventDispatcher_default", "options", "prefix", "root", "id", "isEnabled", "isUpdating", "mutations", "observer", "triggers", "components", "contexts", "children_default", "component_default", "element_default", "dispatch_default", "inContext_default", "nextTick_default", "parent_default", "references_default", "state_default", "for_default", "directives", "reference_default", "attribute_default", "html_default", "if_default", "text_default", "cloak_default", "initialized_default", "on_default", "select_default", "show_default", "syncState_default", "watch_default", "directivesNames", "directivesObject", "directivesRegexp", "directive", "handleMutation", "componentName", "ignoreName", "componentElements", "i", "addComponents", "removeComponents", "elements", "results", "resultElements", "element", "COMPONENT", "component", "Component", "_components", "index", "_contexts", "context", "attributeName", "_directives", "_triggers", "trigger", "path", "newMutations", "componentsToAdd", "componentsToRemove", "remove", "componentElement", "iterator", "walk", "ATTRIBUTES", "attribute", "add", "closestComponent", "attributes", "mutation", "currentElement", "targetAttribute", "value", "setup", "Doars", "text", "element", "count"]
}
